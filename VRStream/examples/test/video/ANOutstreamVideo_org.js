/******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};

    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {

        /******/ 		// Check if module is in cache
        /******/ 		if(installedModules[moduleId])
        /******/ 			return installedModules[moduleId].exports;

        /******/ 		// Create a new module (and put it into the cache)
        /******/ 		var module = installedModules[moduleId] = {
            /******/ 			exports: {},
            /******/ 			id: moduleId,
            /******/ 			loaded: false
            /******/ 		};

        /******/ 		// Execute the module function
        /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

        /******/ 		// Flag the module as loaded
        /******/ 		module.loaded = true;

        /******/ 		// Return the exports of the module
        /******/ 		return module.exports;
        /******/ 	}


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;

    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";

    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(0);
    /******/ })
/************************************************************************/
/******/ ([
    /* 0 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Outstream Ad Renderer module.
         * @module OutstreamRenderer
         */

            //////////////////////////////////////////////////////////////////////
            // VARIABLES
        var Outstream_AdUnit_Base_Object = __webpack_require__(1);
        //var utils = require('videoads-util-misc-general');
        //var prefix = "Outstream Renderer";
        var _logger = __webpack_require__(2);

        var _outstream_adunits = _outstream_adunits || [];
        var _pending_adunit_messages = _pending_adunit_messages || [];

        var TRACE_MESSAGE_PREFIX = "Outstream Renderer";

        /**
         *  Combine 2 JSON objects, with 1 object overriding the other. If target of combinaiton is an object, the elements of that object will be combined
         *  @param {Object} target - Object in which to populate values
         *   @param {Object} souce - Object which to populate values into target with. Values in this object will override those in target if there is a collision
         *
         */
        function combineObjectsAndSubobjects(target, source) {
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    //if the value is an object, but not an array (don't combine arrays)
                    if (target[key] !== null && typeof target[key] === "object" && !Array.isArray(target[key])) {//null also get handled as an object in javascript so it shouldn't go to the recursive logic (for VID-1978)
                        target[key] = combineObjectsAndSubobjects(target[key], source[key]);
                    } else {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        }


        function setInitialPlaybackOptions(playbackOptions, targetOptionsObject) {

            //make sure the targetOptionsObject exists
            targetOptionsObject = targetOptionsObject ? targetOptionsObject : {};

            //playback options is an array (not sure why) so lets itereate through it
            //and set options as we see them

            var optionsSet = false;

            if (playbackOptions && playbackOptions.length >= 1) {
                switch (playbackOptions[0]) {
                    case "auto_play_sound_on":
                        targetOptionsObject.initialPlayback = "auto";
                        targetOptionsObject.initialAudio = "on";
                        optionsSet = true;
                        break;
                    case "auto_play_sound_off":
                        targetOptionsObject.initialPlayback = "auto";
                        targetOptionsObject.initialAudio = "off";
                        optionsSet = true;
                        break;
                    case "click_to_play":
                        targetOptionsObject.initialPlayback = "click";
                        targetOptionsObject.initialAudio = "unknown";
                        optionsSet = true;
                        break;
                    case "mouseover":
                        targetOptionsObject.initialPlayback = "mouseover";
                        targetOptionsObject.initialAudio = "unknown";
                        optionsSet = true;
                        break;
                    case "auto_play_sound_unknown":
                        targetOptionsObject.initialPlayback = "auto";
                        targetOptionsObject.initialAudio = "unknown";
                        optionsSet = true;
                        break;
                    case "max":
                        optionsSet = false;
                        break;
                }

            }

            //if options haven't been set, use defaults
            if (!optionsSet) {
                targetOptionsObject.initialPlayback = "auto";
                targetOptionsObject.initialAudio = "off";
            }

            return targetOptionsObject;
        }


        function sendParentIframeGeometryEventToAdUnit(scrollEventData) {
            _logger.debug(TRACE_MESSAGE_PREFIX, "Parent iframe geometry update", scrollEventData);

            if (_outstream_adunits) {
                for (var i in _outstream_adunits) {
                    _outstream_adunits[i].adUnit.parentIframeGeometryUpdate(scrollEventData);
                }
            }
        }

        function setupParentIframeSizeChangeListener(scrollEventName) {
            //listen for parent iframe scroll
            try {
                window[scrollEventName] = function(e) {
                    sendParentIframeGeometryEventToAdUnit(e);
                };
            } catch (e) {

            }
        }

        function setupParentIframeGeometrySizeChanges(tagParams) {
            //listen for parent iframe geometry event
            if (tagParams.parentIframeGeometryEvent) {
                setupParentIframeSizeChangeListener(tagParams.parentIframeGeometryEvent);
            }

            //make initial size call
            if (typeof tagParams.parentIframeGeometryCb === "function") {
                try {
                    tagParams.parentIframeGeometryCb.call(this, function(e) {
                        //rename patches until Playbuzz updated their events
                        e.windowHeight = e.innerHeight;
                        e.scrollY = e.scroll;
                        sendParentIframeGeometryEventToAdUnit(e);
                    });

                } catch (e) {

                }
            }

        }

        function handleIncomingASTMessage(messageName, messagePayload, targetId) {
            _logger.log("Got AST message ", messageName, " payload", messagePayload, " target", targetId);
            var messageDelivered = false;
            if (_outstream_adunits) {
                //look at every ad unit
                for (var i in _outstream_adunits) {
                    //if target id matches, or targetId is undefined (send to all existing instances)
                    if (!targetId || _outstream_adunits[i].id === targetId) {
                        //dispatch message into adunit
                        _outstream_adunits[i].adUnit.handleMessage(messageName, messagePayload);
                        messageDelivered = true;
                    }

                }
            }

            //if we didn't find the id as active, hold the message until an ad unit with that id is created
            //undefined target ids will be handled above, or dropped here
            if (!messageDelivered && targetId) {
                if (!_pending_adunit_messages[targetId]) {
                    _pending_adunit_messages[targetId] = {};
                }

                _pending_adunit_messages[targetId].push({
                    message: messageName,
                    payload: messagePayload
                });
            }
        }



        function sendPendingMessagesToNewAdUnit(ASTAdId, curOutstreamAdUnit) {
            //if there are any pending adunit messages for this target
            if (_pending_adunit_messages[ASTAdId]) {
                for (var i in _pending_adunit_messages[ASTAdId]) {
                    //send the message to the target
                    curOutstreamAdUnit.adUnit.handleMessage(_pending_adunit_messages[ASTAdId][i].message, _pending_adunit_messages[ASTAdId][i].payload);
                }
                //remove the messages from the pending message array
                delete _pending_adunit_messages[ASTAdId];
            }
        }

        /**
         *  Main entry point for the renderer. Calling this function will cause an attempt to render an ad.
         * @param {Object} adData  - AST object containing tag data
         * @param {Funciton} eventCB - Callback function to be called when ad events (display, end, error) occour
         */
        function renderAd(adData, eventCB) {

            //let's do this before any other checks so we can turn on logging as early as possible if needed
            //even though we have a bit of repetition in our type checking
            //make sure a failure here doesn't stop the ad from loading
            try {
                //try to see if we can read apntag.debug to set the debug level
                if (typeof apntag !== "undefined" && typeof apntag.debug !== "undefined") {
                    _logger.setDebugLevel(apntag.debug);
                } else {
                    //if we can't read apntag.debug, try debugLevel in rendererOptions
                    if (typeof adData !== "undefined" && typeof adData.rendererOptions !== undefined) {
                        _logger.setDebugLevel(adData.rendererOptions.debugLevel);
                    }
                }
            } catch (e) {}

            _logger.info(TRACE_MESSAGE_PREFIX, 'Version: %%%VERSION_NUMBER_HERE%%%');


            if (adData) {

                _logger.log(TRACE_MESSAGE_PREFIX, "renderAd called with ad data " + adData.targetId + " ", adData);

                var ASTAdId = adData.uuid;
                var tagParams = adData.rendererOptions;

                var impbusOptions;
                var videoNodeOptions;

                //these are the options that are defined in the Placement from impbus
                var rendererConfigFromServer = {};


                //if adRepsonse.ad is specified
                if (adData.adResponse && adData.adResponse.ad) {
                    impbusOptions = adData.adResponse.ad;
                    if (adData.adResponse.ad.video) {
                        videoNodeOptions = adData.adResponse.ad.video;
                    }

                    //attempt to parse renderer config options from impbus
                    if (adData.adResponse.ad.renderer_config) {
                        try {
                            rendererConfigFromServer = JSON.parse(adData.adResponse.ad.renderer_config);
                        } catch (e) {}
                    }

                }


                //if tagParams is undefined, create an empty object
                tagParams = tagParams ? tagParams : {};

                //if impbusOptions is undefined, create an empty object
                impbusOptions = impbusOptions ? impbusOptions : {};

                //if videoNodeOptions is undefined, create an empty object
                videoNodeOptions = videoNodeOptions ? videoNodeOptions : {};

                var tempContent = adData.adResponse.content;

                //shim to bring video options up a level
                tagParams = combineObjectsAndSubobjects(tagParams, videoNodeOptions);

                setupParentIframeGeometrySizeChanges(tagParams);

                //using a combined object with all options in it allows us to control the precedence of local vs impbus options
                var combinedOptionsObj = combineObjectsAndSubobjects(impbusOptions, tagParams);

                //combine the renderer config object, with local options taking precednece
                combinedOptionsObj = combineObjectsAndSubobjects(rendererConfigFromServer, combinedOptionsObj);

                //try to combine the video object from the mediaiton ad node into our combined object
                //name of element with video node in it is defined in content_source
                var contentSourceType = impbusOptions.content_source;
                if (contentSourceType) {
                    if (impbusOptions[contentSourceType] && impbusOptions[contentSourceType].video) {
                        combinedOptionsObj = combineObjectsAndSubobjects(combinedOptionsObj, impbusOptions[contentSourceType].video);
                    }
                }


                //translate from how impbus defines initial playback options to outstream's representation
                combinedOptionsObj = setInitialPlaybackOptions(combinedOptionsObj.playback_methods, combinedOptionsObj);


                //convert impbus video->supports_skippable to skippable->enabled
                //ensure combinedOptionsObj has a video node, even if it's empty
                if (!combinedOptionsObj.video) {
                    combinedOptionsObj.video = {};
                }

                //ensure combinedOptionsObj has a skippable node, even if it's empty
                if (combinedOptionsObj.video && !combinedOptionsObj.video.skippable) {
                    combinedOptionsObj.video.skippable = {};
                }

                //if supports_skippable is set, and video skippable is not set, or video skippable enabled is not set
                if ((combinedOptionsObj.video && typeof combinedOptionsObj.video.supports_skippable !== undefined) && (typeof combinedOptionsObj.video.skippable.enabled === undefined)) {
                    combinedOptionsObj.video.skippable.enabled = combinedOptionsObj.video.supports_skippable;
                }

                //translate impbus vs outstream names for some objects
                combinedOptionsObj.vastXml = tempContent || combinedOptionsObj.content;
                combinedOptionsObj.targetId = adData.targetId;
                combinedOptionsObj.targetElementId = combinedOptionsObj.targetId;

                combinedOptionsObj.width = videoNodeOptions.player_width;
                combinedOptionsObj.height = videoNodeOptions.player_height;

                //ensure we have a flash options object
                combinedOptionsObj.flash = combinedOptionsObj.flash ? combinedOptionsObj.flash : {};

                //use a default URL For the flash player if it's not specified
                if (!combinedOptionsObj.flash.swf) {
                    combinedOptionsObj.flash.swf = 'http' +
                        (('https:' === window.document.location.protocol) ? 's' : '') +
                        '://acdn.adnxs.com/video/static/player/flash/adplayer/%%%FLASH_PLAYER_VERSION_NUMBER_HERE%%%/AppnexusFlashPlayer.swf';
                }


                /*
                 var xmlDoc;
                 if (window.DOMParser) {
                 parser = new DOMParser();
                 xmlDoc = parser.parseFromString(combinedOptionsObj.vastXml, "text/xml");
                 } else // Internet Explorer
                 {
                 xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                 xmlDoc.async = false;
                 xmlDoc.loadXML(combinedOptionsObj.vastXml);
                 }

                 console.log(">>>>>", xmlDoc);
                 */

                try {
                    var vastTagURLRegex = /<VASTAdTagURI>(.+)<\/VASTAdTagURI>/ig;
                    var vastTagURIRegexResult = vastTagURLRegex.exec(combinedOptionsObj.vastXml);
                    if (vastTagURLRegex && vastTagURIRegexResult.length > 0) {
                        vastTagURIRegexResult.splice(0, 1);
                        delete vastTagURIRegexResult.index;
                        delete vastTagURIRegexResult.input;

                        //remove CDATA wrapper if it exists
                        var cdataRegex = /<!\[CDATA\[(.+)]]>/ig;
                        var cdataRegexResult = cdataRegex.exec(vastTagURIRegexResult[0]);
                        cdataRegexResult.splice(0, 1);
                        delete cdataRegexResult.index;
                        delete cdataRegexResult.input;

                        //if no CDATA was removed, use the previous regex result array
                        if (!cdataRegexResult || cdataRegexResult.length === 0) {
                            cdataRegexResult = vastTagURIRegexResult;
                        }

                        _logger.log(TRACE_MESSAGE_PREFIX, "First VASTAdTagURI found in incoming VAST Tag:", '\n', cdataRegexResult[0]);
                    } else {
                        _logger.log(TRACE_MESSAGE_PREFIX, "No VASTAdTagURI found, perhaps it is a non-wrapped VAST tag, or CSM");
                    }
                } catch (ex) {}

                combinedOptionsObj.ASTadId = ASTAdId;
                combinedOptionsObj.targetWindow = window;
                combinedOptionsObj.eventCB = eventCB;
                /*
                 combinedOptionsObj.eventCB = function(){
                 console.log("Outstream CB: ", arguments)
                 eventCB.call(this,arguments);
                 }
                 */

                combinedOptionsObj.enableInlineVideoFullscreenButton = true;

                _logger.info("Outstream Renderer calling ad unit with values " + combinedOptionsObj.targetId + " ", combinedOptionsObj);

                var curOutstreamAdUnit = new Outstream_AdUnit_Base_Object();

                // This token is replaced with testing-only code in gulp file (similar to tokens for outstream and flash version numbers)
                // if doing a build for testing, stubbed out otherwise.
                //%%ADUNIT_TEST_CODE%%//

                curOutstreamAdUnit.init(combinedOptionsObj);
                _outstream_adunits.push({
                    id: adData.targetId,
                    adUnit: curOutstreamAdUnit
                });
                sendPendingMessagesToNewAdUnit(ASTAdId, curOutstreamAdUnit);
                //initialize outstream ad
            } else {
                _logger.debug("Outstream Renderer - no ad data");

            }
        }

        //enable for RAD-828/VID-1332 support

        module.exports = {
            renderAd: renderAd,
            notify: handleIncomingASTMessage
        };


        //disable for RAD-828/VID-1332 support
        //module.exports = renderAd;


        //if AST exists, register our handler callback on it
        var rendererTypeId = 2;
        if (typeof apntag === 'object' && typeof apntag.registerRenderer === 'function') {
            apntag.registerRenderer(rendererTypeId, module.exports);
        } else {
            apntag_pendingRenderers = typeof apntag_pendingRenderers !== 'undefined' ? apntag_pendingRenderers : [];
            apntag_pendingRenderers.push({
                type: rendererTypeId,
                handler: renderAd,
                notify: handleIncomingASTMessage
            });
        }


        /***/ },
    /* 1 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * OutstreamAdunit
         * @module OutstreamAdunit
         */


        var prefixOfLog = "Outstream_Main";
        var APN_Logger = __webpack_require__(2);
        // var debug = function (message) {
        //     APN_Logger.verbose(message, prefixOfLog);
        // };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        var info = function (message) {
            APN_Logger.info(message, prefixOfLog);
        };


        /**
         * video player manager object
         * @type {*|exports|module.exports}
         */
        var PlayerManager_object = __webpack_require__(3);
        var AdHandler = __webpack_require__(28);


        /**
         * outstreamadunit class start point is init()
         */
        var outstreamadunit = function () {

            info("Outstream starts to initialize");

            //flags for Outstream
            this.playerManager = Object.create(PlayerManager_object);//clone video player manager object for multiple instances
            this.disableCollapse = undefined;
            this.targetElementId = undefined;
            this.ASTadId = undefined;
            this.isDoneLoadVideo = false;//flag to notify video load
            this.isAlreadyCompleted = false;//flag to avoid to invoke adComplete twice
            this.triggerCheckFocus = null;//id of interval for checking a focus in window
            this.rWindow = window.self;//Reference of window object
            this.targetElement = {};//Object for div including video player
            this.videoPlayerObjectElement = {};//return video object's element
            this.videoIsreadyToPlay = false;//Return true if video is ready to play when video object loaded metadata from server.
            this.isVideoRendered = false;//Return true if video is ready to play when video object loaded metadata from server.Especially this is used for videoRead
            this.hasFocus = false;//detecting document has focus every 0.5 seconds
            this.isFlash = false;
            this.animationSpeed = undefined;
            this.isExpandTransitionCompleted = false;
            this.isAreadyTerminated = false;//flag to avoid double terminating
            this.shouldResizeByFullscreenChange = false;
            this.intervalIdForDetectAndPlay = undefined;
            this.isCollapseEnd = false;
            this.isCollapseStart = false;
            this.isAdComplete = false;
            this.TIME_TO_REVERIFY = 100;
            this.isMutedByViewability = false;
            this.doneInitialPlayback = false;
            this.hasDoneFakingAutoStartForAndroid = false;
            this.originalSize = {width: 0, height: 0};
            this.sideStream = null;
            this.firstAdAttempted = false;
            this.viewableDetector = {};
            this.isOkToPlayFromPublisher = true;
            this.isTerminatedByPublisher = false;
            this.currentEventFromCrossDomainWindow = {offsetTop:0,windowHeight:0};
            this.isExpanded = false;
            this.rWindowForPublisher = null;
            this.isWindowTopAccessible = true;
            this.options = null;
            this.haveVideoThresholdForSideStream = false;
            this.isExpandedWhenFlash = false;
            this.sizeObj = {};//to save orignal size and final size of Outstream
            this.DEFAULT_OPTIONS_FOR_OUTSTREAM = __webpack_require__(40);
            this.cbType = {loaded: "loaded", ended: "ended", error: "error", impression: "impression"};//define callback type for AST tag
            this.cbNotificationType = {error: "error", adComplete: "adComplete", expandStart: "expandStart", expandEnd: "expandEnd", collapseStart: "collapseStart", collapseEnd: "collapseEnd", timeout: "timeout", size: "renderedPlayerSize", waterfall :"waterfall"};//define cbNotifications
            this.doneUserActionForInitiateOutstream = false;




            //major object
            var outstreamSelf = this;//main object instantiated to point this module itself internally
            this.videoPlayer = PlayerManager_object;//expose video player for having backward compativbility
            this.AdHandler = AdHandler;//expose AdHandler for having backward compativbility


            //internal modules
            var Initialize = __webpack_require__(41)(outstreamSelf);
            var Termination = __webpack_require__(45)(outstreamSelf);
            var Mobile = __webpack_require__(46)(outstreamSelf);
            var Waterfall = __webpack_require__(47)(outstreamSelf);
            var ExternalInterface = __webpack_require__(48)(outstreamSelf);
            var Media = __webpack_require__(49)(outstreamSelf);
            var Events = __webpack_require__(50)(outstreamSelf);


            //Initialize
            this.init = Initialize.init;//starting point of this adUnit
            this.start = Initialize.start;
            this.setInitialVariable = Initialize.setInitialVariable;
            this.getTargetWindow = Initialize.getTargetWindow;
            this.checkTopWindow = Initialize.checkTopWindow;


            //Mobile
            this.createAndroidIframes = Mobile.createAndroidIframes;
            this.handleFullscreen = Mobile.handleFullscreen;
            this.fnRotationChange = Mobile.fnRotationChange;
            this.resizeOutstreamArea = Mobile.resizeOutstreamArea;


            //Waterfall
            this.cleanupTargetElement = Waterfall.cleanupTargetElement;
            this.cleanupPreviousFlashElement = Waterfall.cleanupPreviousFlashElement;


            //External Interface
            this.handleMessage = ExternalInterface.handleMessage;//handle message can be called by renderer to send ast messages and payloads to outstream
            this.parentIframeGeometryUpdate = ExternalInterface.parentIframeGeometryUpdate;//public method to be invoked by ASTRenderer
            this.handleOkToPlayAd = ExternalInterface.handleOkToPlayAd;
            this.cbNotification = ExternalInterface.cbNotification;
            this.eventCB = ExternalInterface.eventCB;
            this.cbNotification_internal = ExternalInterface.cbNotification_internal;
            this.eventCB_internal = ExternalInterface.eventCB_internal;
            this.reportFinalSize = ExternalInterface.reportFinalSize;


            //Events and AdUnit behavior
            this.listenerBlur = Events.listenerBlur;
            this.listenerFocus = Events.listenerFocus;
            this.setIsExpanded = Events.setIsExpanded;
            this.expandArea = Events.expandArea;
            this.detectAndPlay = Events.detectAndPlay;
            this.isElementVisible = Events.isElementVisible;


            //Media
            this.isPlayingVideo = Media.isPlayingVideo;
            this.sendPlaySignalToVideoPlayerExplicit = Media.sendPlaySignalToVideoPlayerExplicit;
            this.sendPlaySignalToVideoPlayer = Media.sendPlaySignalToVideoPlayer;
            this.sendPauseSignalToVideoPlayerExplicit = Media.sendPauseSignalToVideoPlayerExplicit;
            this.sendPauseSignalToVideoPlayer = Media.sendPauseSignalToVideoPlayer;


            //Termination
            this.terminateAll = Termination;


        };

        module.exports = outstreamadunit;
        /*
         //public method
         this.init = function (_options) {
         this.injectEvent = function (e) {
         this.videoPlayer = PlayerManager_object;//expose video player for having backward compativbility
         this.AdHandler = AdHandler;//expose AdHandler for having backward compativbility
         */


        /***/ },
    /* 2 */
    /***/ function(module, exports) {

        /**
         * Client Side Logging module.
         * @module Logging
         */


            //Note that we have an excessive amount of try/catch blocks in this code.
            //That is intentional. Logging should never break the features which are using it

        var TRACE_LEVEL_SILENT = 0;
        var TRACE_LEVEL_ALWAYS = 1;
        var TRACE_LEVEL_ERROR = 2;
        var TRACE_LEVEL_WARN = 3;
        var TRACE_LEVEL_INFO = 4;
        var TRACE_LEVEL_LOG = 5;
        var TRACE_LEVEL_DEBUG = 6;
        var TRACE_LEVEL_VERBOSE = 6;

        //not an actual debug level, but used as a shortcut so we always
        //know what the max debug level is
        var TRACE_LEVEL_ALL = TRACE_LEVEL_DEBUG;
        var TRACE_LEVEL_DEFAULT = TRACE_LEVEL_SILENT;

        //the current debug level to use
        var _curDebugLevel;

        //the debug level that was set via querystring
        var _debugLevelQueryString = TRACE_LEVEL_DEFAULT;

        //the debug level that was set via call to setDebugLevel
        var _debugLevelFunctionSet = TRACE_LEVEL_DEFAULT;


        function getTraceMethodName(messageLogLevel) {
            switch (messageLogLevel) {
                case 0:
                    break;
                case 1:
                    return 'always';
                case 2:
                    return 'error';
                case 3:
                    return 'warn';
                case 4:
                    return 'info';
                case 5:
                    return 'log';
                case 6:
                    return 'debug';
                case 7:
                    return 'verbose';
                default:
                    break;
            }
        }

        function traceMessageAtLevel(messageLogLevel, args) {

            try {
                //if method has been defined, and the correct debug level has been set, log it
                if (typeof messageLogLevel !== 'undefined' && okToLogMessage(messageLogLevel)) {
                    if (console) {
                        var messagePrefix = "[APN";
                        var methodToUse = getTraceMethodName(messageLogLevel);

                        //if console message doesn't exist, use 'log' and
                        //set the original method in the message prefix
                        if (!console[methodToUse]) {
                            messagePrefix += "-" + methodToUse;
                            methodToUse = 'log';
                        }
                        messagePrefix += "]";

                        args.splice(0, 0, messagePrefix);
                        //from http://tobyho.com/2012/07/27/taking-over-console-log/
                        if (console[methodToUse].apply) {
                            console[methodToUse].apply(console, args);
                        } else {
                            var message = Array.prototype.slice.apply(args).join('');
                            console[methodToUse](message);
                        }
                    }
                }
            } catch (e) {}
        }


        //get a named parameter from the querystring
        function getParameterByName(name) {
            //accesing window might fail at the browser level, we can't really test for it,
            //so there are a few nested try/catch blocks here
            try {
                var urlToSearch = '';
                //try checking the topmost window, and if not, use current window
                try {
                    urlToSearch = window.top.location.search;
                } catch (e) {
                    try {
                        urlToSearch = window.location.search;
                    } catch (e) {}
                }

                var regexS = '[\\?&]' + name + '=([^&#]*)';
                var regex = new RegExp(regexS);
                var results = regex.exec(urlToSearch);
                if (results === null) {
                    return '';
                }
                return decodeURIComponent(results[1].replace(/\+/g, ' '));
            } catch (e) {
                return '';
            }
        }

        function parseDebugLevelInput(incomingDebugLevel) {
            var debugLevelToReturn = TRACE_LEVEL_DEFAULT;
            try {
                if (typeof incomingDebugLevel !== "undefined") {
                    var debugLevelToParseInt = parseInt(incomingDebugLevel);
                    //if level is an integer, treat it as such
                    if (!isNaN(debugLevelToParseInt)) {
                        debugLevelToReturn = debugLevelToParseInt;
                    } else {
                        if (typeof incomingDebugLevel === "boolean") {
                            if (incomingDebugLevel) {
                                debugLevelToReturn = TRACE_LEVEL_ALL;
                            } else {
                                debugLevelToReturn = TRACE_LEVEL_SILENT;
                            }
                        } else {
                            //not an integer or boolean, treat it as a string
                            incomingDebugLevel = incomingDebugLevel.toUpperCase();
                            if (incomingDebugLevel === "TRUE") {
                                debugLevelToReturn = TRACE_LEVEL_ALL;
                            } else {
                                if (incomingDebugLevel === "FALSE") {
                                    debugLevelToReturn = TRACE_LEVEL_SILENT;
                                }
                            }
                        }
                    }
                }
            } catch (e) {}

            return debugLevelToReturn;
        }

        //determine the maximum debug level from the page URL
        function setDebugLevelFromPageUrl() {
            try {
                //keep track of the new level
                _debugLevelQueryString = parseDebugLevelInput(getParameterByName("ast_debug").toUpperCase());

                _debugLevelQueryString = "TRUE";

                //the highest (least restrictive debug level) always wins
                _curDebugLevel = Math.max(_debugLevelQueryString, _debugLevelFunctionSet);
            } catch (e) {}
        }

        function handleSetDebugLevel(newDebugLevel) {
            try {
                //keep track of the new level
                _debugLevelFunctionSet = parseDebugLevelInput(newDebugLevel);

                //the highest (least restrictive debug level) always wins
                _curDebugLevel = Math.max(_debugLevelQueryString, _debugLevelFunctionSet);
            } catch (e) {}
        }

        function okToLogMessage() {
            //return level <= _curDebugLevel; // getReqestedMaxDebugLevel();
            return true;
        }


        //DEPRECATED
        function tryLogMessageLegacy(level, message, source) {
            try {
                var messageToLog = "[APN-" + level + "-" + new Date().toISOString() + "] ";
                if (source !== null && source && source.length > 0) {
                    messageToLog += source + ">";
                }
                messageToLog += message;

                if (okToLogMessage(level)) {
                    console.log(messageToLog);
                }
            } catch (ex) {
                if (okToLogMessage(level)) {
                    console.log(ex);
                }
            }
        }

        module.exports = {


            /**
             * Call the appropriate trace method at the given level
             * @param (string) debugLevel = Level to debug at
             */
            traceAtLevel: function() {
                try {
                    if (arguments.length > 0) {
                        var targetTraceLevel = arguments[0];
                        var argsWithoutTraceLevel = Array.prototype.slice.call(arguments, 1);
                        traceMessageAtLevel.call(this, targetTraceLevel, argsWithoutTraceLevel);
                    }
                } catch (e) {}
            },

            /**
             * If the logging level for type "always" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "log" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.log style logging.
             */
            always: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_ALWAYS, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },


            /**
             * If the logging level for type "error" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "error" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.error style logging.
             */
            error: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_ERROR, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },

            /**
             * If the logging level for type "log" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "log" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.log style logging.
             */
            log: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_LOG, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },

            /**
             * If the logging level for type "warn" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "warn" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.warn style logging.
             */
            warn: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_WARN, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },

            /**
             * If the logging level for type "info" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "info" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.info style logging.
             */
            info: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_INFO, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },

            /**
             * If the logging level for type "debug" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "debug" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.debug style logging.
             */
            debug: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_DEBUG, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },

            /**
             * If the logging level for type "verbose" or higher is set, output message to browser's console log
             * With the [APN] prefix and styled with the browser's console "debug" level trace style
             * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
             * for more details about how to use console.debug style logging.
             */
            verbose: function() {
                try {
                    traceMessageAtLevel.call(this, TRACE_LEVEL_VERBOSE, Array.prototype.slice.call(arguments));
                } catch (e) {}
            },

            /**
             * @deprecated - use other logging methods in this library
             * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
             * @param (string) message = text to be written to the log
             * @param (string) source = optional string which identifies the source of the debug statement
             *      - if present, then it will be prepended to front of the string
             *      - example 1:  debug("hello") ==> <timestamp> hello
             *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
             */
            handleLogDebugLegacySupport: function(message, source) {
                /*
                 var mainArguments = Array.prototype.slice.call(arguments);
                 mainArguments.unshift("DEBUG");
                 */
                try {
                    tryLogMessageLegacy(TRACE_LEVEL_LOG, message, source);
                } catch (e) {}
            },

            /**
             * Sets debug level for logger
             * @param (string) level = Debug level to use
             */
            setDebugLevel: function(newLevel) {
                try {
                    handleSetDebugLevel(newLevel);
                } catch (e) {}
            },


            /**
             * Checks if specified trace level will be emitted given the current trace level settings.
             * @param (Number) levelToCheck = Debug level to check
             */
            isTraceLevelActive: function(levelToCheck) {
                try {
                    return okToLogMessage(levelToCheck);
                } catch (e) {
                    return false;
                }
            },

            /** @constant {number} */
            TRACE_LEVEL_ALWAYS: TRACE_LEVEL_ALWAYS,

            /** @constant {number} */
            TRACE_LEVEL_ERROR: TRACE_LEVEL_ERROR,

            /** @constant {number} */
            TRACE_LEVEL_WARN: TRACE_LEVEL_WARN,

            /** @constant {number} */
            TRACE_LEVEL_INFO: TRACE_LEVEL_INFO,

            /** @constant {number} */
            TRACE_LEVEL_LOG: TRACE_LEVEL_LOG,

            /** @constant {number} */
            TRACE_LEVEL_DEBUG: TRACE_LEVEL_DEBUG,

            /** @constant {number} */
            TRACE_LEVEL_VERBOSE: TRACE_LEVEL_VERBOSE
        };


        //look in the query string for debug level
        setDebugLevelFromPageUrl();


        /***/ },
    /* 3 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Ad Video Player Manager module.
         * @module AdVideoPlayerManager
         */

            //define reference of required modules
        var VideoJSPlayer = __webpack_require__(4);
        var BuildPlayerObj = __webpack_require__(7);
        var JSVpaidPlayer = __webpack_require__(21);
        var ExtendDefaultOption = __webpack_require__(22);
        var VideoSizeHandler = __webpack_require__(20);
        var MobileSupport = __webpack_require__(23);
        var DelayEventHandler = __webpack_require__(9).DelayEventHandler;
        var unique = __webpack_require__(9).unique();
        var CustomSkinning = __webpack_require__(24);
        var ViewabilityTracking = __webpack_require__(26);


        var CONST_MESSAGE_VIDEO_FAILED = "'video_failed' reported from Flash player";
        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);
        var externalNameOfVideoPlayer = "APNVideo_Player_" + UID;


        var prefixOfLog = "[PlayerManager_Main]";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(prefixOfLog, message);
        };
        var error = function (message) {
            APN_Logger.error(prefixOfLog, message);
        };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };



        var isIE11 = function () {
            var index = navigator.userAgent.indexOf("Trident/7.0");
            return (index > -1);
        };

        //for VID-1551
        var EVENTS_HAVE_TO_FILTER_OUT = ["AdPaused","AdVolumeChange"];

        var EVENTS_RESTRICTED_SUPPRESSING = [
            "AdLoaded",
            // "AdStarted", //need to disscuss with Vikki or Jeff but I'm assuming this also should suppressed because the startAd will be invoked by programmatically instead of human activity
            "AdStopped",
            "AdSkippableStateChange",
            "AdLinearChange",
            "AdDurationChange",
            "AdRemainingTimeChange",
            "AdLog",
            "AdError"
        ];

        var ERROR_TYPE_VAST = 1;//vast-error (one of the error codes specified in the VAST spec)
        var VAST_ERROR_TIMEOUT = 402;
        var VAST_ERROR_UNDEFINED = 900;
        var VAST_ERROR_VIDEOFAILED = 405;


        /*
         apply Vikki and Eugene's following opinion
         We proposed to change initialPlayback to auto, initialAudio to off. Add the following options: vpaidTimeout : 5000, waterfallTimeout : 30000, waterfallSteps : -1
         */
        //define default option for playerManager which can be overrided if it deosn't exists
        var DEFAILT_OPTIONS_FOR_PLAYER_MANAGER = {
            "initialPlayback": "auto",
            "initialAudio": "off",
            "skippable": {
                "enabled": true,
                "videoThreshold": 15,
                "videoOffset": 5,
                "skipLocation": "top-left",
                "skipText": "Video can be skipped in %%TIME%% seconds",
                "skipButtonText": "SKIP"
            },
            "adText": "Ad",
            "showMute": true,
            "showVolume": true,
            "showProgressBar": true,
            "showPlayToggle": true,
            "showBigPlayButton": true,
            "allowFullscreen": true,
            "playerSkin": {
                "customPlayerSkin":"",
                "topDividerColor": "#606060",
                "bottomDividerColor": "#606060",
                "topDividerWidth": 1,
                "bottomDividerWidth": 1
            },
            "enableInlineVideoForIos": true,
            "delayExpandUntilVPAIDInit":false,
            "delayExpandUntilVPAIDImpression": false,
            "flash": {"swf": "http://acdn.adnxs.com/video/player/vastPlayer/AppnexusFlashPlayer.swf"},
            "vpaidTimeout": 5000,
            "waterfallTimeout": 30000,
            "waterfallSteps": -1,
            "fixedSizePlayer": true,
            "disableTopBar": false,
            "sideStream": {
                "enabled": false,
                "position": "bottom-right",
                "xOffset": 0,
                "yOffset": 0,
                "space": "empty"
            },
            "sideStreamObject":{},
            "preloadInlineAudioForIos": false,
            "controlBarPosition": "over",
            "customPlayerSkinCss": "",
            "customButton": {
                "enabled":false,
                "url":"",
                "altText":"",
                "imageSrc":"",
                "imgWidth": 50,
                "imgHeight": 30
            },
            "enableNativeInline": false
        };



        /**
         * adVideoPlayerManager function
         * @type {{externalNameOfVideoPlayer: string, videoPlayerObj, mobileSupport, options: {}, adVideoPlayer: {}, callbackForAdUnit: {}, vpaidData: {}, iframeVideoWrapper: {}, isPlayingVideo: boolean, isDoneInitialPlay: boolean, isFullscreen: boolean, heightOffset: number, explicitPaused: boolean, aspectRatio: number, videoObjectId: {}, isViewable: boolean, isSkipped: boolean, isCompleted: boolean, isMuted: boolean, isExplicitMuted: boolean, isChrome: boolean, videojs_vpaid, overlayPlayer: boolean, forceToSkip: boolean, ExtendDefaultOption, delayEventHandler: null, pausedByViewability: boolean, init: adVideoPlayerManager.init, getValueFromPlayer: adVideoPlayerManager.getValueFromPlayer, isIosInlineRequired: adVideoPlayerManager.isIosInlineRequired, decidePlayer: adVideoPlayerManager.decidePlayer, buildPlayer: adVideoPlayerManager.buildPlayer, getPlayerStatus: adVideoPlayerManager.getPlayerStatus, notifyPlayer: adVideoPlayerManager.notifyPlayer, load: adVideoPlayerManager.load, play: adVideoPlayerManager.play, pause: adVideoPlayerManager.pause, explicitPause: adVideoPlayerManager.explicitPause, explicitPlay: adVideoPlayerManager.explicitPlay, mute: adVideoPlayerManager.mute, explicitMute: adVideoPlayerManager.explicitMute, unmute: adVideoPlayerManager.unmute, explicitUnmute: adVideoPlayerManager.explicitUnmute, mouseIn: adVideoPlayerManager.mouseIn, mouseOut: adVideoPlayerManager.mouseOut, destroy: adVideoPlayerManager.destroy, destroyWithoutSkip: adVideoPlayerManager.destroyWithoutSkip, getVideoObject: adVideoPlayerManager.getVideoObject, handlePlayerNotification: adVideoPlayerManager.handlePlayerNotification, handleOverlayNotification: adVideoPlayerManager.handleOverlayNotification, notifyVpaidEvent: adVideoPlayerManager.notifyVpaidEvent, notifyVpaidEvent_internal: adVideoPlayerManager.notifyVpaidEvent_internal, setChromeSize: adVideoPlayerManager.setChromeSize, click: adVideoPlayerManager.click, getRapamsAndExtensions: adVideoPlayerManager.getRapamsAndExtensions, dispatchEventToAdunit: adVideoPlayerManager.dispatchEventToAdunit, dispatchEventToAdunit_internal: adVideoPlayerManager.dispatchEventToAdunit_internal, resizeVideo: adVideoPlayerManager.resizeVideo, isIosInlineRequired: adVideoPlayerManager.isIosInlineRequired, resizePlayer: adVideoPlayerManager.resizePlayer, getFinalSize: adVideoPlayerManager.getFinalSize, log: log, debug: debug}}
         */
        var adVideoPlayerManager = {

            //binding objects for sub module
            externalNameOfVideoPlayer: externalNameOfVideoPlayer,
            videoPlayerObj: VideoJSPlayer,
            mobileSupport: MobileSupport,
            customSkinning: CustomSkinning,
            options: {},
            adVideoPlayer: {},
            callbackForAdUnit: {},//callback in adunit
            vpaidData: {},
            iframeVideoWrapper: {},
            isPlayingVideo: false,
            isDoneInitialPlay: false,
            isFullscreen: false,
            heightOffset: 0,
            explicitPaused: false,
            aspectRatio: 0,
            videoObjectId: {},
            isViewable: false,
            isSkipped: false,
            isCompleted: false,
            isMuted: false,
            isExplicitMuted: false,
            hasBeenUnmuted: false,
            isChrome: (navigator.userAgent.indexOf("Chrome") > -1),
            videojs_vpaid: JSVpaidPlayer,
            overlayPlayer: false,
            forceToSkip: false,
            ExtendDefaultOption:ExtendDefaultOption,
            delayEventHandler: null,
            pausedByViewability: false,
            mutedByVisibility: false,
            gotAdImpressionForFlash: false,
            gotAdStartedForFlash: false,
            isReadyToExpandForMobile: false,
            isAlreadyPlaingForVPAID: false,
            isSideStreamActivated: false,//this will be set after options.sideStream maxPageOverlay processed by its own logic
            isExpanded: false,
            isVideoCompleteInjected: false,
            isFullscreenToggled: false,//for VID-2558 VID-2554 Safari, Chrome browsers response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation
            toggleWindowFocus: true,//toggle flag to know whether current window has a focus or not
            viewabilityTracking: null,
            isDoneFirstLoadStart: false,

            /**
             * a start point for initializing playerManager
             * @param _options
             */
            init: function(_options) {
                var extendedOptions = ExtendDefaultOption(DEFAILT_OPTIONS_FOR_PLAYER_MANAGER,_options);//if optons doesn't have default variables for playerManager level, overrides it
                this.options = extendedOptions;//TODO minthe : it will be better not to set at this time but remain this until code has more stable & clear state.

                this.delayEventHandler = new DelayEventHandler();//make instance of delay event handling
                //set event delay handler
                this.delayEventHandler.suppress(this.options.delayExpandUntilVPAIDImpression);
                this.delayEventHandler.start();

                //activate appnexus viewability
                this.viewabilityTracking = new ViewabilityTracking();


                return extendedOptions;
            },

            getValueFromPlayer: function (param) {

                //this is just for iOS inline video, height of toolbar which will be added to video area. this is required to show whole area of video with controlbar
                var result = 0;
                try {
                    if (param === "controlBar.height") {
                        if (this.adVideoPlayer && this.adVideoPlayer.controlBar && this.adVideoPlayer.controlBar.height && typeof this.adVideoPlayer.controlBar.height === "function" && this.decidePlayer(this.options.requiredPlayer) === 'html5') {
                            result = this.adVideoPlayer.controlBar.height();
                        }
                    }
                } catch (ex) {
                    error(ex);
                }

                return result;
            },

            /**
             * return decision what to use for player
             * @returns {string}
             */
            decidePlayer: function (arrTech) {

                /*
                 parameter arrTech will have a result from rendition manager as this.options.requiredPlayer
                 Expected requiredPlayer from Rendition manager is :
                 0 - any,
                 1 - html5,
                 2 - flash
                 this result will be decided by Rendition Manager Module with VAST XML
                 */

                /*
                 summary of result from rendition manager
                 rendition manager returns 0 when it doesn't find any specific playable format for each of technology between html5 and flash
                 if the "type" attribute of "<MediaFile>" element of vast XML has...
                 'video/x-flv', 'video/x-f4v','video/f4v', 'application/x-shockwave-flash' then rendition manager will return flash
                 'video/webm','video/ogg','application/javascript','application/x-javascript' then rendition manager will return html5
                 all the other case rendition manager will return 0
                 */

                /*
                 special cases verified with Eugene
                 VPAID ad is always favorable by Rendition Manager so if VAST tag has VPAID creative, Rendtional Manager will try to choose VPAID one
                 and If VAST has both JSVPAID and FLASH-VPAID the selection will be depending on playerTechnology
                 */

                var result = "";
                var TECH_FLASH = "flash";
                var TECH_HTML5 = "html5";

                var isMobile = function () {
                    var index = navigator.appVersion.indexOf("Mobile");
                    var indexForAndroid = navigator.appVersion.indexOf("Android");
                    return (index > -1) || (indexForAndroid > -1);
                };


                //fix VID-1069
                var playerTechnology = this.options.playerTechnology;//possible scenario : ["flash"], ["html5"], ["html5","flash"], ["flash","html5"]


                //if playerTechnology is either of html5 and flash
                if (playerTechnology && playerTechnology.length && playerTechnology.length === 1) {
                    switch (arrTech) {
                        case 1:
                            result = TECH_HTML5;
                            break;
                        case 2:
                            result = TECH_FLASH;
                            break;
                        case 0:
                            result = (playerTechnology[0] === TECH_HTML5) ? TECH_HTML5 : TECH_FLASH;
                            break;
                    }
                }

                //if playerTechnology has both html5 and flash
                if (playerTechnology && playerTechnology.length && playerTechnology.length === 2) {
                    switch (arrTech) {
                        case 1:
                            result = TECH_HTML5;
                            break;
                        case 2:
                            result = TECH_FLASH;
                            break;
                        case 0:
                            //for VID-1069 (kyungsuk)
                            //confirmed with Jeff Outstream will favor HTML5 for this case even through Flash was listed first
                            //a case for (arrTech==0 and jsVpaid==true) won't be happend by Rendition manager. if there's the case, AdHandler will destroy framework with error. this is confirmed with Eugene
                            result = TECH_HTML5;
                            break;
                    }
                }

                if (isMobile()) {//if it's mobile this manager will always choose html5
                    result = TECH_HTML5;
                }

                return result;

            },

            /** Build Player.
             @param {Object} options - Options used to construct video player.
             @param {Object} eventHandlerCallback - Messages from player will be called on this function.
             */
            buildPlayer: function (_callbackForAdUnit, _options) {



                //register options and callbackForAdUnit
                //this.options = _options;//deprecated it will be done at init method
                this.callbackForAdUnit = _callbackForAdUnit;
                if (_options.hasOwnProperty('overlayPlayer')) {
                    this.overlayPlayer = _options.overlayPlayer;
                    if (_options.hasOwnProperty('fullscreenMode')) {
                        _options.allowFullscreen = false;
                    }
                }

                if (isIE11() && this.decidePlayer(this.options.requiredPlayer) === "flash") {
                    //do nothing for now
                } else if (this.options.targetElement && !this.options.firstAdAttempted) {
                    this.options.targetElement.style.visibility = "hidden";
                }

                var UID = new Date().getTime() + Math.floor(Math.random() * 10000);
                var externalNameOfVideoPlayer = "APNVideo_Player_" + UID;
                this.externalNameOfVideoPlayer = externalNameOfVideoPlayer;

                BuildPlayerObj(_callbackForAdUnit, _options, this);

            },

            /** Get current property state of player.
             @param {String} propertyName - Property name to get.
             @returns {Object} Value of requested propertyName
             */
            //getPlayerProperty: function (propertyName) {
            //    return null;
            //},

            /** Get entire player status object.
             @returns {Object} Representation of all player status values (playerState, audioState etc)
             */
            getPlayerStatus: function () {

            },

            /** Send notification to the player
             @param {String} notifiactionName - notification name.
             @param {Object} notifiactionValue - notification value.
             */
            notifyPlayer: function (notifiactionName, notifiactionValue) {
                this.adVideoPlayer.handleAdUnitNotification({name: notifiactionName, value: notifiactionValue});
            },

            load: function () {

                if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
                    debug("load video");
                    try {
                        if (this.adVideoPlayer && this.adVideoPlayer !== undefined && this.adVideoPlayer.load && typeof this.adVideoPlayer.load === "function") {
                            // VID-2517 Force the video tag to be in non autoplay state and autoplay is handled by explicitly by ad unit.
                            if(this.options.delayExpandUntilVPAIDImpression &&  this.adVideoPlayer.player() && this.adVideoPlayer.player().autoplay()){
                                this.adVideoPlayer.player().autoplay(false);
                            }
                            this.adVideoPlayer.load();
                        }
                    } catch (ex) {
                        error(ex);
                    }

                }

            },

            /**
             * play video
             */
            play: function () {

                //remedy for fixing a bug on iOS10.1 - iOS10.1 has a bug to break a div which has overflow = "hidden" after entering fullscreen where their native video player.
                var needApplePatchForIos10 = MobileSupport.isMobile() && MobileSupport.iOSversion()[0] >= 10 && this.options.enableInlineVideoForIos === false;
                if (needApplePatchForIos10) {
                    var _playerManager = this;
                    if (_playerManager.overlayPlayer) {
                        _playerManager.options.targetElement.style.overflow = "";
                    } else {
                        setTimeout(function() {
                            _playerManager.options.targetElement.style.overflow = "";
                        }, _playerManager.options.expandTime);
                    }
                }

                //this.destroyWithoutSkip(true, "error occurred",null,900);

                this.isAlreadyPlaingForVPAID = true;

                if (this.isCompleted) {
                    return;
                }
                debug("play video");


                //this is for VID-1820 : sending event should be prior than invoking actual play method because that play method will cause another event like "firstPlay" which could give us a flag (this.isDoneInitialPlay == true).
                if (this.isDoneInitialPlay) {
                    if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
                        if (!this.isPlayingVideo) {
                            this.dispatchEventToAdunit({"name": "video_resume"});
                        }
                    }
                    else if (!this.isPlayingVideo) {
                        this.dispatchEventToAdunit({"name": "video_resume"});
                    }
                } else {
                    // handle impression only for video cases.
                    if(!this.options.vpaid){
                        this.dispatchEventToAdunit({"name": "video_start"});
                        this.dispatchEventToAdunit({"name": "video_impression"});
                    }
                }


                if (this.options.vpaid && this.isIosInlineRequired()) {
                    if (!this.isDoneInitialPlay) {
                        this.adVideoPlayer.trigger('play');//jsvpaid in iOS inline should have this call instead of .play() in order to get "AdStarted" event for JSVPAID after that, framework will have proper video url which is set by JSVPAID creative
                    } else {
                        this.adVideoPlayer.play();//for resuming video
                    }

                } else {
                    this.adVideoPlayer.play();
                }




                if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
                } else {
                    this.isPlayingVideo = true;
                }

                this.isDoneInitialPlay = true;


            },


            /**
             * pause video
             */
            pause: function () {
                if (this.isPlayingVideo) {
                    debug("pause video");


                    this.adVideoPlayer.pause();

                    if (!this.isCompleted) {
                        this.dispatchEventToAdunit({"name": "video_pause"});
                    }

                }

            },

            /**
             * explicit pause a video
             */
            explicitPause: function () {
                debug("explicit pause video");
                this.explicitPaused = true;
                this.pause();
            },

            /**
             * explicit play a video
             * @constructor
             */
            explicitPlay: function () {
                debug("explicit play video");
                this.explicitPaused = false;
                this.play();
            },

            /**
             * mute audio
             */
            mute: function () {
                if (!this.isMuted) {
                    debug("mute audio");
                    if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
                        this.adVideoPlayer.muted(true);
                        this.dispatchEventToAdunit({"name": "video_mute"});
                    }
                    else {
                        // the flash player will notify player manager when audio is muted and then dispatchEventToAdunit for video_mute will be called
                        this.adVideoPlayer.mute();
                    }
                    this.isMuted = true;
                }
            },

            explicitMute: function () {
                debug("explicit mute video");
                this.isExplicitMuted = true;
                this.mute();
            },

            /**
             * unmute audio
             */
            unmute: function () {
                if (!this.isExplicitMuted && this.isMuted) {
                    debug("unmute audio");
                    if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
                        if (this.adVideoPlayer.muted() === true) {//if already unmuted then set flag and return;
                            this.adVideoPlayer.muted(false);
                        }
                        if (this.isMuted || this.options.initialAudio === "off") {
                            this.dispatchEventToAdunit({"name": "video_unmute"});
                        }
                    }
                    else {
                        // the flash player will notify player manager when audio is unmuted and then dispatchEventToAdunit for video_unmute will be called
                        this.adVideoPlayer.unmute();
                        this.hasBeenUnmuted = true;
                    }
                    this.isMuted = false;
                }
            },

            explicitUnmute: function () {
                this.isExplicitMuted = false;
                this.unmute();
            },

            /**
             * mouseIn (for flash only)
             */
            mouseIn: function () {
                this.adVideoPlayer.mouseIn();
            },

            /**
             * mouseOut (for flash only)
             */
            mouseOut: function () {
                this.adVideoPlayer.mouseOut();
            },

            destroy: function (isError, message) {


                this.isPlayingVideo = false;
                this.adVideoPlayer.pause();

                //invoke skip event
                if (!this.isCompleted) {
                    this.dispatchEventToAdunit({"name": "video_skip"});
                }
                this.isSkipped = true;

                //TODO all event should be clear in here
                debug("destroy");
                var code = VAST_ERROR_UNDEFINED;//Undefined Error in VPAID3.0 spec
                if (typeof this.callbackForAdUnit.cbWhenDestroy === "function") {
                    if (this.overlayPlayer) {
                        if (isError && message) {
                            this.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, true, this.options);
                        } else {
                            this.callbackForAdUnit.cbWhenDestroy(null, true, this.options);
                        }
                    }
                    else {
                        if (isError && message) {
                            this.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, null, this.options);
                        } else {
                            this.callbackForAdUnit.cbWhenDestroy(null, null, this.options);
                        }
                    }
                }
            },

            destroyWithoutSkip: function (isError, message, timeout, errCode) {

                var playerManagerSelf = this;
                var performSkip = function() {
                    playerManagerSelf.isPlayingVideo = false;
                    playerManagerSelf.adVideoPlayer.pause();

                    //TODO all event should be clear in here
                    debug("destroy without skip");
                    var code = errCode || VAST_ERROR_UNDEFINED;//Undefined Error in VPAID3.0 spec
                    if (typeof playerManagerSelf.callbackForAdUnit.cbWhenDestroy === "function") {
                        if (playerManagerSelf.overlayPlayer) {
                            if (isError && message) {
                                if(timeout){
                                    code = VAST_ERROR_TIMEOUT;
                                }
                                playerManagerSelf.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, true, playerManagerSelf.options);
                            } else {
                                playerManagerSelf.callbackForAdUnit.cbWhenDestroy(null, true, playerManagerSelf.options);
                            }
                        }
                        else {
                            if (isError && message) {
                                if(timeout){
                                    code = VAST_ERROR_TIMEOUT;
                                }
                                playerManagerSelf.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, null, playerManagerSelf.options);
                            } else {
                                playerManagerSelf.callbackForAdUnit.cbWhenDestroy(null, null, playerManagerSelf.options);
                            }
                        }
                    }
                };

                if (playerManagerSelf.options.disableCollapseForDelay && playerManagerSelf.options.disableCollapseForDelay > 0) {
                    setTimeout(performSkip, playerManagerSelf.options.disableCollapseForDelay);
                } else {
                    performSkip();
                }

            },

            /**
             * return Video Object it self
             * @returns {*}
             */
            getVideoObject: function () {
                return this.adVideoPlayer;
            },


            handleFlashPlay: function() {
                var playerManager = this;
                var fnAfterAdLoaded = function() {
                    playerManager.resizeVideo(playerManager.aspectRatio);
                    debug("flash player is ready to play");
                    if (playerManager.callbackForAdUnit.cbWhenReady) {
                        playerManager.callbackForAdUnit.cbWhenReady(playerManager);
                    }
                };
                if (playerManager.isChrome) {
                    playerManager.setChromeSize();//for Chrome limitations
                    setTimeout(fnAfterAdLoaded, 100);
                }
                else {
                    fnAfterAdLoaded();
                }
            },

            handlePlayerNotification: function (dataObj) {

                //        debug(dataObj);
                if (dataObj.name !== 'video_time') {
                    debug("Got notification from player = " + dataObj.name);
                }
                //define method in self object
                //debug(dataObj);
                var playerManager = this;

                var eventHandler = {
                    "canplay": function () {
                        if (playerManager.options.hasOwnProperty('overlayPlayer')) {
                            try {
                                playerManager.adVideoPlayer.setDOMPlayerIdAndSize(playerManager.adVideoPlayer.id,
                                    playerManager.options.width, playerManager.options.height);
                            }
                            catch(ex) {
                                debug("Failed to execute setDOMPlayerIdAndSize(...) on Flash Player");
                            }
                        }
                        if (playerManager.options.vpaid) {
                            try {
                                var strCompanions = playerManager.adVideoPlayer.getCompanionsXml();
                                if (strCompanions && strCompanions.length > 0) {
                                    dataObj.companionAds = strCompanions;
                                }
                            }
                            catch(err) {}
                        }
                        if (playerManager.options.vpaid && playerManager.options.delayExpandUntilVPAIDImpression) {
                            playerManager.adVideoPlayer.play();//VID-1549
                        } else {
                            playerManager.handleFlashPlay();
                        }
                    },
                    "video_failed": function () {
                        // 'destroyWithoutSkip(true)' will dispatch 'error' event by itself
                        playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VIDEO_FAILED, null, VAST_ERROR_VIDEOFAILED);
                    },
                    "video_timeout": function () {
                        playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VIDEO_FAILED, true, VAST_ERROR_TIMEOUT);
                    },
                    "video_bitrate": function () {
                        var bandWidth = dataObj.bandwidth;
                        debug("bandwidth from flash : " + bandWidth);
                        //TODO expose bandwitdh
                    },
                    "video_impression": function () {

                    },
                    "video_mute": function () {
                        if (dataObj.hasOwnProperty('value') && !dataObj.value) {
                            dataObj.name = 'video_unmute';
                        }
                        if (dataObj.hasOwnProperty('value')) {
                            playerManager.isMuted = dataObj.value;
                        }
                    },
                    "video_click": function () {


                        if (dataObj.hasOwnProperty('playerHandles')) {
                            if (dataObj.playerHandles) {
                                // the player handles vpaid creative click event
                                if (dataObj.hasOwnProperty('url') && dataObj.url.length > 0) {
                                    playerManager.click(dataObj.url);
                                }
                                else {
                                    playerManager.click();
                                }
                            }
                            else {
                                // creative handles this event. we need only notify ad about click
                                playerManager.dispatchEventToAdunit({"name": "ad-click"});
                            }
                        }
                        else {
                            // it is not a vpaid creative click
                            playerManager.click();
                        }
                    },
                    "video_complete": function () {
                        playerManager.isCompleted = true;
                        if (!playerManager.options.disableCollapse) {
                            playerManager.destroyWithoutSkip();
                        }
                    },
                    "video_fullscreen": function () {
                        if (playerManager.isFullscreen) {
                            setTimeout(function () {
                                playerManager.isFullscreen = !playerManager.isFullscreen;
                            }, 1000);//this delay must be required for supressing mouseout event when exit fullscreen

                        } else {
                            playerManager.isFullscreen = !playerManager.isFullscreen;
                        }

                    },
                    "quartile_event": function () {

                    },
                    "video_pause": function () {
                    },
                    "video_start": function () {
                        if (!playerManager.isDoneInitialPlay && playerManager.options.initialPlayback !== 'auto') {
                            playerManager.play();
                        }
                    },
                    "video_time": function () {

                    },
                    "video_resume": function () {
                    },
                    "video_stopped": function () {
                        playerManager.destroyWithoutSkip();
                    },
                    "video_skipped": function () {
                        //click skip
                        playerManager.destroy();
                    },
                    "video_ratio": function () {
                        //playerManager.aspectRatio = dataObj.ratio;
                    },
                    "video_heightOffset": function () {
                        playerManager.heightOffset = dataObj.heightOffset;
                        //playerManager.options.height = playerManager.options.height + dataObj.heightOffset;
                        //test
                    },
                    "video_paused_by_user": function () {
                        playerManager.explicitPause();
                    },
                    "video_resumed_by_user": function () {
                        //playerManager.explicitPlay();

                        //change logic for VID-2504
                        debug("received video_resumed_by_user from Flash");
                        if (playerManager.requiredForFlashVpaid()) {
                            if (playerManager.isVpaidFlashVideoPlaying === false) {
                                debug("call explicitPlay by video_Resumed_by_user event");
                                playerManager.explicitPlay();
                            } else {
                                debug("do nothing because of isVpaidFlashVideoPlaying:true");
                            }
                        } else {
                            playerManager.explicitPlay();
                        }
                    }
                };

                if (!playerManager.isDoneInitialPlay && dataObj.name === "video_mute") {
                    // ignore some implicit event(s) before done initial play
                    return;
                }

                //invoke eventHandler by dataObj.name
                var invoker = eventHandler[dataObj.name];
                if (invoker && invoker !== undefined) {
                    invoker();
                }

                if (dataObj.name !== "video_pause" && dataObj.name !== "video_resume" &&
                    dataObj.name !== "video_impression" && dataObj.name !== "video_start" &&
                    dataObj.name !== "video_failed" &&  dataObj.name !== "video_timeout") {
                    this.dispatchEventToAdunit(dataObj);
                }

                if((dataObj.name === "video_impression" || dataObj.name === "video_start") && playerManager.options.vpaid){
                    this.dispatchEventToAdunit(dataObj);
                }
            },

            handleOverlayNotification: function (dataObj) {
                //define method in self object
                debug("Got overlay notification from player = " + dataObj.name);
                var playerManager = this;

                var eventHandler = {
                    "leaveFullscreen": function () {
                        if (playerManager.options.hasOwnProperty('playerNotification')) {
                            playerManager.options.playerNotification('leaveFullscreen');
                        }
                    }
                };

                //invoke eventHandler by dataObj.name
                var invoker = eventHandler[dataObj.name];
                if (invoker && invoker !== undefined) {
                    invoker();
                }
            },

            requiredForFlashVpaid: function() {
                return (this.decidePlayer(this.options.requiredPlayer) === "flash" && this.options.vpaid === true);
            },

            notifyVpaidEvent: function (eventName) {
                var playerManager = this;

                //for VID-2504
                if (playerManager.requiredForFlashVpaid()) {
                    if (eventName === "AdPaused") {
                        debug("received VPAID AdPaused from Flash");
                        playerManager.isVpaidFlashVideoPlaying = false;
                        playerManager.isPlayingVideo = false;
                        debug("set isVpaidFlashVideoPlaying = false");
                        debug("set isPlayingVideo = false");
                    }

                    if (eventName === "AdPlaying") {
                        debug("received VPAID AdPlaying from Flash");
                        playerManager.isVpaidFlashVideoPlaying = true;
                        playerManager.isPlayingVideo = true;
                        debug("set isVpaidFlashVideoPlaying = true");
                        debug("set isPlayingVideo = true");
                    }
                }

                //for VID-1549
                if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash" && playerManager.options.delayExpandUntilVPAIDImpression) {
                    if (eventName === "AdVideoStart") {
                        playerManager.adVideoPlayer.pause();
                    }
                    if (eventName === "AdImpression") {
                        playerManager.gotAdImpressionForFlash = true;
                    }
                    if (eventName === "AdStarted") {
                        playerManager.gotAdStartedForFlash = true;
                    }
                    if (playerManager.gotAdImpressionForFlash && playerManager.gotAdStartedForFlash) {
                        //this should be one time action when we got both impression and adStarted in order to resize video
                        playerManager.handleFlashPlay();//allow to expand
                        playerManager.gotAdImpressionForFlash = false;
                        playerManager.gotAdStartedForFlash = false;
                    }
                }


                //for VID-1551
                if (playerManager.options.delayExpandUntilVPAIDImpression && playerManager.delayEventHandler.isSuppress && EVENTS_HAVE_TO_FILTER_OUT.indexOf(eventName) >= 0) {
                    return;
                }

                if (EVENTS_RESTRICTED_SUPPRESSING.indexOf(eventName) >= 0 || EVENTS_RESTRICTED_SUPPRESSING.indexOf("vpaid." + eventName) >= 0) {
                    //don't suppress, trigger immidiately
                    playerManager.notifyVpaidEvent_internal(eventName);
                } else {
                    playerManager.delayEventHandler.push(function () {
                        playerManager.notifyVpaidEvent_internal(eventName);
                    });
                }
            },

            notifyVpaidEvent_internal: function (eventName) {
                if (this.options.cbNotification) {
                    this.options.cbNotification('VPAID', eventName, this.options.targetId);
                }
            },

            setChromeSize: function () {
                this.adVideoPlayer.width = "0px";
                this.adVideoPlayer.height = "0px";
                this.adVideoPlayer.style.width = "0px";
                this.adVideoPlayer.style.height = "0px";
                this.options.targetElement.style.visibility = "visible";
            },

            click: function (urlFromCreative) {


                var render360Video = function() {
                    var scene = document.getElementsByTagName("a-scene")[0];
                    if (scene) {
                        scene.parentNode.removeChild(scene);
                    }


                    document.getElementById("mainpart").style.display = "none";

                    var scene = document.createElement("a-scene");
                    var assets = document.createElement("a-assets");
                    var video = document.createElement("video");
                    var avideo = document.createElement("a-videosphere");

                    video.setAttribute("id","main-video");
                    video.setAttribute("src","http://vr.jwplayer.com/content/AgqYcfAT/AgqYcfAT-8yQ1cYbs.mp4");

                    avideo.setAttribute("src","#main-video");
                    avideo.setAttribute("rotation","0 180 0");

                    document.body.appendChild(scene);
                    scene.appendChild(assets);
                    assets.appendChild(video);
                    scene.appendChild(avideo);

                    scene.addEventListener("exit-vr",function() {
                        window.location.reload();
                    })

                };


                var renderVRVideo = function(url) {

                    document.getElementById("mainpart").style.display = "none";
                    var scene = document.createElement("a-scene");
                    var sky = document.createElement("a-sky");
                    var assets = document.createElement("a-assets");
                    var video = document.createElement("video");
                    var avideo = document.createElement("a-video");

                    video.setAttribute("id","main-video");
                    video.setAttribute("src","http://v.adsrvr.org/tdpartnerid/cxpowqgj/r17axcdp.webm");
                    //video.setAttribute("src",url);

                    avideo.setAttribute("src","#main-video");
                    avideo.setAttribute("width","40");
                    avideo.setAttribute("height","26");
                    avideo.setAttribute("position","110.86 62.31 -200");
                    avideo.setAttribute("rotation","2 -32 0");
                    avideo.setAttribute("scale","7.14 6.46 5.00");

                    sky.setAttribute("src","theater.jpg");
                    sky.setAttribute("rotation","0 -130 0");

                    document.body.appendChild(scene);
                    scene.appendChild(assets);
                    assets.appendChild(video);
                    scene.appendChild(avideo);
                    scene.appendChild(sky);

                    scene.addEventListener("exit-vr",function() {
                        render360Video();
                        window.location.reload();
                    })
                };

                // render360Video();
                renderVRVideo(this.options.videoUrl);

                return;
                if (!this.isDoneInitialPlay) {
                    this.play();//play the video by clicking play button
                    return;
                }

                if (this.isIosInlineRequired() === false) {//iOS will pause the video when window.open completed by blur a window, so don't need to be invoked here for VID-2074
                    this.pause();
                    this.toggleWindowFocus = false;//this will make sure to have clear status of focus because at somecase, document.hasFocus() can have true when we do open.window() even the focus is already on the new window.
                }

                /**
                 * ad-click
                 */
                if (urlFromCreative) {
                    window.open(urlFromCreative);
                }
                else if (this.options.clickUrls[0]) {
                    var url = this.options.clickUrls[0];
                    window.open(url);
                }

                this.dispatchEventToAdunit({"name": "ad-click"});

            },

            getRapamsAndExtensions: function () {
                var extensions = (this.options.extensions && this.options.extensions.length > 0) ? '<Extensions>' + this.options.extensions + '</Extensions>' : '';
                return {adParameters: this.options.adParameters, extensions: extensions};
            },

            handleViewability: function(object_, checkEventToStartViewability, isHtml5) {

                var isEnabledViewability = this.options && this.options.viewability && this.options.viewability.config;
                if (object_ && object_.name && isEnabledViewability) {
                    if (object_.name === checkEventToStartViewability) {//only at the time we got "expandStart" can have proper duration and final width,height for outstream, for other ad-unit this will use `loadstart` by a logic

                        var duration;
                        if (isHtml5) {//for html5
                            duration = this.adVideoPlayer && this.adVideoPlayer.player && typeof(this.adVideoPlayer.player) === "function" && this.adVideoPlayer.player().duration();
                            if (!duration || duration === undefined) {
                                duration = 0;//parser module doesn't store a duration from VAST XML, we use 0 as a default
                            }
                        }

                        //comment out flash because of unclear situation to get duration of flash video
                        // else {//for flash
                        //     duration = object_.duration;
                        //     if (!duration || duration === undefined) {
                        //         duration = 0;
                        //     }
                        // }

                        var width = this.options.width;
                        var height = this.options.height;
                        this.viewabilityTracking.init(this.options, duration, width, height);
                        this.viewabilityTracking.invokeEvent(object_.name);
                    } else {
                        if (this.viewabilityTracking.isReady) {
                            this.viewabilityTracking.invokeEvent(object_.name);
                        }
                    }
                }
            },

            findPathForViewability: function(object_) {

                var isHtml5 = (this.decidePlayer(this.options.requiredPlayer) === 'html5');
                var checkEventToStartViewability;

                if (isHtml5) {//for html5
                    if (this.options.expandable) {
                        checkEventToStartViewability = "expand";//event from Outstream
                    } else {
                        checkEventToStartViewability = "loadstart";//event from core-video framework
                    }
                    if (object_ && object_.name && object_.name === checkEventToStartViewability) {//avoiding double invoke
                        if (this.isDoneFirstLoadStart) {
                            return;
                        } else {
                            this.isDoneFirstLoadStart = true;
                        }
                    }
                    this.handleViewability(object_, checkEventToStartViewability, isHtml5);

                }

                //comment out flash because of unclear situation to get duration of flash video
                // else {//for flash
                //     checkEventToStartViewability = "video_time";//only way to get duration from flash player so have to delay "start" signal until "video_time" for viewability
                //     if (object_ && object_.name && object_.name === checkEventToStartViewability) {//avoiding double invoke
                //         if (this.isDoneFirstLoadStart) {
                //             //do nothing
                //         } else {
                //             this.isDoneFirstLoadStart = true;
                //
                //             this.handleViewability(object_, checkEventToStartViewability, isHtml5);//for initialize
                //             this.handleViewability({"name":"expand"}, checkEventToStartViewability, isHtml5);
                //         }
                //     } else {
                //         this.handleViewability(object_, checkEventToStartViewability, isHtml5);
                //     }
                //
                // }
            },

            dispatchEventToAdunit: function (object_, cb) {

                this.findPathForViewability(object_);

                var that = this;

                if (object_.name === "video_skip" && unique.pushAndCheck("dispatchEventToAdunit",object_.name) === false) {
                    return;//the unique.pushAndCheck will check if the value is unique, through this apprach unnecassary second "video-skip" will be ignored.
                }

                if (object_.name === "video_complete" && this.isVideoCompleteInjected === true) {
                    //do nothing
                } else {
                    debug("(push)" + object_.name);
                    this.delayEventHandler.push(function() {
                        that.dispatchEventToAdunit_internal(object_, cb);
                    });
                    if (object_.name === "video_complete") {
                        this.isVideoCompleteInjected = true;
                    }
                }

            },

            /**
             * dispatchEventToAdunit_internal
             * @param object_ : kind of events
             * @param cb : this callback will be invoked after handled all trackings and events
             */
            dispatchEventToAdunit_internal: function (object_, cb) {


                //debug("dispatchEventToAdunit : " + object_.name);

                // if video is completed all vast event firing will be ignored,
                // except video_complete, video_skip and ad-click event, make sure we notify ad unit about video completion.
                if (this.isCompleted && !(object_.name === "video_complete" || object_.name === "ad-click" || object_.name === "video_skip")) {
                    return;
                }

                var playerManager = this;
                debug("invoke callback : " + JSON.stringify(object_));

                if (this.callbackForAdUnit.cbForHandlingDispatchedEvent && object_.name !== "video_time") {
                    // debug("dispatchEventToAdunit : " + object_.name);

                    if (object_.name === "video_pause") {
                        this.isPlayingVideo = false;
                    }

                    if (object_.name === "video_play" || object_.name === "video_start" || object_.name === "firstplay") {
                        this.isPlayingVideo = true;
                        this.isDoneInitialPlay = true;
                    }


                    //fullscreen has to have some latency to get a exact fullscreen status during switching it
                    if (object_.name === "video_fullscreen") {
                        setTimeout(function () {
                            object_.fullscreenStatus = (playerManager.isFullscreen ? "enter" : "exit");
                            playerManager.callbackForAdUnit.cbForHandlingDispatchedEvent(object_);
                        }, 1500);
                        return;

                    }


                    if (typeof(cb) === "function") {
                        cb();//invoke callback if exists
                    }

                    this.callbackForAdUnit.cbForHandlingDispatchedEvent(object_);
                }
            },

            resizeVideo: function (aspectRatio, shouldConsiderHeightOfDevice,cb) {
                VideoSizeHandler.resizeVideo(aspectRatio, shouldConsiderHeightOfDevice, this,cb);
            },

            resizeVideoForSideStream: function (width, height,cb) {
                VideoSizeHandler.resizeVideoForSideStream(this, width, height,cb);
            },

            isIosInlineRequired: function() {
                return this.mobileSupport.isIosInlineRequired(this.options);
            },

            resizePlayer: function(width, height) {
                VideoSizeHandler.resizePlayer(width, height, this);
            },

            getFinalSize: function() {
                return VideoSizeHandler.getFinalSize(this);
            },

            log: debug,
            debug: debug
        };

        module.exports = adVideoPlayerManager;
        window[externalNameOfVideoPlayer] = adVideoPlayerManager;


        /***/ },
    /* 4 */
    /***/ function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/* jshint ignore:start */
            /**
             * @fileoverview Main function src.
             */

            // HTML5 Shiv. Must be in <head> to support older browsers.
            document.createElement('video');
            document.createElement('audio');
            document.createElement('track');

            /**
             * Doubles as the main function for users to create a player instance and also
             * the main library object.
             *
             * **ALIASES** videojs, _V_ (deprecated)
             *
             * The `vjs` function can be used to initialize or retrieve a player.
             *
             *     var myPlayer = vjs('my_video_id');
             *
             * @param  {String|Element} id      Video element or video element ID
             * @param  {Object=} options        Optional options object for config/settings
             * @param  {Function=} ready        Optional ready callback
             * @return {vjs.Player}             A player instance
             * @namespace
             */
            var global_options;//for having proper pre-generate iframe id
            var vjs = function(id, options, ready){
                global_options = options;
                var tag; // Element of ID

                // Allow for element or ID to be passed in
                // String ID
                if (typeof id === 'string') {

                    // Adjust for jQuery ID syntax
                    if (id.indexOf('#') === 0) {
                        id = id.slice(1);
                    }

                    // If a player instance has already been created for this ID return it.
                    if (vjs.players[id]) {

                        // If options or ready funtion are passed, warn
                        if (options) {
                            vjs.log.warn ('Player "' + id + '" is already initialised. Options will not be applied.');
                        }

                        if (ready) {
                            vjs.players[id].ready(ready);
                        }

                        return vjs.players[id];

                        // Otherwise get element for ID
                    } else {
                        tag = vjs.el(id);
                    }

                    // ID is a media element
                } else {
                    tag = id;
                }

                // Check for a useable element
                if (!tag || !tag.nodeName) { // re: nodeName, could be a box div also
                    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
                }

                // Element may have a player attr referring to an already created player instance.
                // If not, set up a new player and return the instance.
                return tag['player'] || new vjs.Player(tag, options, ready);
            };

            // Extended name, also available externally, window.videojs
            var videojs = window['videojs_apn'] = vjs;

            // CDN Version. Used to target right flash swf.
            vjs.CDN_VERSION = 'GENERATED_CDN_VSN';
            vjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');

            /**
             * Full player version
             * @type {string}
             */
            vjs['VERSION'] = 'GENERATED_FULL_VSN';

            /**
             * Global Player instance options, surfaced from vjs.Player.prototype.options_
             * vjs.options = vjs.Player.prototype.options_
             * All options should use string keys so they avoid
             * renaming by closure compiler
             * @type {Object}
             */
            vjs.options = {
                // Default order of fallback technology
                'techOrder': ['html5','flash'],
                // techOrder: ['flash','html5'],

                'html5': {},
                'flash': {},

                // Default of web browser is 300x150. Should rely on source width/height.
                'width': 300,
                'height': 150,
                // defaultVolume: 0.85,
                'defaultVolume': 0.00, // The freakin seaguls are driving me crazy!

                // default playback rates
                'playbackRates': [],
                // Add playback rate selection by adding rates
                // 'playbackRates': [0.5, 1, 1.5, 2],

                // default inactivity timeout
                'inactivityTimeout': 2000,

                // Included control sets
                'children': {
                    'mediaLoader': {},
                    'posterImage': {},
                    'loadingSpinner': {},
                    'textTrackDisplay': {},
                    'bigPlayButton': {},
                    'controlBar': {},
                    'errorDisplay': {},
                    'textTrackSettings': {}
                },

                'language': document.getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

                // locales and their language translations
                'languages': {},

                // Default message to show when a video cannot be played.
                'notSupportedMessage': 'No compatible source was found for this video.'
            };

            // Set CDN Version of swf
            // The added (+) blocks the replace from changing this GENERATED_CDN_VSN string
            if (vjs.CDN_VERSION !== 'GENERATED'+'_CDN_VSN') {
                videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/'+vjs.CDN_VERSION+'/video-js.swf';
            }

            /**
             * Utility function for adding languages to the default options. Useful for
             * amending multiple language support at runtime.
             *
             * Example: vjs.addLanguage('es', {'Hello':'Hola'});
             *
             * @param  {String} code The language code or dictionary property
             * @param  {Object} data The data values to be translated
             * @return {Object} The resulting global languages dictionary object
             */
            vjs.addLanguage = function(code, data){
                if(vjs.options['languages'][code] !== undefined) {
                    vjs.options['languages'][code] = vjs.util.mergeOptions(vjs.options['languages'][code], data);
                } else {
                    vjs.options['languages'][code] = data;
                }
                return vjs.options['languages'];
            };

            /**
             * Global player list
             * @type {Object}
             */
            vjs.players = {};

            /*!
             * Custom Universal Module Definition (UMD)
             *
             * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
             * still support requirejs and browserify. This also needs to be closure
             * compiler compatible, so string keys are used.
             */
            if ("function" === 'function' && __webpack_require__(6)['amd']) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return videojs; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

                // checking that module is an object too because of umdjs/umd#35
            } else if (true) {
                module['exports'] = videojs;
            }

            /**
             * Core Object/Class for objects that use inheritance + constructors
             *
             * To create a class that can be subclassed itself, extend the CoreObject class.
             *
             *     var Animal = CoreObject.extend();
             *     var Horse = Animal.extend();
             *
             * The constructor can be defined through the init property of an object argument.
             *
             *     var Animal = CoreObject.extend({
	 *       init: function(name, sound){
	 *         this.name = name;
	 *       }
	 *     });
             *
             * Other methods and properties can be added the same way, or directly to the
             * prototype.
             *
             *    var Animal = CoreObject.extend({
	 *       init: function(name){
	 *         this.name = name;
	 *       },
	 *       getName: function(){
	 *         return this.name;
	 *       },
	 *       sound: '...'
	 *    });
             *
             *    Animal.prototype.makeSound = function(){
	 *      alert(this.sound);
	 *    };
             *
             * To create an instance of a class, use the create method.
             *
             *    var fluffy = Animal.create('Fluffy');
             *    fluffy.getName(); // -> Fluffy
             *
             * Methods and properties can be overridden in subclasses.
             *
             *     var Horse = Animal.extend({
	 *       sound: 'Neighhhhh!'
	 *     });
             *
             *     var horsey = Horse.create('Horsey');
             *     horsey.getName(); // -> Horsey
             *     horsey.makeSound(); // -> Alert: Neighhhhh!
             *
             * @class
             * @constructor
             */
            vjs.CoreObject = vjs['CoreObject'] = function(){};
            // Manually exporting vjs['CoreObject'] here for Closure Compiler
            // because of the use of the extend/create class methods
            // If we didn't do this, those functions would get flattened to something like
            // `a = ...` and `this.prototype` would refer to the global object instead of
            // CoreObject

            /**
             * Create a new object that inherits from this Object
             *
             *     var Animal = CoreObject.extend();
             *     var Horse = Animal.extend();
             *
             * @param {Object} props Functions and properties to be applied to the
             *                       new object's prototype
             * @return {vjs.CoreObject} An object that inherits from CoreObject
             * @this {*}
             */
            vjs.CoreObject.extend = function(props){
                var init, subObj;

                props = props || {};
                // Set up the constructor using the supplied init method
                // or using the init of the parent object
                // Make sure to check the unobfuscated version for external libs
                init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function(){};
                // In Resig's simple class inheritance (previously used) the constructor
                //  is a function that calls `this.init.apply(arguments)`
                // However that would prevent us from using `ParentObject.call(this);`
                //  in a Child constructor because the `this` in `this.init`
                //  would still refer to the Child and cause an infinite loop.
                // We would instead have to do
                //    `ParentObject.prototype.init.apply(this, arguments);`
                //  Bleh. We're not creating a _super() function, so it's good to keep
                //  the parent constructor reference simple.
                subObj = function(){
                    init.apply(this, arguments);
                };

                // Inherit from this object's prototype
                subObj.prototype = vjs.obj.create(this.prototype);
                // Reset the constructor property for subObj otherwise
                // instances of subObj would have the constructor of the parent Object
                subObj.prototype.constructor = subObj;

                // Make the class extendable
                subObj.extend = vjs.CoreObject.extend;
                // Make a function for creating instances
                subObj.create = vjs.CoreObject.create;

                // Extend subObj's prototype with functions and other properties from props
                for (var name in props) {
                    if (props.hasOwnProperty(name)) {
                        subObj.prototype[name] = props[name];
                    }
                }

                return subObj;
            };

            /**
             * Create a new instance of this Object class
             *
             *     var myAnimal = Animal.create();
             *
             * @return {vjs.CoreObject} An instance of a CoreObject subclass
             * @this {*}
             */
            vjs.CoreObject.create = function(){
                // Create a new object that inherits from this object's prototype
                var inst = vjs.obj.create(this.prototype);

                // Apply this constructor function to the new object
                this.apply(inst, arguments);

                // Return the new object
                return inst;
            };

            /**
             * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
             * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
             * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
             * robust as jquery's, so there's probably some differences.
             */

            /**
             * Add an event listener to element
             * It stores the handler function in a separate cache object
             * and adds a generic handler to the element's event,
             * along with a unique id (guid) to the element.
             * @param  {Element|Object}   elem Element or object to bind listeners to
             * @param  {String|Array}   type Type of event to bind to.
             * @param  {Function} fn   Event listener.
             * @private
             */
            vjs.on = function(elem, type, fn){
                if (vjs.obj.isArray(type)) {
                    return _handleMultipleEvents(vjs.on, elem, type, fn);
                }

                var data = vjs.getData(elem);

                // We need a place to store all our handler data
                if (!data.handlers) data.handlers = {};

                if (!data.handlers[type]) data.handlers[type] = [];

                if (!fn.guid) fn.guid = vjs.guid++;

                data.handlers[type].push(fn);

                if (!data.dispatcher) {
                    data.disabled = false;

                    data.dispatcher = function (event){

                        if (data.disabled) return;
                        event = vjs.fixEvent(event);

                        var handlers = data.handlers[event.type];

                        if (handlers) {
                            // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
                            var handlersCopy = handlers.slice(0);

                            for (var m = 0, n = handlersCopy.length; m < n; m++) {
                                if (event.isImmediatePropagationStopped()) {
                                    break;
                                } else {
                                    handlersCopy[m].call(elem, event);
                                }
                            }
                        }
                    };
                }

                if (data.handlers[type].length == 1) {
                    if (elem.addEventListener) {
                        elem.addEventListener(type, data.dispatcher, false);
                    } else if (elem.attachEvent) {
                        elem.attachEvent('on' + type, data.dispatcher);
                    }
                }
            };

            /**
             * Removes event listeners from an element
             * @param  {Element|Object}   elem Object to remove listeners from
             * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
             * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
             * @private
             */
            vjs.off = function(elem, type, fn) {
                // Don't want to add a cache object through getData if not needed
                if (!vjs.hasData(elem)) return;

                var data = vjs.getData(elem);

                // If no events exist, nothing to unbind
                if (!data.handlers) { return; }

                if (vjs.obj.isArray(type)) {
                    return _handleMultipleEvents(vjs.off, elem, type, fn);
                }

                // Utility function
                var removeType = function(t){
                    data.handlers[t] = [];
                    vjs.cleanUpEvents(elem,t);
                };

                // Are we removing all bound events?
                if (!type) {
                    for (var t in data.handlers) removeType(t);
                    return;
                }

                var handlers = data.handlers[type];

                // If no handlers exist, nothing to unbind
                if (!handlers) return;

                // If no listener was provided, remove all listeners for type
                if (!fn) {
                    removeType(type);
                    return;
                }

                // We're only removing a single handler
                if (fn.guid) {
                    for (var n = 0; n < handlers.length; n++) {
                        if (handlers[n].guid === fn.guid) {
                            handlers.splice(n--, 1);
                        }
                    }
                }

                vjs.cleanUpEvents(elem, type);
            };

            /**
             * Clean up the listener cache and dispatchers
             * @param  {Element|Object} elem Element to clean up
             * @param  {String} type Type of event to clean up
             * @private
             */
            vjs.cleanUpEvents = function(elem, type) {
                var data = vjs.getData(elem);

                // Remove the events of a particular type if there are none left
                if (data.handlers[type].length === 0) {
                    delete data.handlers[type];
                    // data.handlers[type] = null;
                    // Setting to null was causing an error with data.handlers

                    // Remove the meta-handler from the element
                    if (elem.removeEventListener) {
                        elem.removeEventListener(type, data.dispatcher, false);
                    } else if (elem.detachEvent) {
                        elem.detachEvent('on' + type, data.dispatcher);
                    }
                }

                // Remove the events object if there are no types left
                if (vjs.isEmpty(data.handlers)) {
                    delete data.handlers;
                    delete data.dispatcher;
                    delete data.disabled;

                    // data.handlers = null;
                    // data.dispatcher = null;
                    // data.disabled = null;
                }

                // Finally remove the expando if there is no data left
                if (vjs.isEmpty(data)) {
                    vjs.removeData(elem);
                }
            };

            /**
             * Fix a native event to have standard property values
             * @param  {Object} event Event object to fix
             * @return {Object}
             * @private
             */
            vjs.fixEvent = function(event) {

                function returnTrue() { return true; }
                function returnFalse() { return false; }

                // Test if fixing up is needed
                // Used to check if !event.stopPropagation instead of isPropagationStopped
                // But native events return true for stopPropagation, but don't have
                // other expected methods like isPropagationStopped. Seems to be a problem
                // with the Javascript Ninja code. So we're just overriding all events now.
                if (!event || !event.isPropagationStopped) {
                    var old = event || window.event;

                    event = {};
                    // Clone the old object so that we can modify the values event = {};
                    // IE8 Doesn't like when you mess with native event properties
                    // Firefox returns false for event.hasOwnProperty('type') and other props
                    //  which makes copying more difficult.
                    // TODO: Probably best to create a whitelist of event props
                    for (var key in old) {
                        // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
                        // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
                        if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
                            // Chrome 32+ warns if you try to copy deprecated returnValue, but
                            // we still want to if preventDefault isn't supported (IE8).
                            if (!(key == 'returnValue' && old.preventDefault)) {
                                event[key] = old[key];
                            }
                        }
                    }

                    // The event occurred on this element
                    if (!event.target) {
                        event.target = event.srcElement || document;
                    }

                    // Handle which other element the event is related to
                    event.relatedTarget = event.fromElement === event.target ?
                        event.toElement :
                        event.fromElement;

                    // Stop the default browser action
                    event.preventDefault = function () {
                        if (old.preventDefault) {
                            old.preventDefault();
                        }
                        event.returnValue = false;
                        event.isDefaultPrevented = returnTrue;
                        event.defaultPrevented = true;
                    };

                    event.isDefaultPrevented = returnFalse;
                    event.defaultPrevented = false;

                    // Stop the event from bubbling
                    event.stopPropagation = function () {
                        if (old.stopPropagation) {
                            old.stopPropagation();
                        }
                        event.cancelBubble = true;
                        event.isPropagationStopped = returnTrue;
                    };

                    event.isPropagationStopped = returnFalse;

                    // Stop the event from bubbling and executing other handlers
                    event.stopImmediatePropagation = function () {
                        if (old.stopImmediatePropagation) {
                            old.stopImmediatePropagation();
                        }
                        event.isImmediatePropagationStopped = returnTrue;
                        event.stopPropagation();
                    };

                    event.isImmediatePropagationStopped = returnFalse;

                    // Handle mouse position
                    if (event.clientX != null) {
                        var doc = document.documentElement, body = document.body;

                        event.pageX = event.clientX +
                            (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                            (doc && doc.clientLeft || body && body.clientLeft || 0);
                        event.pageY = event.clientY +
                            (doc && doc.scrollTop || body && body.scrollTop || 0) -
                            (doc && doc.clientTop || body && body.clientTop || 0);
                    }

                    // Handle key presses
                    event.which = event.charCode || event.keyCode;

                    // Fix button for mouse clicks:
                    // 0 == left; 1 == middle; 2 == right
                    if (event.button != null) {
                        event.button = (event.button & 1 ? 0 :
                            (event.button & 4 ? 1 :
                                (event.button & 2 ? 2 : 0)));
                    }
                }

                // Returns fixed-up instance
                return event;
            };

            /**
             * Trigger an event for an element
             * @param  {Element|Object}      elem  Element to trigger an event on
             * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
             * @private
             */
            vjs.trigger = function(elem, event) {
                // Fetches element data and a reference to the parent (for bubbling).
                // Don't want to add a data object to cache for every parent,
                // so checking hasData first.
                var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};
                var parent = elem.parentNode || elem.ownerDocument;
                // type = event.type || event,
                // handler;

                // If an event name was passed as a string, creates an event out of it
                if (typeof event === 'string') {
                    event = { type:event, target:elem };
                }
                // Normalizes the event properties.
                event = vjs.fixEvent(event);

                // If the passed element has a dispatcher, executes the established handlers.
                if (elemData.dispatcher) {
                    elemData.dispatcher.call(elem, event);
                }

                // Unless explicitly stopped or the event does not bubble (e.g. media events)
                // recursively calls this function to bubble the event up the DOM.
                if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
                    vjs.trigger(parent, event);

                    // If at the top of the DOM, triggers the default action unless disabled.
                } else if (!parent && !event.defaultPrevented) {
                    var targetData = vjs.getData(event.target);

                    // Checks if the target has a default action for this event.
                    if (event.target[event.type]) {
                        // Temporarily disables event dispatching on the target as we have already executed the handler.
                        targetData.disabled = true;
                        // Executes the default action.
                        if (typeof event.target[event.type] === 'function') {
                            event.target[event.type]();
                        }
                        // Re-enables event dispatching.
                        targetData.disabled = false;
                    }
                }

                // Inform the triggerer if the default was prevented by returning false
                return !event.defaultPrevented;
                /* Original version of js ninja events wasn't complete.
                 * We've since updated to the latest version, but keeping this around
                 * for now just in case.
                 */
                // // Added in addition to book. Book code was broke.
                // event = typeof event === 'object' ?
                //   event[vjs.expando] ?
                //     event :
                //     new vjs.Event(type, event) :
                //   new vjs.Event(type);

                // event.type = type;
                // if (handler) {
                //   handler.call(elem, event);
                // }

                // // Clean up the event in case it is being reused
                // event.result = undefined;
                // event.target = elem;
            };

            /**
             * Trigger a listener only once for an event
             * @param  {Element|Object}   elem Element or object to
             * @param  {String|Array}   type
             * @param  {Function} fn
             * @private
             */
            vjs.one = function(elem, type, fn) {
                if (vjs.obj.isArray(type)) {
                    return _handleMultipleEvents(vjs.one, elem, type, fn);
                }
                var func = function(){
                    vjs.off(elem, type, func);
                    fn.apply(this, arguments);
                };
                // copy the guid to the new function so it can removed using the original function's ID
                func.guid = fn.guid = fn.guid || vjs.guid++;
                vjs.on(elem, type, func);
            };

            /**
             * Loops through an array of event types and calls the requested method for each type.
             * @param  {Function} fn   The event method we want to use.
             * @param  {Element|Object} elem Element or object to bind listeners to
             * @param  {String}   type Type of event to bind to.
             * @param  {Function} callback   Event listener.
             * @private
             */
            function _handleMultipleEvents(fn, elem, type, callback) {
                vjs.arr.forEach(type, function(type) {
                    fn(elem, type, callback); //Call the event method for each one of the types
                });
            }

            var hasOwnProp = Object.prototype.hasOwnProperty;

            /**
             * Creates an element and applies properties.
             * @param  {String=} tagName    Name of tag to be created.
             * @param  {Object=} properties Element properties to be applied.
             * @return {Element}
             * @private
             */
            vjs.createEl = function(tagName, properties){
                var el;

                tagName = tagName || 'div';
                properties = properties || {};

                el = document.createElement(tagName);

                vjs.obj.each(properties, function(propName, val){
                    // Not remembering why we were checking for dash
                    // but using setAttribute means you have to use getAttribute

                    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
                    // The additional check for "role" is because the default method for adding attributes does not
                    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
                    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
                    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
                    if (propName.indexOf('aria-') !== -1 || propName == 'role') {
                        el.setAttribute(propName, val);
                    } else {
                        el[propName] = val;
                    }
                });

                return el;
            };

            /**
             * Uppercase the first letter of a string
             * @param  {String} string String to be uppercased
             * @return {String}
             * @private
             */
            vjs.capitalize = function(string){
                return string.charAt(0).toUpperCase() + string.slice(1);
            };

            /**
             * Object functions container
             * @type {Object}
             * @private
             */
            vjs.obj = {};

            /**
             * Object.create shim for prototypal inheritance
             *
             * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
             *
             * @function
             * @param  {Object}   obj Object to use as prototype
             * @private
             */
            vjs.obj.create = Object.create || function(obj){
                    //Create a new function called 'F' which is just an empty object.
                    function F() {}

                    //the prototype of the 'F' function should point to the
                    //parameter of the anonymous function.
                    F.prototype = obj;

                    //create a new constructor function based off of the 'F' function.
                    return new F();
                };

            /**
             * Loop through each property in an object and call a function
             * whose arguments are (key,value)
             * @param  {Object}   obj Object of properties
             * @param  {Function} fn  Function to be called on each property.
             * @this {*}
             * @private
             */
            vjs.obj.each = function(obj, fn, context){
                for (var key in obj) {
                    if (hasOwnProp.call(obj, key)) {
                        fn.call(context || this, key, obj[key]);
                    }
                }
            };

            /**
             * Merge two objects together and return the original.
             * @param  {Object} obj1
             * @param  {Object} obj2
             * @return {Object}
             * @private
             */
            vjs.obj.merge = function(obj1, obj2){
                if (!obj2) { return obj1; }
                for (var key in obj2){
                    if (hasOwnProp.call(obj2, key)) {
                        obj1[key] = obj2[key];
                    }
                }
                return obj1;
            };

            /**
             * Merge two objects, and merge any properties that are objects
             * instead of just overwriting one. Uses to merge options hashes
             * where deeper default settings are important.
             * @param  {Object} obj1 Object to override
             * @param  {Object} obj2 Overriding object
             * @return {Object}      New object. Obj1 and Obj2 will be untouched.
             * @private
             */
            vjs.obj.deepMerge = function(obj1, obj2){
                var key, val1, val2;

                // make a copy of obj1 so we're not overwriting original values.
                // like prototype.options_ and all sub options objects
                obj1 = vjs.obj.copy(obj1);

                for (key in obj2){
                    if (hasOwnProp.call(obj2, key)) {
                        val1 = obj1[key];
                        val2 = obj2[key];

                        // Check if both properties are pure objects and do a deep merge if so
                        if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
                            obj1[key] = vjs.obj.deepMerge(val1, val2);
                        } else {
                            obj1[key] = obj2[key];
                        }
                    }
                }
                return obj1;
            };

            /**
             * Make a copy of the supplied object
             * @param  {Object} obj Object to copy
             * @return {Object}     Copy of object
             * @private
             */
            vjs.obj.copy = function(obj){
                return vjs.obj.merge({}, obj);
            };

            /**
             * Check if an object is plain, and not a dom node or any object sub-instance
             * @param  {Object} obj Object to check
             * @return {Boolean}     True if plain, false otherwise
             * @private
             */
            vjs.obj.isPlain = function(obj){
                return !!obj
                    && typeof obj === 'object'
                    && obj.toString() === '[object Object]'
                    && obj.constructor === Object;
            };

            /**
             * Check if an object is Array
             *  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
             * @param  {Object} obj Object to check
             * @return {Boolean}     True if plain, false otherwise
             * @private
             */
            vjs.obj.isArray = Array.isArray || function(arr) {
                    return Object.prototype.toString.call(arr) === '[object Array]';
                };

            /**
             * Check to see whether the input is NaN or not.
             * NaN is the only JavaScript construct that isn't equal to itself
             * @param {Number} num Number to check
             * @return {Boolean} True if NaN, false otherwise
             * @private
             */
            vjs.isNaN = function(num) {
                return num !== num;
            };

            /**
             * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
             It also stores a unique id on the function so it can be easily removed from events
             * @param  {*}   context The object to bind as scope
             * @param  {Function} fn      The function to be bound to a scope
             * @param  {Number=}   uid     An optional unique ID for the function to be set
             * @return {Function}
             * @private
             */
            vjs.bind = function(context, fn, uid) {
                // Make sure the function has a unique ID
                if (!fn.guid) { fn.guid = vjs.guid++; }

                // Create the new function that changes the context
                var ret = function() {
                    return fn.apply(context, arguments);
                };

                // Allow for the ability to individualize this function
                // Needed in the case where multiple objects might share the same prototype
                // IF both items add an event listener with the same function, then you try to remove just one
                // it will remove both because they both have the same guid.
                // when using this, you need to use the bind method when you remove the listener as well.
                // currently used in text tracks
                ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;

                return ret;
            };

            /**
             * Element Data Store. Allows for binding data to an element without putting it directly on the element.
             * Ex. Event listeners are stored here.
             * (also from jsninja.com, slightly modified and updated for closure compiler)
             * @type {Object}
             * @private
             */
            vjs.cache = {};

            /**
             * Unique ID for an element or function
             * @type {Number}
             * @private
             */
            vjs.guid = 1;

            /**
             * Unique attribute name to store an element's guid in
             * @type {String}
             * @constant
             * @private
             */
            vjs.expando = 'vdata' + (new Date()).getTime();

            /**
             * Returns the cache object where data for an element is stored
             * @param  {Element} el Element to store data for.
             * @return {Object}
             * @private
             */
            vjs.getData = function(el){
                var id = el[vjs.expando];
                if (!id) {
                    id = el[vjs.expando] = vjs.guid++;
                }
                if (!vjs.cache[id]) {
                    vjs.cache[id] = {};
                }
                return vjs.cache[id];
            };

            /**
             * Returns the cache object where data for an element is stored
             * @param  {Element} el Element to store data for.
             * @return {Object}
             * @private
             */
            vjs.hasData = function(el){
                var id = el[vjs.expando];
                return !(!id || vjs.isEmpty(vjs.cache[id]));
            };

            /**
             * Delete data for the element from the cache and the guid attr from getElementById
             * @param  {Element} el Remove data for an element
             * @private
             */
            vjs.removeData = function(el){
                var id = el[vjs.expando];
                if (!id) { return; }
                // Remove all stored data
                // Changed to = null
                // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
                // vjs.cache[id] = null;
                delete vjs.cache[id];

                // Remove the expando property from the DOM node
                try {
                    delete el[vjs.expando];
                } catch(e) {
                    if (el.removeAttribute) {
                        el.removeAttribute(vjs.expando);
                    } else {
                        // IE doesn't appear to support removeAttribute on the document element
                        el[vjs.expando] = null;
                    }
                }
            };

            /**
             * Check if an object is empty
             * @param  {Object}  obj The object to check for emptiness
             * @return {Boolean}
             * @private
             */
            vjs.isEmpty = function(obj) {
                for (var prop in obj) {
                    // Inlude null properties as empty.
                    if (obj[prop] !== null) {
                        return false;
                    }
                }
                return true;
            };

            /**
             * Check if an element has a CSS class
             * @param {Element} element Element to check
             * @param {String} classToCheck Classname to check
             * @private
             */
            vjs.hasClass = function(element, classToCheck){
                try{
                    if(element){
                        return ((' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1);
                    } else{
                        vjs.log('Error in hasClass, element does not exist');
                    }
                } catch(e){
                    vjs.log('Exception in hasClass', e);
                }
            };


            /**
             * Add a CSS class name to an element
             * @param {Element} element    Element to add class name to
             * @param {String} classToAdd Classname to add
             * @private
             */
            vjs.addClass = function(element, classToAdd){
                try{
                    if (element && !vjs.hasClass(element, classToAdd)) {
                        element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
                    } else {
                        vjs.log('Error in addClass, class or element doesn\'t exist');
                    }
                } catch(e){
                    vjs.log('Exception in addClass', e);
                }
            };

            /**
             * Remove a CSS class name from an element
             * @param {Element} element    Element to remove from class name
             * @param {String} classToAdd Classname to remove
             * @private
             */
            vjs.removeClass = function(element, classToRemove){
                var classNames, i;

                if (!vjs.hasClass(element, classToRemove)) {return;}

                classNames = element.className.split(' ');

                // no arr.indexOf in ie8, and we don't want to add a big shim
                for (i = classNames.length - 1; i >= 0; i--) {
                    if (classNames[i] === classToRemove) {
                        classNames.splice(i,1);
                    }
                }

                element.className = classNames.join(' ');
            };

            /**
             * Element for testing browser HTML5 video capabilities
             * @type {Element}
             * @constant
             * @private
             */
            vjs.TEST_VID = vjs.createEl('video');
            (function() {
                var track = document.createElement('track');
                track.kind = 'captions';
                track.srclang = 'en';
                track.label = 'English';
                vjs.TEST_VID.appendChild(track);
            })();

            /**
             * Useragent for browser testing.
             * @type {String}
             * @constant
             * @private
             */
            vjs.USER_AGENT = navigator.userAgent;

            /**
             * Device is an iPhone
             * @type {Boolean}
             * @constant
             * @private
             */
            vjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);
            vjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);
            vjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);
            vjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;

            vjs.IOS_VERSION = (function(){
                var match = vjs.USER_AGENT.match(/OS (\d+)_/i);
                if (match && match[1]) { return match[1]; }
            })();

            vjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);
            vjs.ANDROID_VERSION = (function() {
                // This matches Android Major.Minor.Patch versions
                // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
                var match = vjs.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
                    major,
                    minor;

                if (!match) {
                    return null;
                }

                major = match[1] && parseFloat(match[1]);
                minor = match[2] && parseFloat(match[2]);

                if (major && minor) {
                    return parseFloat(match[1] + '.' + match[2]);
                } else if (major) {
                    return major;
                } else {
                    return null;
                }
            })();
            // Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
            vjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;

            vjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);
            vjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);
            vjs.IS_IE8 = (/MSIE\s8\.0/).test(vjs.USER_AGENT);

            vjs.TOUCH_ENABLED = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
            vjs.BACKGROUND_SIZE_SUPPORTED = 'backgroundSize' in vjs.TEST_VID.style;

            /**
             * Apply attributes to an HTML element.
             * @param  {Element} el         Target element.
             * @param  {Object=} attributes Element attributes to be applied.
             * @private
             */
            vjs.setElementAttributes = function(el, attributes){
                vjs.obj.each(attributes, function(attrName, attrValue) {
                    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
                        el.removeAttribute(attrName);
                    } else {
                        el.setAttribute(attrName, (attrValue === true ? '' : attrValue));
                    }
                });
            };

            /**
             * Get an element's attribute values, as defined on the HTML tag
             * Attributes are not the same as properties. They're defined on the tag
             * or with setAttribute (which shouldn't be used with HTML)
             * This will return true or false for boolean attributes.
             * @param  {Element} tag Element from which to get tag attributes
             * @return {Object}
             * @private
             */
            vjs.getElementAttributes = function(tag){
                var obj, knownBooleans, attrs, attrName, attrVal;

                obj = {};

                // known boolean attributes
                // we can check for matching boolean properties, but older browsers
                // won't know about HTML5 boolean attributes that we still read from
                knownBooleans = ','+'autoplay,controls,loop,muted,default'+',';

                if (tag && tag.attributes && tag.attributes.length > 0) {
                    attrs = tag.attributes;

                    for (var i = attrs.length - 1; i >= 0; i--) {
                        attrName = attrs[i].name;
                        attrVal = attrs[i].value;

                        // check for known booleans
                        // the matching element property will return a value for typeof
                        if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(','+attrName+',') !== -1) {
                            // the value of an included boolean attribute is typically an empty
                            // string ('') which would equal false if we just check for a false value.
                            // we also don't want support bad code like autoplay='false'
                            attrVal = (attrVal !== null) ? true : false;
                        }

                        obj[attrName] = attrVal;
                    }
                }

                return obj;
            };

            /**
             * Get the computed style value for an element
             * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
             * @param  {Element} el        Element to get style value for
             * @param  {String} strCssRule Style name
             * @return {String}            Style value
             * @private
             */
            vjs.getComputedDimension = function(el, strCssRule){
                var strValue = '';
                if(document.defaultView && document.defaultView.getComputedStyle){
                    strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);

                } else if(el.currentStyle){
                    // IE8 Width/Height support
                    strValue = el['client'+strCssRule.substr(0,1).toUpperCase() + strCssRule.substr(1)] + 'px';
                }
                return strValue;
            };

            /**
             * Insert an element as the first child node of another
             * @param  {Element} child   Element to insert
             * @param  {[type]} parent Element to insert child into
             * @private
             */
            vjs.insertFirst = function(child, parent){
                if (parent.firstChild) {
                    parent.insertBefore(child, parent.firstChild);
                } else {
                    parent.appendChild(child);
                }
            };

            /**
             * Object to hold browser support information
             * @type {Object}
             * @private
             */
            vjs.browser = {};

            /**
             * Shorthand for document.getElementById()
             * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
             * @param  {String} id  Element ID
             * @return {Element}    Element with supplied ID
             * @private
             */
            vjs.el = function(id){
                if (id.indexOf('#') === 0) {
                    id = id.slice(1);
                }

                return document.getElementById(id);
            };

            /**
             * Format seconds as a time string, H:MM:SS or M:SS
             * Supplying a guide (in seconds) will force a number of leading zeros
             * to cover the length of the guide
             * @param  {Number} seconds Number of seconds to be turned into a string
             * @param  {Number} guide   Number (in seconds) to model the string after
             * @return {String}         Time formatted as H:MM:SS or M:SS
             * @private
             */
            vjs.formatTime = function(seconds, guide) {
                // Default to using seconds as guide
                guide = guide || seconds;
                var s = Math.floor(seconds % 60),
                    m = Math.floor(seconds / 60 % 60),
                    h = Math.floor(seconds / 3600),
                    gm = Math.floor(guide / 60 % 60),
                    gh = Math.floor(guide / 3600);

                // handle invalid times
                if (isNaN(seconds) || seconds === Infinity) {
                    // '-' is false for all relational operators (e.g. <, >=) so this setting
                    // will add the minimum number of fields specified by the guide
                    h = m = s = '-';
                }

                // Check if we need to show hours
                h = (h > 0 || gh > 0) ? h + ':' : '';

                // If hours are showing, we may need to add a leading zero.
                // Always show at least one digit of minutes.
                m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';

                // Check if leading zero is need for seconds
                s = (s < 10) ? '0' + s : s;

                return h + m + s;
            };

            // Attempt to block the ability to select text while dragging controls
            vjs.blockTextSelection = function(){
                document.body.focus();
                document.onselectstart = function () { return false; };
            };
            // Turn off text selection blocking
            vjs.unblockTextSelection = function(){ document.onselectstart = function () { return true; }; };

            /**
             * Trim whitespace from the ends of a string.
             * @param  {String} string String to trim
             * @return {String}        Trimmed string
             * @private
             */
            vjs.trim = function(str){
                return (str+'').replace(/^\s+|\s+$/g, '');
            };

            /**
             * Should round off a number to a decimal place
             * @param  {Number} num Number to round
             * @param  {Number} dec Number of decimal places to round to
             * @return {Number}     Rounded number
             * @private
             */
            vjs.round = function(num, dec) {
                if (!dec) { dec = 0; }
                return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
            };

            /**
             * Should create a fake TimeRange object
             * Mimics an HTML5 time range instance, which has functions that
             * return the start and end times for a range
             * TimeRanges are returned by the buffered() method
             * @param  {Number} start Start time in seconds
             * @param  {Number} end   End time in seconds
             * @return {Object}       Fake TimeRange object
             * @private
             */
            vjs.createTimeRange = function(start, end){
                if (start === undefined && end === undefined) {
                    return {
                        length: 0,
                        start: function() {
                            throw new Error('This TimeRanges object is empty');
                        },
                        end: function() {
                            throw new Error('This TimeRanges object is empty');
                        }
                    };
                }

                return {
                    length: 1,
                    start: function() { return start; },
                    end: function() { return end; }
                };
            };

            /**
             * Add to local storage (may removable)
             * @private
             */
            vjs.setLocalStorage = function(key, value){
                try {
                    // IE was throwing errors referencing the var anywhere without this
                    var localStorage = window.localStorage || false;
                    if (!localStorage) { return; }
                    localStorage[key] = value;
                } catch(e) {
                    if (e.code == 22 || e.code == 1014) { // Webkit == 22 / Firefox == 1014
                        vjs.log('LocalStorage Full (VideoJS)', e);
                    } else {
                        if (e.code == 18) {
                            vjs.log('LocalStorage not allowed (VideoJS)', e);
                        } else {
                            vjs.log('LocalStorage Error (VideoJS)', e);
                        }
                    }
                }
            };

            /**
             * Get absolute version of relative URL. Used to tell flash correct URL.
             * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
             * @param  {String} url URL to make absolute
             * @return {String}     Absolute URL
             * @private
             */
            vjs.getAbsoluteURL = function(url){

                // Check if absolute URL
                if (!url.match(/^https?:\/\//)) {
                    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
                    url = vjs.createEl('div', {
                        innerHTML: '<a href="'+url+'">x</a>'
                    }).firstChild.href;
                }

                return url;
            };


            /**
             * Resolve and parse the elements of a URL
             * @param  {String} url The url to parse
             * @return {Object}     An object of url details
             */
            vjs.parseUrl = function(url) {
                var div, a, addToBody, props, details;

                props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

                // add the url to an anchor and let the browser parse the URL
                a = vjs.createEl('a', { href: url });

                // IE8 (and 9?) Fix
                // ie8 doesn't parse the URL correctly until the anchor is actually
                // added to the body, and an innerHTML is needed to trigger the parsing
                addToBody = (a.host === '' && a.protocol !== 'file:');
                if (addToBody) {
                    div = vjs.createEl('div');
                    div.innerHTML = '<a href="'+url+'"></a>';
                    a = div.firstChild;
                    // prevent the div from affecting layout
                    div.setAttribute('style', 'display:none; position:absolute;');
                    document.body.appendChild(div);
                }

                // Copy the specific URL properties to a new object
                // This is also needed for IE8 because the anchor loses its
                // properties when it's removed from the dom
                details = {};
                for (var i = 0; i < props.length; i++) {
                    details[props[i]] = a[props[i]];
                }

                // IE9 adds the port to the host property unlike everyone else. If
                // a port identifier is added for standard ports, strip it.
                if (details.protocol === 'http:') {
                    details.host = details.host.replace(/:80$/, '');
                }
                if (details.protocol === 'https:') {
                    details.host = details.host.replace(/:443$/, '');
                }

                if (addToBody) {
                    document.body.removeChild(div);
                }

                return details;
            };

            /**
             * Log messages to the console and history based on the type of message
             *
             * @param  {String} type The type of message, or `null` for `log`
             * @param  {[type]} args The args to be passed to the log
             * @private
             */
            function _logType(type, args){

                return;//TODO minthe to block all video.js log

                var argsArray, noop, console;

                // convert args to an array to get array functions
                argsArray = Array.prototype.slice.call(args);
                // if there's no console then don't try to output messages
                // they will still be stored in vjs.log.history
                // Was setting these once outside of this function, but containing them
                // in the function makes it easier to test cases where console doesn't exist
                noop = function(){};
                console = window['console'] || {
                        'log': noop,
                        'warn': noop,
                        'error': noop
                    };

                if (type) {
                    // add the type to the front of the message
                    argsArray.unshift(type.toUpperCase()+':');
                } else {
                    // default to log with no prefix
                    type = 'log';
                }

                // add to history
                vjs.log.history.push(argsArray);

                // add console prefix after adding to history
                argsArray.unshift('VIDEOJS:');

                // call appropriate log function
                if (console[type].apply) {
                    console[type].apply(console, argsArray);
                } else {
                    // ie8 doesn't allow error.apply, but it will just join() the array anyway
                    console[type](argsArray.join(' '));
                }
            }

            /**
             * Log plain debug messages
             */
            vjs.log = function(){
                _logType(null, arguments);
            };

            /**
             * Keep a history of log messages
             * @type {Array}
             */
            vjs.log.history = [];

            /**
             * Log error messages
             */
            vjs.log.error = function(){
                _logType('error', arguments);
            };

            /**
             * Log warning messages
             */
            vjs.log.warn = function(){
                _logType('warn', arguments);
            };

            // Offset Left
            // getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
            vjs.findPosition = function(el) {
                var box, docEl, body, clientLeft, scrollLeft, left, clientTop, scrollTop, top;

                if (el.getBoundingClientRect && el.parentNode) {
                    box = el.getBoundingClientRect();
                }

                if (!box) {
                    return {
                        left: 0,
                        top: 0
                    };
                }

                docEl = document.documentElement;
                body = document.body;

                clientLeft = docEl.clientLeft || body.clientLeft || 0;
                scrollLeft = window.pageXOffset || body.scrollLeft;
                left = box.left + scrollLeft - clientLeft;

                clientTop = docEl.clientTop || body.clientTop || 0;
                scrollTop = window.pageYOffset || body.scrollTop;
                top = box.top + scrollTop - clientTop;

                // Android sometimes returns slightly off decimal values, so need to round
                return {
                    left: vjs.round(left),
                    top: vjs.round(top)
                };
            };

            /**
             * Array functions container
             * @type {Object}
             * @private
             */
            vjs.arr = {};

            /*
             * Loops through an array and runs a function for each item inside it.
             * @param  {Array}    array       The array
             * @param  {Function} callback    The function to be run for each item
             * @param  {*}        thisArg     The `this` binding of callback
             * @returns {Array}               The array
             * @private
             */
            vjs.arr.forEach = function(array, callback, thisArg) {
                if (vjs.obj.isArray(array) && callback instanceof Function) {
                    for (var i = 0, len = array.length; i < len; ++i) {
                        callback.call(thisArg || vjs, array[i], i, array);
                    }
                }

                return array;
            };

            /**
             * Utility functions namespace
             * @namespace
             * @type {Object}
             */
            vjs.util = {};

            /**
             * Merge two options objects, recursively merging any plain object properties as
             * well.  Previously `deepMerge`
             *
             * @param  {Object} obj1 Object to override values in
             * @param  {Object} obj2 Overriding object
             * @return {Object}      New object -- obj1 and obj2 will be untouched
             */
            vjs.util.mergeOptions = function(obj1, obj2){
                var key, val1, val2;

                // make a copy of obj1 so we're not overwriting original values.
                // like prototype.options_ and all sub options objects
                obj1 = vjs.obj.copy(obj1);

                for (key in obj2){
                    if (obj2.hasOwnProperty(key)) {
                        val1 = obj1[key];
                        val2 = obj2[key];

                        // Check if both properties are pure objects and do a deep merge if so
                        if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
                            obj1[key] = vjs.util.mergeOptions(val1, val2);
                        } else {
                            obj1[key] = obj2[key];
                        }
                    }
                }
                return obj1;
            };
            vjs.EventEmitter = function() {
            };

            vjs.EventEmitter.prototype.allowedEvents_ = {
            };

            vjs.EventEmitter.prototype.on = function(type, fn) {
                // Remove the addEventListener alias before calling vjs.on
                // so we don't get into an infinite type loop
                var ael = this.addEventListener;
                this.addEventListener = Function.prototype;
                vjs.on(this, type, fn);
                this.addEventListener = ael;
            };
            vjs.EventEmitter.prototype.addEventListener = vjs.EventEmitter.prototype.on;

            vjs.EventEmitter.prototype.off = function(type, fn) {
                vjs.off(this, type, fn);
            };
            vjs.EventEmitter.prototype.removeEventListener = vjs.EventEmitter.prototype.off;

            vjs.EventEmitter.prototype.one = function(type, fn) {
                vjs.one(this, type, fn);
            };

            vjs.EventEmitter.prototype.trigger = function(event) {
                var type = event.type || event;

                if (typeof event === 'string') {
                    event = {
                        type: type
                    };
                }
                event = vjs.fixEvent(event);

                if (this.allowedEvents_[type] && this['on' + type]) {
                    this['on' + type](event);
                }

                vjs.trigger(this, event);
            };
            // The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
            vjs.EventEmitter.prototype.dispatchEvent = vjs.EventEmitter.prototype.trigger;

            /**
             * @fileoverview Player Component - Base class for all UI objects
             *
             */

            /**
             * Base UI Component class
             *
             * Components are embeddable UI objects that are represented by both a
             * javascript object and an element in the DOM. They can be children of other
             * components, and can have many children themselves.
             *
             *     // adding a button to the player
             *     var button = player.addChild('button');
             *     button.el(); // -> button element
             *
             *     <div class="video-js">
             *       <div class="vjs-button">Button</div>
             *     </div>
             *
             * Components are also event emitters.
             *
             *     button.on('click', function(){
	 *       console.log('Button Clicked!');
	 *     });
             *
             *     button.trigger('customevent');
             *
             * @param {Object} player  Main Player
             * @param {Object=} options
             * @class
             * @constructor
             * @extends vjs.CoreObject
             */
            vjs.Component = vjs.CoreObject.extend({
                /**
                 * the constructor function for the class
                 *
                 * @constructor
                 */
                init: function(player, options, ready){
                    this.player_ = player;

                    // Make a copy of prototype.options_ to protect against overriding global defaults
                    this.options_ = vjs.obj.copy(this.options_);

                    // Updated options with supplied options
                    options = this.options(options);

                    // Get ID from options or options element if one is supplied
                    this.id_ = options['id'] || (options['el'] && options['el']['id']);

                    // If there was no ID from the options, generate one
                    if (!this.id_) {
                        // Don't require the player ID function in the case of mock players
                        this.id_ = ((player.id && player.id()) || 'no_player') + '_component_' + vjs.guid++;
                    }

                    this.name_ = options['name'] || null;

                    // Create element if one wasn't provided in options
                    this.el_ = options['el'] || this.createEl();

                    this.children_ = [];
                    this.childIndex_ = {};
                    this.childNameIndex_ = {};

                    // Add any child components in options
                    this.initChildren();

                    this.ready(ready);
                    // Don't want to trigger ready here or it will before init is actually
                    // finished for all children that run this constructor

                    if (options.reportTouchActivity !== false) {
                        this.enableTouchActivity();
                    }
                }
            });

            /**
             * Dispose of the component and all child components
             */
            vjs.Component.prototype.dispose = function(){
                this.trigger({ type: 'dispose', 'bubbles': false });

                // Dispose all children.
                if (this.children_) {
                    for (var i = this.children_.length - 1; i >= 0; i--) {
                        if (this.children_[i].dispose) {
                            this.children_[i].dispose();
                        }
                    }
                }

                // Delete child references
                this.children_ = null;
                this.childIndex_ = null;
                this.childNameIndex_ = null;

                // Remove all event listeners.
                this.off();

                // Remove element from DOM
                if (this.el_.parentNode) {
                    this.el_.parentNode.removeChild(this.el_);
                }

                vjs.removeData(this.el_);
                this.el_ = null;
            };

            /**
             * Reference to main player instance
             *
             * @type {vjs.Player}
             * @private
             */
            vjs.Component.prototype.player_ = true;

            /**
             * Return the component's player
             *
             * @return {vjs.Player}
             */
            vjs.Component.prototype.player = function(){
                return this.player_;
            };

            /**
             * The component's options object
             *
             * @type {Object}
             * @private
             */
            vjs.Component.prototype.options_;

            /**
             * Deep merge of options objects
             *
             * Whenever a property is an object on both options objects
             * the two properties will be merged using vjs.obj.deepMerge.
             *
             * This is used for merging options for child components. We
             * want it to be easy to override individual options on a child
             * component without having to rewrite all the other default options.
             *
             *     Parent.prototype.options_ = {
	 *       children: {
	 *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
	 *         'childTwo': {},
	 *         'childThree': {}
	 *       }
	 *     }
             *     newOptions = {
	 *       children: {
	 *         'childOne': { 'foo': 'baz', 'abc': '123' }
	 *         'childTwo': null,
	 *         'childFour': {}
	 *       }
	 *     }
             *
             *     this.options(newOptions);
             *
             * RESULT
             *
             *     {
	 *       children: {
	 *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
	 *         'childTwo': null, // Disabled. Won't be initialized.
	 *         'childThree': {},
	 *         'childFour': {}
	 *       }
	 *     }
             *
             * @param  {Object} obj Object of new option values
             * @return {Object}     A NEW object of this.options_ and obj merged
             */
            vjs.Component.prototype.options = function(obj){
                if (obj === undefined) return this.options_;

                return this.options_ = vjs.util.mergeOptions(this.options_, obj);
            };

            /**
             * The DOM element for the component
             *
             * @type {Element}
             * @private
             */
            vjs.Component.prototype.el_;

            /**
             * Create the component's DOM element
             *
             * @param  {String=} tagName  Element's node type. e.g. 'div'
             * @param  {Object=} attributes An object of element attributes that should be set on the element
             * @return {Element}
             */
            vjs.Component.prototype.createEl = function(tagName, attributes){
                return vjs.createEl(tagName, attributes);
            };

            vjs.Component.prototype.localize = function(string){
                var lang = this.player_.language(),
                    languages = this.player_.languages();
                if (languages && languages[lang] && languages[lang][string]) {
                    return languages[lang][string];
                }
                return string;
            };

            /**
             * Get the component's DOM element
             *
             *     var domEl = myComponent.el();
             *
             * @return {Element}
             */
            vjs.Component.prototype.el = function(){
                return this.el_;
            };

            /**
             * An optional element where, if defined, children will be inserted instead of
             * directly in `el_`
             *
             * @type {Element}
             * @private
             */
            vjs.Component.prototype.contentEl_;

            /**
             * Return the component's DOM element for embedding content.
             * Will either be el_ or a new element defined in createEl.
             *
             * @return {Element}
             */
            vjs.Component.prototype.contentEl = function(){
                return this.contentEl_ || this.el_;
            };

            /**
             * The ID for the component
             *
             * @type {String}
             * @private
             */
            vjs.Component.prototype.id_;

            /**
             * Get the component's ID
             *
             *     var id = myComponent.id();
             *
             * @return {String}
             */
            vjs.Component.prototype.id = function(){
                return this.id_;
            };

            /**
             * The name for the component. Often used to reference the component.
             *
             * @type {String}
             * @private
             */
            vjs.Component.prototype.name_;

            /**
             * Get the component's name. The name is often used to reference the component.
             *
             *     var name = myComponent.name();
             *
             * @return {String}
             */
            vjs.Component.prototype.name = function(){
                return this.name_;
            };

            /**
             * Array of child components
             *
             * @type {Array}
             * @private
             */
            vjs.Component.prototype.children_;

            /**
             * Get an array of all child components
             *
             *     var kids = myComponent.children();
             *
             * @return {Array} The children
             */
            vjs.Component.prototype.children = function(){
                return this.children_;
            };

            /**
             * Object of child components by ID
             *
             * @type {Object}
             * @private
             */
            vjs.Component.prototype.childIndex_;

            /**
             * Returns a child component with the provided ID
             *
             * @return {vjs.Component}
             */
            vjs.Component.prototype.getChildById = function(id){
                return this.childIndex_[id];
            };

            /**
             * Object of child components by name
             *
             * @type {Object}
             * @private
             */
            vjs.Component.prototype.childNameIndex_;

            /**
             * Returns a child component with the provided name
             *
             * @return {vjs.Component}
             */
            vjs.Component.prototype.getChild = function(name){
                return this.childNameIndex_[name];
            };

            /**
             * Adds a child component inside this component
             *
             *     myComponent.el();
             *     // -> <div class='my-component'></div>
             *     myComonent.children();
             *     // [empty array]
             *
             *     var myButton = myComponent.addChild('MyButton');
             *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
             *     // -> myButton === myComonent.children()[0];
             *
             * Pass in options for child constructors and options for children of the child
             *
             *     var myButton = myComponent.addChild('MyButton', {
	 *       text: 'Press Me',
	 *       children: {
	 *         buttonChildExample: {
	 *           buttonChildOption: true
	 *         }
	 *       }
	 *     });
             *
             * @param {String|vjs.Component} child The class name or instance of a child to add
             * @param {Object=} options Options, including options to be passed to children of the child.
             * @return {vjs.Component} The child component (created by this process if a string was used)
             * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
             */
            vjs.Component.prototype.addChild = function(child, options){
                var component, componentClass, componentName;

                // If child is a string, create new component with options
                if (typeof child === 'string') {
                    componentName = child;

                    // Make sure options is at least an empty object to protect against errors
                    options = options || {};

                    // If no componentClass in options, assume componentClass is the name lowercased
                    // (e.g. playButton)
                    componentClass = options['componentClass'] || vjs.capitalize(componentName);

                    // Set name through options
                    options['name'] = componentName;

                    // Create a new object & element for this controls set
                    // If there's no .player_, this is a player
                    // Closure Compiler throws an 'incomplete alias' warning if we use the vjs variable directly.
                    // Every class should be exported, so this should never be a problem here.
                    component = new window['videojs_apn'][componentClass](this.player_ || this, options);

                    // child is a component instance
                } else {
                    component = child;
                }

                this.children_.push(component);

                if (typeof component.id === 'function') {
                    this.childIndex_[component.id()] = component;
                }

                // If a name wasn't used to create the component, check if we can use the
                // name function of the component
                componentName = componentName || (component.name && component.name());

                if (componentName) {
                    this.childNameIndex_[componentName] = component;
                }

                // Add the UI object's element to the container div (box)
                // Having an element is not required
                if (typeof component['el'] === 'function' && component['el']()) {
                    this.contentEl().appendChild(component['el']());
                }

                // Return so it can stored on parent object if desired.
                return component;
            };

            /**
             * Remove a child component from this component's list of children, and the
             * child component's element from this component's element
             *
             * @param  {vjs.Component} component Component to remove
             */
            vjs.Component.prototype.removeChild = function(component){
                if (typeof component === 'string') {
                    component = this.getChild(component);
                }

                if (!component || !this.children_) return;

                var childFound = false;
                for (var i = this.children_.length - 1; i >= 0; i--) {
                    if (this.children_[i] === component) {
                        childFound = true;
                        this.children_.splice(i,1);
                        break;
                    }
                }

                if (!childFound) return;

                this.childIndex_[component.id()] = null;
                this.childNameIndex_[component.name()] = null;

                var compEl = component.el();
                if (compEl && compEl.parentNode === this.contentEl()) {
                    this.contentEl().removeChild(component.el());
                }
            };

            /**
             * Add and initialize default child components from options
             *
             *     // when an instance of MyComponent is created, all children in options
             *     // will be added to the instance by their name strings and options
             *     MyComponent.prototype.options_.children = {
	 *       myChildComponent: {
	 *         myChildOption: true
	 *       }
	 *     }
             *
             *     // Or when creating the component
             *     var myComp = new MyComponent(player, {
	 *       children: {
	 *         myChildComponent: {
	 *           myChildOption: true
	 *         }
	 *       }
	 *     });
             *
             * The children option can also be an Array of child names or
             * child options objects (that also include a 'name' key).
             *
             *     var myComp = new MyComponent(player, {
	 *       children: [
	 *         'button',
	 *         {
	 *           name: 'button',
	 *           someOtherOption: true
	 *         }
	 *       ]
	 *     });
             *
             */
            vjs.Component.prototype.initChildren = function(){
                var parent, parentOptions, children, child, name, opts, handleAdd;

                parent = this;
                parentOptions = parent.options();
                children = parentOptions['children'];

                if (children) {
                    handleAdd = function(name, opts){
                        // Allow options for children to be set at the parent options
                        // e.g. videojs(id, { controlBar: false });
                        // instead of videojs(id, { children: { controlBar: false });
                        if (parentOptions[name] !== undefined) {
                            opts = parentOptions[name];
                        }

                        // Allow for disabling default components
                        // e.g. vjs.options['children']['posterImage'] = false
                        if (opts === false) return;

                        // Create and add the child component.
                        // Add a direct reference to the child by name on the parent instance.
                        // If two of the same component are used, different names should be supplied
                        // for each
                        parent[name] = parent.addChild(name, opts);
                    };

                    // Allow for an array of children details to passed in the options
                    if (vjs.obj.isArray(children)) {
                        for (var i = 0; i < children.length; i++) {
                            child = children[i];

                            if (typeof child == 'string') {
                                // ['myComponent']
                                name = child;
                                opts = {};
                            } else {
                                // [{ name: 'myComponent', otherOption: true }]
                                name = child.name;
                                opts = child;
                            }

                            handleAdd(name, opts);
                        }
                    } else {
                        vjs.obj.each(children, handleAdd);
                    }
                }
            };

            /**
             * Allows sub components to stack CSS class names
             *
             * @return {String} The constructed class name
             */
            vjs.Component.prototype.buildCSSClass = function(){
                // Child classes can include a function that does:
                // return 'CLASS NAME' + this._super();
                return '';
            };

            /* Events
             ============================================================================= */

            /**
             * Add an event listener to this component's element
             *
             *     var myFunc = function(){
	 *       var myComponent = this;
	 *       // Do something when the event is fired
	 *     };
             *
             *     myComponent.on('eventType', myFunc);
             *
             * The context of myFunc will be myComponent unless previously bound.
             *
             * Alternatively, you can add a listener to another element or component.
             *
             *     myComponent.on(otherElement, 'eventName', myFunc);
             *     myComponent.on(otherComponent, 'eventName', myFunc);
             *
             * The benefit of using this over `vjs.on(otherElement, 'eventName', myFunc)`
             * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
             * will be automatically cleaned up when either component is disposed.
             * It will also bind myComponent as the context of myFunc.
             *
             * **NOTE**: When using this on elements in the page other than window
             * and document (both permanent), if you remove the element from the DOM
             * you need to call `vjs.trigger(el, 'dispose')` on it to clean up
             * references to it and allow the browser to garbage collect it.
             *
             * @param  {String|vjs.Component} first   The event type or other component
             * @param  {Function|String}      second  The event handler or event type
             * @param  {Function}             third   The event handler
             * @return {vjs.Component}        self
             */
            vjs.Component.prototype.on = function(first, second, third){
                var target, type, fn, removeOnDispose, cleanRemover, thisComponent;

                if (typeof first === 'string' || vjs.obj.isArray(first)) {
                    vjs.on(this.el_, first, vjs.bind(this, second));

                    // Targeting another component or element
                } else {
                    target = first;
                    type = second;
                    fn = vjs.bind(this, third);
                    thisComponent = this;

                    // When this component is disposed, remove the listener from the other component
                    removeOnDispose = function(){
                        thisComponent.off(target, type, fn);
                    };
                    // Use the same function ID so we can remove it later it using the ID
                    // of the original listener
                    removeOnDispose.guid = fn.guid;
                    this.on('dispose', removeOnDispose);

                    // If the other component is disposed first we need to clean the reference
                    // to the other component in this component's removeOnDispose listener
                    // Otherwise we create a memory leak.
                    cleanRemover = function(){
                        thisComponent.off('dispose', removeOnDispose);
                    };
                    // Add the same function ID so we can easily remove it later
                    cleanRemover.guid = fn.guid;

                    // Check if this is a DOM node
                    if (first.nodeName) {
                        // Add the listener to the other element
                        vjs.on(target, type, fn);
                        vjs.on(target, 'dispose', cleanRemover);

                        // Should be a component
                        // Not using `instanceof vjs.Component` because it makes mock players difficult
                    } else if (typeof first.on === 'function') {
                        // Add the listener to the other component
                        target.on(type, fn);
                        target.on('dispose', cleanRemover);
                    }
                }

                return this;
            };

            /**
             * Remove an event listener from this component's element
             *
             *     myComponent.off('eventType', myFunc);
             *
             * If myFunc is excluded, ALL listeners for the event type will be removed.
             * If eventType is excluded, ALL listeners will be removed from the component.
             *
             * Alternatively you can use `off` to remove listeners that were added to other
             * elements or components using `myComponent.on(otherComponent...`.
             * In this case both the event type and listener function are REQUIRED.
             *
             *     myComponent.off(otherElement, 'eventType', myFunc);
             *     myComponent.off(otherComponent, 'eventType', myFunc);
             *
             * @param  {String=|vjs.Component}  first  The event type or other component
             * @param  {Function=|String}       second The listener function or event type
             * @param  {Function=}              third  The listener for other component
             * @return {vjs.Component}
             */
            vjs.Component.prototype.off = function(first, second, third){
                var target, otherComponent, type, fn, otherEl;

                if (!first || typeof first === 'string' || vjs.obj.isArray(first)) {
                    vjs.off(this.el_, first, second);
                } else {
                    target = first;
                    type = second;
                    // Ensure there's at least a guid, even if the function hasn't been used
                    fn = vjs.bind(this, third);

                    // Remove the dispose listener on this component,
                    // which was given the same guid as the event listener
                    this.off('dispose', fn);

                    if (first.nodeName) {
                        // Remove the listener
                        vjs.off(target, type, fn);
                        // Remove the listener for cleaning the dispose listener
                        vjs.off(target, 'dispose', fn);
                    } else {
                        target.off(type, fn);
                        target.off('dispose', fn);
                    }
                }

                return this;
            };

            /**
             * Add an event listener to be triggered only once and then removed
             *
             *     myComponent.one('eventName', myFunc);
             *
             * Alternatively you can add a listener to another element or component
             * that will be triggered only once.
             *
             *     myComponent.one(otherElement, 'eventName', myFunc);
             *     myComponent.one(otherComponent, 'eventName', myFunc);
             *
             * @param  {String|vjs.Component}  first   The event type or other component
             * @param  {Function|String}       second  The listener function or event type
             * @param  {Function=}             third   The listener function for other component
             * @return {vjs.Component}
             */
            vjs.Component.prototype.one = function(first, second, third) {
                var target, type, fn, thisComponent, newFunc;

                if (typeof first === 'string' || vjs.obj.isArray(first)) {
                    vjs.one(this.el_, first, vjs.bind(this, second));
                } else {
                    target = first;
                    type = second;
                    fn = vjs.bind(this, third);
                    thisComponent = this;

                    newFunc = function(){
                        thisComponent.off(target, type, newFunc);
                        fn.apply(this, arguments);
                    };
                    // Keep the same function ID so we can remove it later
                    newFunc.guid = fn.guid;

                    this.on(target, type, newFunc);
                }

                return this;
            };

            /**
             * Trigger an event on an element
             *
             *     myComponent.trigger('eventName');
             *     myComponent.trigger({'type':'eventName'});
             *
             * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
             * @return {vjs.Component}       self
             */
            vjs.Component.prototype.trigger = function(event){
                vjs.trigger(this.el_, event);
                return this;
            };

            /* Ready
             ================================================================================ */
            /**
             * Is the component loaded
             * This can mean different things depending on the component.
             *
             * @private
             * @type {Boolean}
             */
            vjs.Component.prototype.isReady_;

            /**
             * Trigger ready as soon as initialization is finished
             *
             * Allows for delaying ready. Override on a sub class prototype.
             * If you set this.isReadyOnInitFinish_ it will affect all components.
             * Specially used when waiting for the Flash player to asynchronously load.
             *
             * @type {Boolean}
             * @private
             */
            vjs.Component.prototype.isReadyOnInitFinish_ = true;

            /**
             * List of ready listeners
             *
             * @type {Array}
             * @private
             */
            vjs.Component.prototype.readyQueue_;

            /**
             * Bind a listener to the component's ready state
             *
             * Different from event listeners in that if the ready event has already happened
             * it will trigger the function immediately.
             *
             * @param  {Function} fn Ready listener
             * @return {vjs.Component}
             */
            vjs.Component.prototype.ready = function(fn){
                if (fn) {
                    if (this.isReady_) {
                        fn.call(this);
                    } else {
                        if (this.readyQueue_ === undefined) {
                            this.readyQueue_ = [];
                        }
                        this.readyQueue_.push(fn);
                    }
                }
                return this;
            };

            /**
             * Trigger the ready listeners
             *
             * @return {vjs.Component}
             */
            vjs.Component.prototype.triggerReady = function(){
                this.isReady_ = true;

                var readyQueue = this.readyQueue_;

                if (readyQueue && readyQueue.length > 0) {

                    for (var i = 0, j = readyQueue.length; i < j; i++) {
                        readyQueue[i].call(this);
                    }

                    // Reset Ready Queue
                    this.readyQueue_ = [];

                    // Allow for using event listeners also, in case you want to do something everytime a source is ready.
                    this.trigger('ready');
                }
            };

            /* Display
             ============================================================================= */

            /**
             * Check if a component's element has a CSS class name
             *
             * @param {String} classToCheck Classname to check
             * @return {vjs.Component}
             */
            vjs.Component.prototype.hasClass = function(classToCheck){
                return vjs.hasClass(this.el_, classToCheck);
            };

            /**
             * Add a CSS class name to the component's element
             *
             * @param {String} classToAdd Classname to add
             * @return {vjs.Component}
             */
            vjs.Component.prototype.addClass = function(classToAdd){
                vjs.addClass(this.el_, classToAdd);
                return this;
            };

            /**
             * Remove a CSS class name from the component's element
             *
             * @param {String} classToRemove Classname to remove
             * @return {vjs.Component}
             */
            vjs.Component.prototype.removeClass = function(classToRemove){
                vjs.removeClass(this.el_, classToRemove);
                return this;
            };

            /**
             * Show the component element if hidden
             *
             * @return {vjs.Component}
             */
            vjs.Component.prototype.show = function(){
                this.removeClass('vjs-hidden');
                return this;
            };

            /**
             * Hide the component element if currently showing
             *
             * @return {vjs.Component}
             */
            vjs.Component.prototype.hide = function(){
                this.addClass('vjs-hidden');
                return this;
            };

            /**
             * Lock an item in its visible state
             * To be used with fadeIn/fadeOut.
             *
             * @return {vjs.Component}
             * @private
             */
            vjs.Component.prototype.lockShowing = function(){
                this.addClass('vjs-lock-showing');
                return this;
            };

            /**
             * Unlock an item to be hidden
             * To be used with fadeIn/fadeOut.
             *
             * @return {vjs.Component}
             * @private
             */
            vjs.Component.prototype.unlockShowing = function(){
                this.removeClass('vjs-lock-showing');
                return this;
            };

            /**
             * Disable component by making it unshowable
             *
             * Currently private because we're moving towards more css-based states.
             * @private
             */
            vjs.Component.prototype.disable = function(){
                this.hide();
                this.show = function(){};
            };

            /**
             * Set or get the width of the component (CSS values)
             *
             * Setting the video tag dimension values only works with values in pixels.
             * Percent values will not work.
             * Some percents can be used, but width()/height() will return the number + %,
             * not the actual computed width/height.
             *
             * @param  {Number|String=} num   Optional width number
             * @param  {Boolean} skipListeners Skip the 'resize' event trigger
             * @return {vjs.Component} This component, when setting the width
             * @return {Number|String} The width, when getting
             */
            vjs.Component.prototype.width = function(num, skipListeners){
                return this.dimension('width', num, skipListeners);
            };

            /**
             * Get or set the height of the component (CSS values)
             *
             * Setting the video tag dimension values only works with values in pixels.
             * Percent values will not work.
             * Some percents can be used, but width()/height() will return the number + %,
             * not the actual computed width/height.
             *
             * @param  {Number|String=} num     New component height
             * @param  {Boolean=} skipListeners Skip the resize event trigger
             * @return {vjs.Component} This component, when setting the height
             * @return {Number|String} The height, when getting
             */
            vjs.Component.prototype.height = function(num, skipListeners){
                return this.dimension('height', num, skipListeners);
            };

            /**
             * Set both width and height at the same time
             *
             * @param  {Number|String} width
             * @param  {Number|String} height
             * @return {vjs.Component} The component
             */
            vjs.Component.prototype.dimensions = function(width, height){
                // Skip resize listeners on width for optimization
                return this.width(width, true).height(height);
            };

            /**
             * Get or set width or height
             *
             * This is the shared code for the width() and height() methods.
             * All for an integer, integer + 'px' or integer + '%';
             *
             * Known issue: Hidden elements officially have a width of 0. We're defaulting
             * to the style.width value and falling back to computedStyle which has the
             * hidden element issue. Info, but probably not an efficient fix:
             * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
             *
             * @param  {String} widthOrHeight  'width' or 'height'
             * @param  {Number|String=} num     New dimension
             * @param  {Boolean=} skipListeners Skip resize event trigger
             * @return {vjs.Component} The component if a dimension was set
             * @return {Number|String} The dimension if nothing was set
             * @private
             */
            vjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners){
                if (num !== undefined) {
                    if (num === null || vjs.isNaN(num)) {
                        num = 0;
                    }

                    // Check if using css width/height (% or px) and adjust
                    if ((''+num).indexOf('%') !== -1 || (''+num).indexOf('px') !== -1) {
                        this.el_.style[widthOrHeight] = num;
                    } else if (num === 'auto') {
                        this.el_.style[widthOrHeight] = '';
                    } else {
                        this.el_.style[widthOrHeight] = num+'px';
                    }

                    // skipListeners allows us to avoid triggering the resize event when setting both width and height
                    if (!skipListeners) { this.trigger('resize'); }

                    // Return component
                    return this;
                }

                // Not setting a value, so getting it
                // Make sure element exists
                if (!this.el_) return 0;

                // Get dimension value from style
                var val = this.el_.style[widthOrHeight];
                var pxIndex = val.indexOf('px');
                if (pxIndex !== -1) {
                    // Return the pixel value with no 'px'
                    return parseInt(val.slice(0,pxIndex), 10);

                    // No px so using % or no style was set, so falling back to offsetWidth/height
                    // If component has display:none, offset will return 0
                    // TODO: handle display:none and no dimension style using px
                } else {

                    return parseInt(this.el_['offset'+vjs.capitalize(widthOrHeight)], 10);

                    // ComputedStyle version.
                    // Only difference is if the element is hidden it will return
                    // the percent value (e.g. '100%'')
                    // instead of zero like offsetWidth returns.
                    // var val = vjs.getComputedStyleValue(this.el_, widthOrHeight);
                    // var pxIndex = val.indexOf('px');

                    // if (pxIndex !== -1) {
                    //   return val.slice(0, pxIndex);
                    // } else {
                    //   return val;
                    // }
                }
            };

            /**
             * Fired when the width and/or height of the component changes
             * @event resize
             */
            vjs.Component.prototype.onResize;

            /**
             * Emit 'tap' events when touch events are supported
             *
             * This is used to support toggling the controls through a tap on the video.
             *
             * We're requiring them to be enabled because otherwise every component would
             * have this extra overhead unnecessarily, on mobile devices where extra
             * overhead is especially bad.
             * @private
             */
            vjs.Component.prototype.emitTapEvents = function(){
                var touchStart, firstTouch, touchTime, couldBeTap, noTap,
                    xdiff, ydiff, touchDistance, tapMovementThreshold, touchTimeThreshold;

                // Track the start time so we can determine how long the touch lasted
                touchStart = 0;
                firstTouch = null;

                // Maximum movement allowed during a touch event to still be considered a tap
                // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
                tapMovementThreshold = 10;

                // The maximum length a touch can be while still being considered a tap
                touchTimeThreshold = 200;

                this.on('touchstart', function(event) {
                    // If more than one finger, don't consider treating this as a click
                    if (event.touches.length === 1) {
                        firstTouch = vjs.obj.copy(event.touches[0]);
                        // Record start time so we can detect a tap vs. "touch and hold"
                        touchStart = new Date().getTime();
                        // Reset couldBeTap tracking
                        couldBeTap = true;
                    }
                });

                this.on('touchmove', function(event) {
                    // If more than one finger, don't consider treating this as a click
                    if (event.touches.length > 1) {
                        couldBeTap = false;
                    } else if (firstTouch) {
                        // Some devices will throw touchmoves for all but the slightest of taps.
                        // So, if we moved only a small distance, this could still be a tap
                        xdiff = event.touches[0].pageX - firstTouch.pageX;
                        ydiff = event.touches[0].pageY - firstTouch.pageY;
                        touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                        if (touchDistance > tapMovementThreshold) {
                            couldBeTap = false;
                        }
                    }
                });

                noTap = function(){
                    couldBeTap = false;
                };
                // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
                this.on('touchleave', noTap);
                this.on('touchcancel', noTap);

                // When the touch ends, measure how long it took and trigger the appropriate
                // event
                this.on('touchend', function(event) {
                    firstTouch = null;
                    // Proceed only if the touchmove/leave/cancel event didn't happen
                    if (couldBeTap === true) {
                        // Measure how long the touch lasted
                        touchTime = new Date().getTime() - touchStart;
                        // Make sure the touch was less than the threshold to be considered a tap
                        if (touchTime < touchTimeThreshold) {
                            event.preventDefault(); // Don't let browser turn this into a click
                            this.trigger('tap');
                            // It may be good to copy the touchend event object and change the
                            // type to tap, if the other event properties aren't exact after
                            // vjs.fixEvent runs (e.g. event.target)
                        }
                    }
                });
            };

            /**
             * Report user touch activity when touch events occur
             *
             * User activity is used to determine when controls should show/hide. It's
             * relatively simple when it comes to mouse events, because any mouse event
             * should show the controls. So we capture mouse events that bubble up to the
             * player and report activity when that happens.
             *
             * With touch events it isn't as easy. We can't rely on touch events at the
             * player level, because a tap (touchstart + touchend) on the video itself on
             * mobile devices is meant to turn controls off (and on). User activity is
             * checked asynchronously, so what could happen is a tap event on the video
             * turns the controls off, then the touchend event bubbles up to the player,
             * which if it reported user activity, would turn the controls right back on.
             * (We also don't want to completely block touch events from bubbling up)
             *
             * Also a touchmove, touch+hold, and anything other than a tap is not supposed
             * to turn the controls back on on a mobile device.
             *
             * Here we're setting the default component behavior to report user activity
             * whenever touch events happen, and this can be turned off by components that
             * want touch events to act differently.
             */
            vjs.Component.prototype.enableTouchActivity = function() {
                var report, touchHolding, touchEnd;

                // Don't continue if the root player doesn't support reporting user activity
                if (!this.player().reportUserActivity) {
                    return;
                }

                // listener for reporting that the user is active
                report = vjs.bind(this.player(), this.player().reportUserActivity);

                this.on('touchstart', function() {
                    report();
                    // For as long as the they are touching the device or have their mouse down,
                    // we consider them active even if they're not moving their finger or mouse.
                    // So we want to continue to update that they are active
                    this.clearInterval(touchHolding);
                    // report at the same interval as activityCheck
                    touchHolding = this.setInterval(report, 250);
                });

                touchEnd = function(event) {
                    report();
                    // stop the interval that maintains activity if the touch is holding
                    this.clearInterval(touchHolding);
                };

                this.on('touchmove', report);
                this.on('touchend', touchEnd);
                this.on('touchcancel', touchEnd);
            };

            /**
             * Creates timeout and sets up disposal automatically.
             * @param {Function} fn The function to run after the timeout.
             * @param {Number} timeout Number of ms to delay before executing specified function.
             * @return {Number} Returns the timeout ID
             */
            vjs.Component.prototype.setTimeout = function(fn, timeout) {
                fn = vjs.bind(this, fn);

                // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
                var timeoutId = setTimeout(fn, timeout);

                var disposeFn = function() {
                    this.clearTimeout(timeoutId);
                };

                disposeFn.guid = 'vjs-timeout-'+ timeoutId;

                this.on('dispose', disposeFn);

                return timeoutId;
            };


            /**
             * Clears a timeout and removes the associated dispose listener
             * @param {Number} timeoutId The id of the timeout to clear
             * @return {Number} Returns the timeout ID
             */
            vjs.Component.prototype.clearTimeout = function(timeoutId) {
                clearTimeout(timeoutId);

                var disposeFn = function(){};
                disposeFn.guid = 'vjs-timeout-'+ timeoutId;

                this.off('dispose', disposeFn);

                return timeoutId;
            };

            /**
             * Creates an interval and sets up disposal automatically.
             * @param {Function} fn The function to run every N seconds.
             * @param {Number} interval Number of ms to delay before executing specified function.
             * @return {Number} Returns the interval ID
             */
            vjs.Component.prototype.setInterval = function(fn, interval) {
                fn = vjs.bind(this, fn);

                var intervalId = setInterval(fn, interval);

                var disposeFn = function() {
                    this.clearInterval(intervalId);
                };

                disposeFn.guid = 'vjs-interval-'+ intervalId;

                this.on('dispose', disposeFn);

                return intervalId;
            };

            /**
             * Clears an interval and removes the associated dispose listener
             * @param {Number} intervalId The id of the interval to clear
             * @return {Number} Returns the interval ID
             */
            vjs.Component.prototype.clearInterval = function(intervalId) {
                clearInterval(intervalId);

                var disposeFn = function(){};
                disposeFn.guid = 'vjs-interval-'+ intervalId;

                this.off('dispose', disposeFn);

                return intervalId;
            };

            /* Button - Base class for all buttons
             ================================================================================ */
            /**
             * Base class for all buttons
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             */
            vjs.Button = vjs.Component.extend({
                /**
                 * @constructor
                 * @inheritDoc
                 */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    this.emitTapEvents();

                    this.on('tap', this.onClick);
                    this.on('click', this.onClick);
                    this.on('focus', this.onFocus);
                    this.on('blur', this.onBlur);
                }
            });

            vjs.Button.prototype.createEl = function(type, props){
                var el;

                // Add standard Aria and Tabindex info
                props = vjs.obj.merge({
                    className: this.buildCSSClass(),
                    'role': 'button',
                    'aria-live': 'polite', // let the screen reader user know that the text of the button may change
                    tabIndex: 0
                }, props);

                el = vjs.Component.prototype.createEl.call(this, type, props);

                // if innerHTML hasn't been overridden (bigPlayButton), add content elements
                if (!props.innerHTML) {
                    this.contentEl_ = vjs.createEl('div', {
                        className: 'vjs-control-content'
                    });

                    this.controlText_ = vjs.createEl('span', {
                        className: 'vjs-control-text',
                        innerHTML: this.localize(this.buttonText) || 'Need Text'
                    });

                    this.contentEl_.appendChild(this.controlText_);
                    el.appendChild(this.contentEl_);
                }

                return el;
            };

            vjs.Button.prototype.buildCSSClass = function(){
                // TODO: Change vjs-control to vjs-button?
                return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);
            };

            // Click - Override with specific functionality for button
            vjs.Button.prototype.onClick = function(){};

            // Focus - Add keyboard functionality to element
            vjs.Button.prototype.onFocus = function(){
                vjs.on(document, 'keydown', vjs.bind(this, this.onKeyPress));
            };

            // KeyPress (document level) - Trigger click when keys are pressed
            vjs.Button.prototype.onKeyPress = function(event){
                // Check for space bar (32) or enter (13) keys
                if (event.which == 32 || event.which == 13) {
                    event.preventDefault();
                    this.onClick();
                }
            };

            // Blur - Remove keyboard triggers
            vjs.Button.prototype.onBlur = function(){
                vjs.off(document, 'keydown', vjs.bind(this, this.onKeyPress));
            };

            /* Slider
             ================================================================================ */
            /**
             * The base functionality for sliders like the volume bar and seek bar
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.Slider = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    // Set property names to bar and handle to match with the child Slider class is looking for
                    this.bar = this.getChild(this.options_['barName']);
                    this.handle = this.getChild(this.options_['handleName']);

                    this.on('mousedown', this.onMouseDown);
                    this.on('touchstart', this.onMouseDown);
                    this.on('focus', this.onFocus);
                    this.on('blur', this.onBlur);
                    this.on('click', this.onClick);

                    this.on(player, 'controlsvisible', this.update);
                    this.on(player, this.playerEvent, this.update);
                }
            });

            vjs.Slider.prototype.createEl = function(type, props) {
                props = props || {};
                // Add the slider element class to all sub classes
                props.className = props.className + ' vjs-slider';
                props = vjs.obj.merge({
                    'role': 'slider',
                    'aria-valuenow': 0,
                    'aria-valuemin': 0,
                    'aria-valuemax': 100,
                    tabIndex: 0
                }, props);

                return vjs.Component.prototype.createEl.call(this, type, props);
            };

            vjs.Slider.prototype.onMouseDown = function(event){
                event.preventDefault();
                vjs.blockTextSelection();
                this.addClass('vjs-sliding');

                this.on(document, 'mousemove', this.onMouseMove);
                this.on(document, 'mouseup', this.onMouseUp);
                this.on(document, 'touchmove', this.onMouseMove);
                this.on(document, 'touchend', this.onMouseUp);

                this.onMouseMove(event);
            };

            // To be overridden by a subclass
            vjs.Slider.prototype.onMouseMove = function(){};

            vjs.Slider.prototype.onMouseUp = function() {
                vjs.unblockTextSelection();
                this.removeClass('vjs-sliding');

                this.off(document, 'mousemove', this.onMouseMove);
                this.off(document, 'mouseup', this.onMouseUp);
                this.off(document, 'touchmove', this.onMouseMove);
                this.off(document, 'touchend', this.onMouseUp);

                this.update();
            };

            vjs.Slider.prototype.update = function(){
                // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
                // execution stack. The player is destroyed before then update will cause an error
                if (!this.el_) return;

                // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
                // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
                // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();

                var barProgress,
                    progress = this.getPercent(),
                    handle = this.handle,
                    bar = this.bar;

                // Protect against no duration and other division issues
                if (typeof progress !== 'number' ||
                    progress !== progress ||
                    progress < 0 ||
                    progress === Infinity) {
                    progress = 0;
                }

                barProgress = progress;

                // If there is a handle, we need to account for the handle in our calculation for progress bar
                // so that it doesn't fall short of or extend past the handle.
                if (handle) {

                    var box = this.el_,
                        boxWidth = box.offsetWidth,

                        handleWidth = handle.el().offsetWidth,

                        // The width of the handle in percent of the containing box
                        // In IE, widths may not be ready yet causing NaN
                        handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,

                        // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
                        // There is a margin of half the handle's width on both sides.
                        boxAdjustedPercent = 1 - handlePercent,

                        // Adjust the progress that we'll use to set widths to the new adjusted box width
                        adjustedProgress = progress * boxAdjustedPercent;

                    // The bar does reach the left side, so we need to account for this in the bar's width
                    barProgress = adjustedProgress + (handlePercent / 2);

                    // Move the handle from the left based on the adjected progress
                    handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';
                }

                // Set the new bar width
                if (bar) {
                    bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';
                }
            };

            vjs.Slider.prototype.calculateDistance = function(event){
                var el, box, boxX, boxY, boxW, boxH, handle, pageX, pageY;

                el = this.el_;
                box = vjs.findPosition(el);
                boxW = boxH = el.offsetWidth;
                handle = this.handle;

                if (this.options()['vertical']) {
                    boxY = box.top;

                    if (event.changedTouches) {
                        pageY = event.changedTouches[0].pageY;
                    } else {
                        pageY = event.pageY;
                    }

                    if (handle) {
                        var handleH = handle.el().offsetHeight;
                        // Adjusted X and Width, so handle doesn't go outside the bar
                        boxY = boxY + (handleH / 2);
                        boxH = boxH - handleH;
                    }

                    // Percent that the click is through the adjusted area
                    return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));

                } else {
                    boxX = box.left;

                    if (event.changedTouches) {
                        pageX = event.changedTouches[0].pageX;
                    } else {
                        pageX = event.pageX;
                    }

                    if (handle) {
                        var handleW = handle.el().offsetWidth;

                        // Adjusted X and Width, so handle doesn't go outside the bar
                        boxX = boxX + (handleW / 2);
                        boxW = boxW - handleW;
                    }

                    // Percent that the click is through the adjusted area
                    return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
                }
            };

            vjs.Slider.prototype.onFocus = function(){
                this.on(document, 'keydown', this.onKeyPress);
            };

            vjs.Slider.prototype.onKeyPress = function(event){
                if (event.which == 37 || event.which == 40) { // Left and Down Arrows
                    event.preventDefault();
                    this.stepBack();
                } else if (event.which == 38 || event.which == 39) { // Up and Right Arrows
                    event.preventDefault();
                    this.stepForward();
                }
            };

            vjs.Slider.prototype.onBlur = function(){
                this.off(document, 'keydown', this.onKeyPress);
            };

            /**
             * Listener for click events on slider, used to prevent clicks
             *   from bubbling up to parent elements like button menus.
             * @param  {Object} event Event object
             */
            vjs.Slider.prototype.onClick = function(event){
                event.stopImmediatePropagation();
                event.preventDefault();
            };

            /**
             * SeekBar Behavior includes play progress bar, and seek handle
             * Needed so it can determine seek position based on handle position/size
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.SliderHandle = vjs.Component.extend();

            /**
             * Default value of the slider
             *
             * @type {Number}
             * @private
             */
            vjs.SliderHandle.prototype.defaultValue = 0;

            /** @inheritDoc */
            vjs.SliderHandle.prototype.createEl = function(type, props) {
                props = props || {};
                // Add the slider element class to all sub classes
                props.className = props.className + ' vjs-slider-handle';
                props = vjs.obj.merge({
                    innerHTML: '<span class="vjs-control-text">'+this.defaultValue+'</span>'
                }, props);

                return vjs.Component.prototype.createEl.call(this, 'div', props);
            };

            /* Menu
             ================================================================================ */
            /**
             * The Menu component is used to build pop up menus, including subtitle and
             * captions selection menus.
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             */
            vjs.Menu = vjs.Component.extend();

            /**
             * Add a menu item to the menu
             * @param {Object|String} component Component or component type to add
             */
            vjs.Menu.prototype.addItem = function(component){
                this.addChild(component);
                component.on('click', vjs.bind(this, function(){
                    this.unlockShowing();
                }));
            };

            /** @inheritDoc */
            vjs.Menu.prototype.createEl = function(){
                var contentElType = this.options().contentElType || 'ul';
                this.contentEl_ = vjs.createEl(contentElType, {
                    className: 'vjs-menu-content'
                });
                var el = vjs.Component.prototype.createEl.call(this, 'div', {
                    append: this.contentEl_,
                    className: 'vjs-menu'
                });
                el.appendChild(this.contentEl_);

                // Prevent clicks from bubbling up. Needed for Menu Buttons,
                // where a click on the parent is significant
                vjs.on(el, 'click', function(event){
                    event.preventDefault();
                    event.stopImmediatePropagation();
                });

                return el;
            };

            /**
             * The component for a menu item. `<li>`
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             */
            vjs.MenuItem = vjs.Button.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Button.call(this, player, options);
                    this.selected(options['selected']);
                }
            });

            /** @inheritDoc */
            vjs.MenuItem.prototype.createEl = function(type, props){
                return vjs.Button.prototype.createEl.call(this, 'li', vjs.obj.merge({
                    className: 'vjs-menu-item',
                    innerHTML: this.localize(this.options_['label'])
                }, props));
            };

            /**
             * Handle a click on the menu item, and set it to selected
             */
            vjs.MenuItem.prototype.onClick = function(){
                this.selected(true);
            };

            /**
             * Set this menu item as selected or not
             * @param  {Boolean} selected
             */
            vjs.MenuItem.prototype.selected = function(selected){
                if (selected) {
                    this.addClass('vjs-selected');
                    this.el_.setAttribute('aria-selected',true);
                } else {
                    this.removeClass('vjs-selected');
                    this.el_.setAttribute('aria-selected',false);
                }
            };


            /**
             * A button class with a popup menu
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.MenuButton = vjs.Button.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Button.call(this, player, options);

                    this.update();

                    this.on('keydown', this.onKeyPress);
                    this.el_.setAttribute('aria-haspopup', true);
                    this.el_.setAttribute('role', 'button');
                }
            });

            vjs.MenuButton.prototype.update = function() {
                var menu = this.createMenu();

                if (this.menu) {
                    this.removeChild(this.menu);
                }

                this.menu = menu;
                this.addChild(menu);

                if (this.items && this.items.length === 0) {
                    this.hide();
                } else if (this.items && this.items.length > 1) {
                    this.show();
                }
            };

            /**
             * Track the state of the menu button
             * @type {Boolean}
             * @private
             */
            vjs.MenuButton.prototype.buttonPressed_ = false;

            vjs.MenuButton.prototype.createMenu = function(){
                var menu = new vjs.Menu(this.player_);

                // Add a title list item to the top
                if (this.options().title) {
                    menu.contentEl().appendChild(vjs.createEl('li', {
                        className: 'vjs-menu-title',
                        innerHTML: vjs.capitalize(this.options().title),
                        tabindex: -1
                    }));
                }

                this.items = this['createItems']();

                if (this.items) {
                    // Add menu items to the menu
                    for (var i = 0; i < this.items.length; i++) {
                        menu.addItem(this.items[i]);
                    }
                }

                return menu;
            };

            /**
             * Create the list of menu items. Specific to each subclass.
             */
            vjs.MenuButton.prototype.createItems = function(){};

            /** @inheritDoc */
            vjs.MenuButton.prototype.buildCSSClass = function(){
                return this.className + ' vjs-menu-button ' + vjs.Button.prototype.buildCSSClass.call(this);
            };

            // Focus - Add keyboard functionality to element
            // This function is not needed anymore. Instead, the keyboard functionality is handled by
            // treating the button as triggering a submenu. When the button is pressed, the submenu
            // appears. Pressing the button again makes the submenu disappear.
            vjs.MenuButton.prototype.onFocus = function(){};
            // Can't turn off list display that we turned on with focus, because list would go away.
            vjs.MenuButton.prototype.onBlur = function(){};

            vjs.MenuButton.prototype.onClick = function(){
                // When you click the button it adds focus, which will show the menu indefinitely.
                // So we'll remove focus when the mouse leaves the button.
                // Focus is needed for tab navigation.
                this.one('mouseout', vjs.bind(this, function(){
                    this.menu.unlockShowing();
                    this.el_.blur();
                }));
                if (this.buttonPressed_){
                    this.unpressButton();
                } else {
                    this.pressButton();
                }
            };

            vjs.MenuButton.prototype.onKeyPress = function(event){

                // Check for space bar (32) or enter (13) keys
                if (event.which == 32 || event.which == 13) {
                    if (this.buttonPressed_){
                        this.unpressButton();
                    } else {
                        this.pressButton();
                    }
                    event.preventDefault();
                    // Check for escape (27) key
                } else if (event.which == 27){
                    if (this.buttonPressed_){
                        this.unpressButton();
                    }
                    event.preventDefault();
                }
            };

            vjs.MenuButton.prototype.pressButton = function(){
                this.buttonPressed_ = true;
                this.menu.lockShowing();
                this.el_.setAttribute('aria-pressed', true);
                if (this.items && this.items.length > 0) {
                    this.items[0].el().focus(); // set the focus to the title of the submenu
                }
            };

            vjs.MenuButton.prototype.unpressButton = function(){
                this.buttonPressed_ = false;
                this.menu.unlockShowing();
                this.el_.setAttribute('aria-pressed', false);
            };

            /**
             * Custom MediaError to mimic the HTML5 MediaError
             * @param {Number} code The media error code
             */
            vjs.MediaError = function(code){

                if (typeof code === 'number') {
                    this.code = code;
                } else if (typeof code === 'string') {
                    // default code is zero, so this is a custom error
                    this.message = code;
                } else if (typeof code === 'object') { // object
                    vjs.obj.merge(this, code);
                }

                if (!this.message) {
                    //this.message = vjs.MediaError.defaultMessages[this.code] || '';
                    this.message = '';//VID-1444
                }
            };

            /**
             * The error code that refers two one of the defined
             * MediaError types
             * @type {Number}
             */
            vjs.MediaError.prototype.code = 0;

            /**
             * An optional message to be shown with the error.
             * Message is not part of the HTML5 video spec
             * but allows for more informative custom errors.
             * @type {String}
             */
            vjs.MediaError.prototype.message = '';

            /**
             * An optional status code that can be set by plugins
             * to allow even more detail about the error.
             * For example the HLS plugin might provide the specific
             * HTTP status code that was returned when the error
             * occurred, then allowing a custom error overlay
             * to display more information.
             * @type {[type]}
             */
            vjs.MediaError.prototype.status = null;

            vjs.MediaError.errorTypes = [
                'MEDIA_ERR_CUSTOM',            // = 0
                'MEDIA_ERR_ABORTED',           // = 1
                'MEDIA_ERR_NETWORK',           // = 2
                'MEDIA_ERR_DECODE',            // = 3
                'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
                'MEDIA_ERR_ENCRYPTED'          // = 5
            ];

            vjs.MediaError.defaultMessages = {
                1: 'You aborted the video playback',
                2: 'A network error caused the video download to fail part-way.',
                3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
                4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
                5: 'The video is encrypted and we do not have the keys to decrypt it.'
            };

            // Add types as properties on MediaError
            // e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
            for (var errNum = 0; errNum < vjs.MediaError.errorTypes.length; errNum++) {
                vjs.MediaError[vjs.MediaError.errorTypes[errNum]] = errNum;
                // values should be accessible on both the class and instance
                vjs.MediaError.prototype[vjs.MediaError.errorTypes[errNum]] = errNum;
            }

            (function(){
                var apiMap, specApi, browserApi, i;

                /**
                 * Store the browser-specific methods for the fullscreen API
                 * @type {Object|undefined}
                 * @private
                 */
                vjs.browser.fullscreenAPI;

                // browser API methods
                // map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
                apiMap = [
                    // Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
                    [
                        'requestFullscreen',
                        'exitFullscreen',
                        'fullscreenElement',
                        'fullscreenEnabled',
                        'fullscreenchange',
                        'fullscreenerror'
                    ],
                    // WebKit
                    [
                        'webkitRequestFullscreen',
                        'webkitExitFullscreen',
                        'webkitFullscreenElement',
                        'webkitFullscreenEnabled',
                        'webkitfullscreenchange',
                        'webkitfullscreenerror'
                    ],
                    // Old WebKit (Safari 5.1)
                    [
                        'webkitRequestFullScreen',
                        'webkitCancelFullScreen',
                        'webkitCurrentFullScreenElement',
                        'webkitCancelFullScreen',
                        'webkitfullscreenchange',
                        'webkitfullscreenerror'
                    ],
                    // Mozilla
                    [
                        'mozRequestFullScreen',
                        'mozCancelFullScreen',
                        'mozFullScreenElement',
                        'mozFullScreenEnabled',
                        'mozfullscreenchange',
                        'mozfullscreenerror'
                    ],
                    // Microsoft
                    [
                        'msRequestFullscreen',
                        'msExitFullscreen',
                        'msFullscreenElement',
                        'msFullscreenEnabled',
                        'MSFullscreenChange',
                        'MSFullscreenError'
                    ]
                ];

                specApi = apiMap[0];

                // determine the supported set of functions
                for (i=0; i<apiMap.length; i++) {
                    // check for exitFullscreen function
                    if (apiMap[i][1] in document) {
                        browserApi = apiMap[i];
                        break;
                    }
                }

                // map the browser API names to the spec API names
                // or leave vjs.browser.fullscreenAPI undefined
                if (browserApi) {
                    vjs.browser.fullscreenAPI = {};

                    for (i=0; i<browserApi.length; i++) {
                        vjs.browser.fullscreenAPI[specApi[i]] = browserApi[i];
                    }
                }

            })();

            /**
             * An instance of the `vjs.Player` class is created when any of the Video.js setup methods are used to initialize a video.
             *
             * ```js
             * var myPlayer = videojs('example_video_1');
             * ```
             *
             * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
             *
             * ```html
             * <video id="example_video_1" data-setup='{}' controls>
             *   <source src="my-source.mp4" type="video/mp4">
             * </video>
             * ```
             *
             * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
             *
             * @class
             * @extends vjs.Component
             */
            vjs.Player = vjs.Component.extend({

                /**
                 * player's constructor function
                 *
                 * @constructs
                 * @method init
                 * @param {Element} tag        The original video tag used for configuring options
                 * @param {Object=} options    Player options
                 * @param {Function=} ready    Ready callback function
                 */
                init: function(tag, options, ready){
                    this.tag = tag; // Store the original tag used to set options

                    // Make sure tag ID exists
                    tag.id = tag.id || 'vjs_video_' + vjs.guid++;

                    // Store the tag attributes used to restore html5 element
                    this.tagAttributes = tag && vjs.getElementAttributes(tag);

                    // Set Options
                    // The options argument overrides options set in the video tag
                    // which overrides globally set options.
                    // This latter part coincides with the load order
                    // (tag must exist before Player)
                    options = vjs.obj.merge(this.getTagSettings(tag), options);

                    // Update Current Language
                    this.language_ = options['language'] || vjs.options['language'];

                    // Update Supported Languages
                    this.languages_ = options['languages'] || vjs.options['languages'];

                    // Cache for video property values.
                    this.cache_ = {};

                    // Set poster
                    this.poster_ = options['poster'] || '';

                    // Set controls
                    this.controls_ = !!options['controls'];
                    // Original tag settings stored in options
                    // now remove immediately so native controls don't flash.
                    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
                    tag.controls = false;

                    // we don't want the player to report touch activity on itself
                    // see enableTouchActivity in Component
                    options.reportTouchActivity = false;

                    // Set isAudio based on whether or not an audio tag was used
                    this.isAudio(this.tag.nodeName.toLowerCase() === 'audio');

                    // Run base component initializing with new options.
                    // Builds the element through createEl()
                    // Inits and embeds any child components in opts
                    vjs.Component.call(this, this, options, ready);

                    // Update controls className. Can't do this when the controls are initially
                    // set because the element doesn't exist yet.
                    if (this.controls()) {
                        this.addClass('vjs-controls-enabled');
                    } else {
                        this.addClass('vjs-controls-disabled');
                    }

                    if (this.isAudio()) {
                        this.addClass('vjs-audio');
                    }

                    this.addClass('vjs-big-play-centered');

                    // TODO: Make this smarter. Toggle user state between touching/mousing
                    // using events, since devices can have both touch and mouse events.
                    // if (vjs.TOUCH_ENABLED) {
                    //   this.addClass('vjs-touch-enabled');
                    // }

                    // Make player easily findable by ID
                    vjs.players[this.id_] = this;

                    if (options['plugins']) {
                        vjs.obj.each(options['plugins'], function(key, val){
                            this[key](val);
                        }, this);
                    }

                    //Ref: VID 601 Disabling the activity tracker for JS VPAID
                    if(!options['vpaid']){
                        this.listenForUserActivity();
                    }
                }
            });

            /**
             * The player's stored language code
             *
             * @type {String}
             * @private
             */
            vjs.Player.prototype.language_;

            /**
             * The player's language code
             * @param  {String} languageCode  The locale string
             * @return {String}             The locale string when getting
             * @return {vjs.Player}         self, when setting
             */
            vjs.Player.prototype.language = function (languageCode) {
                if (languageCode === undefined) {
                    return this.language_;
                }

                this.language_ = languageCode;
                return this;
            };

            /**
             * The player's override for Volume controls
             * @return {Boolean}             The volume override
             */
            vjs.Player.prototype.getMuteSettingsForIOS10 = function () {
                //VID-2810 Override the video-js volume logic for IOS 10 and above which allow the set up of the volume
                return vjs.IS_IOS && this.options_['enableNativeInline'] && (parseInt(vjs.IOS_VERSION) > 9);

            };

            /**
             * The player's stored language dictionary
             *
             * @type {Object}
             * @private
             */
            vjs.Player.prototype.languages_;

            vjs.Player.prototype.languages = function(){
                return this.languages_;
            };

            /**
             * Player instance options, surfaced using vjs.options
             * vjs.options = vjs.Player.prototype.options_
             * Make changes in vjs.options, not here.
             * All options should use string keys so they avoid
             * renaming by closure compiler
             * @type {Object}
             * @private
             */
            vjs.Player.prototype.options_ = vjs.options;

            /**
             * Destroys the video player and does any necessary cleanup
             *
             *     myPlayer.dispose();
             *
             * This is especially helpful if you are dynamically adding and removing videos
             * to/from the DOM.
             */
            vjs.Player.prototype.dispose = function(){
                this.trigger('dispose');
                // prevent dispose from being called twice
                this.off('dispose');

                // Kill reference to this player
                vjs.players[this.id_] = null;
                if (this.tag && this.tag['player']) { this.tag['player'] = null; }
                if (this.el_ && this.el_['player']) { this.el_['player'] = null; }

                if (this.tech) { this.tech.dispose(); }

                // Component dispose
                vjs.Component.prototype.dispose.call(this);
            };

            vjs.Player.prototype.getTagSettings = function(tag){
                var tagOptions,
                    dataSetup,
                    options = {
                        'sources': [],
                        'tracks': []
                    };

                tagOptions = vjs.getElementAttributes(tag);
                dataSetup = tagOptions['data-setup'];

                // Check if data-setup attr exists.
                if (dataSetup !== null){
                    // Parse options JSON
                    // If empty string, make it a parsable json object.
                    vjs.obj.merge(tagOptions, vjs.JSON.parse(dataSetup || '{}'));
                }

                vjs.obj.merge(options, tagOptions);

                // Get tag children settings
                if (tag.hasChildNodes()) {
                    var children, child, childName, i, j;

                    children = tag.childNodes;

                    for (i=0,j=children.length; i<j; i++) {
                        child = children[i];
                        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
                        childName = child.nodeName.toLowerCase();
                        if (childName === 'source') {
                            options['sources'].push(vjs.getElementAttributes(child));
                        } else if (childName === 'track') {
                            options['tracks'].push(vjs.getElementAttributes(child));
                        }
                    }
                }

                return options;
            };

            vjs.Player.prototype.createEl = function(){
                var
                    el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div'),
                    tag = this.tag,
                    attrs;

                // Remove width/height attrs from tag so CSS can make it 100% width/height
                tag.removeAttribute('width');
                tag.removeAttribute('height');

                // Copy over all the attributes from the tag, including ID and class
                // ID will now reference player box, not the video tag
                attrs = vjs.getElementAttributes(tag);
                vjs.obj.each(attrs, function(attr) {
                    // workaround so we don't totally break IE7
                    // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
                    if (attr == 'class') {
                        el.className = attrs[attr];
                    } else {
                        el.setAttribute(attr, attrs[attr]);
                    }
                });

                // Update tag id/class for use as HTML5 playback tech
                // Might think we should do this after embedding in container so .vjs-tech class
                // doesn't flash 100% width/height, but class only applies with .video-js parent
                tag.id += '_html5_api';
                tag.className = 'vjs-tech';

                // Make player findable on elements
                tag['player'] = el['player'] = this;
                // Default state of video is paused
                this.addClass('vjs-paused');

                // Make box use width/height of tag, or rely on default implementation
                // Enforce with CSS since width/height attrs don't work on divs
                this.width(this.options_['width'], true); // (true) Skip resize listener on load
                this.height(this.options_['height'], true);

                // vjs.insertFirst seems to cause the networkState to flicker from 3 to 2, so
                // keep track of the original for later so we can know if the source originally failed
                tag.initNetworkState_ = tag.networkState;

                // Wrap video tag in div (el/box) container
                if (tag.parentNode) {
                    tag.parentNode.insertBefore(el, tag);
                }
                vjs.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

                // The event listeners need to be added before the children are added
                // in the component init because the tech (loaded with mediaLoader) may
                // fire events, like loadstart, that these events need to capture.
                // Long term it might be better to expose a way to do this in component.init
                // like component.initEventListeners() that runs between el creation and
                // adding children
                this.el_ = el;
                this.on('loadstart', this.onLoadStart);
                this.on('waiting', this.onWaiting);
                this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
                this.on('seeking', this.onSeeking);
                this.on('seeked', this.onSeeked);
                this.on('ended', this.onEnded);
                this.on('play', this.onPlay);
                this.on('firstplay', this.onFirstPlay);
                this.on('pause', this.onPause);
                this.on('progress', this.onProgress);
                this.on('durationchange', this.onDurationChange);
                this.on('fullscreenchange', this.onFullscreenChange);

                return el;
            };

            // /* Media Technology (tech)
            // ================================================================================ */
            // Load/Create an instance of playback technology including element and API methods
            // And append playback element in player div.
            vjs.Player.prototype.loadTech = function(techName, source){

                // Pause and remove current playback technology
                if (this.tech) {
                    this.unloadTech();
                }

                // get rid of the HTML5 video tag as soon as we are using another tech
                if (techName !== 'Html5' && this.tag) {
                    vjs.Html5.disposeMediaElement(this.tag);
                    this.tag = null;
                }

                this.techName = techName;

                // Turn off API access because we're loading a new tech that might load asynchronously
                this.isReady_ = false;

                var techReady = function(){
                    this.player_.triggerReady();
                };

                // Grab tech-specific options from player options and add source and parent element to use.
                var techOptions = vjs.obj.merge({ 'source': source, 'parentEl': this.el_ }, this.options_[techName.toLowerCase()]);

                if (source) {
                    this.currentType_ = source.type;
                    if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
                        techOptions['startTime'] = this.cache_.currentTime;
                    }

                    this.cache_.src = source.src;
                }

                // Initialize tech instance
                this.tech = new window['videojs_apn'][techName](this, techOptions);

                this.tech.ready(techReady);
            };

            vjs.Player.prototype.unloadTech = function(){
                this.isReady_ = false;

                this.tech.dispose();

                this.tech = false;
            };

            // There's many issues around changing the size of a Flash (or other plugin) object.
            // First is a plugin reload issue in Firefox that has been around for 11 years: https://bugzilla.mozilla.org/show_bug.cgi?id=90268
            // Then with the new fullscreen API, Mozilla and webkit browsers will reload the flash object after going to fullscreen.
            // To get around this, we're unloading the tech, caching source and currentTime values, and reloading the tech once the plugin is resized.
            // reloadTech: function(betweenFn){
            //   vjs.log('unloadingTech')
            //   this.unloadTech();
            //   vjs.log('unloadedTech')
            //   if (betweenFn) { betweenFn.call(); }
            //   vjs.log('LoadingTech')
            //   this.loadTech(this.techName, { src: this.cache_.src })
            //   vjs.log('loadedTech')
            // },

            // /* Player event handlers (how the player reacts to certain events)
            // ================================================================================ */

            /**
             * Fired when the user agent begins looking for media data
             * @event loadstart
             */
            vjs.Player.prototype.onLoadStart = function() {
                // TODO: Update to use `emptied` event instead. See #1277.

                this.removeClass('vjs-ended');

                // reset the error state
                this.error(null);

                // If it's already playing we want to trigger a firstplay event now.
                // The firstplay event relies on both the play and loadstart events
                // which can happen in any order for a new source
                if (!this.paused()) {
                    this.trigger('firstplay');
                } else {
                    // reset the hasStarted state
                    this.hasStarted(false);
                }
            };

            vjs.Player.prototype.hasStarted_ = false;

            vjs.Player.prototype.hasStarted = function(hasStarted){
                if (hasStarted !== undefined) {
                    // only update if this is a new value
                    if (this.hasStarted_ !== hasStarted) {
                        this.hasStarted_ = hasStarted;
                        if (hasStarted) {
                            this.addClass('vjs-has-started');
                            // trigger the firstplay event if this newly has played
                            this.trigger('firstplay');
                        } else {
                            this.removeClass('vjs-has-started');
                        }
                    }
                    return this;
                }
                return this.hasStarted_;
            };

            /**
             * Fired when the player has initial duration and dimension information
             * @event loadedmetadata
             */
            vjs.Player.prototype.onLoadedMetaData;

            /**
             * Fired when the player has downloaded data at the current playback position
             * @event loadeddata
             */
            vjs.Player.prototype.onLoadedData;

            /**
             * Fired when the player has finished downloading the source data
             * @event loadedalldata
             */
            vjs.Player.prototype.onLoadedAllData;

            /**
             * Fired whenever the media begins or resumes playback
             * @event play
             */
            vjs.Player.prototype.onPlay = function(){
                this.removeClass('vjs-ended');
                this.removeClass('vjs-paused');
                this.addClass('vjs-playing');

                // hide the poster when the user hits play
                // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
                this.hasStarted(true);
            };

            /**
             * Fired whenever the media begins waiting
             * @event waiting
             */
            vjs.Player.prototype.onWaiting = function(){
                this.addClass('vjs-waiting');
            };

            /**
             * A handler for events that signal that waiting has ended
             * which is not consistent between browsers. See #1351
             * @private
             */
            vjs.Player.prototype.onWaitEnd = function(){
                this.removeClass('vjs-waiting');
            };

            /**
             * Fired whenever the player is jumping to a new time
             * @event seeking
             */
            vjs.Player.prototype.onSeeking = function(){
                this.addClass('vjs-seeking');
            };

            /**
             * Fired when the player has finished jumping to a new time
             * @event seeked
             */
            vjs.Player.prototype.onSeeked = function(){
                this.removeClass('vjs-seeking');
            };

            /**
             * Fired the first time a video is played
             *
             * Not part of the HLS spec, and we're not sure if this is the best
             * implementation yet, so use sparingly. If you don't have a reason to
             * prevent playback, use `myPlayer.one('play');` instead.
             *
             * @event firstplay
             */
            vjs.Player.prototype.onFirstPlay = function(){
                //If the first starttime attribute is specified
                //then we will start at the given offset in seconds
                if(this.options_['starttime']){
                    this.currentTime(this.options_['starttime']);
                }

                this.addClass('vjs-has-started');
            };

            /**
             * Fired whenever the media has been paused
             * @event pause
             */
            vjs.Player.prototype.onPause = function(){
                this.removeClass('vjs-playing');
                this.addClass('vjs-paused');
            };

            /**
             * Fired when the current playback position has changed
             *
             * During playback this is fired every 15-250 milliseconds, depending on the
             * playback technology in use.
             * @event timeupdate
             */
            vjs.Player.prototype.onTimeUpdate;

            /**
             * Fired while the user agent is downloading media data
             * @event progress
             */
            vjs.Player.prototype.onProgress = function(){
                // Add custom event for when source is finished downloading.
                if (this.bufferedPercent() == 1) {
                    this.trigger('loadedalldata');
                }
            };

            /**
             * Fired when the end of the media resource is reached (currentTime == duration)
             * @event ended
             */
            vjs.Player.prototype.onEnded = function(){
                this.addClass('vjs-ended');
                if (this.options_['loop']) {
                    this.currentTime(0);
                    this.play();
                } else if (!this.paused()) {
                    this.pause();
                }
            };

            /**
             * Fired when the duration of the media resource is first known or changed
             * @event durationchange
             */
            vjs.Player.prototype.onDurationChange = function(){
                // Allows for caching value instead of asking player each time.
                // We need to get the techGet response and check for a value so we don't
                // accidentally cause the stack to blow up.
                var duration = this.techGet('duration');
                if (duration) {
                    if (duration < 0) {
                        duration = Infinity;
                    }
                    this.duration(duration);
                    // Determine if the stream is live and propagate styles down to UI.
                    if (duration === Infinity) {
                        this.addClass('vjs-live');
                    } else {
                        this.removeClass('vjs-live');
                    }
                }
            };

            /**
             * Fired when the volume changes
             * @event volumechange
             */
            vjs.Player.prototype.onVolumeChange;

            /**
             * Fired when the player switches in or out of fullscreen mode
             * @event fullscreenchange
             */
            vjs.Player.prototype.onFullscreenChange = function() {
                if (this.isFullscreen()) {
                    this.addClass('vjs-fullscreen');
                } else {
                    this.removeClass('vjs-fullscreen');
                }
            };

            /**
             * Fired when an error occurs
             * @event error
             */
            vjs.Player.prototype.onError;

            // /* Player API
            // ================================================================================ */

            /**
             * Object for cached values.
             * @private
             */
            vjs.Player.prototype.cache_;

            vjs.Player.prototype.getCache = function(){
                return this.cache_;
            };

            // Pass values to the playback tech
            vjs.Player.prototype.techCall = function(method, arg){
                // If it's not ready yet, call method when it is
                if (this.tech && !this.tech.isReady_) {
                    this.tech.ready(function(){
                        this[method](arg);
                    });

                    // Otherwise call method now
                } else {
                    try {
                        this.tech[method](arg);
                    } catch(e) {
                        vjs.log(e);
                        throw e;
                    }
                }
            };

            // Get calls can't wait for the tech, and sometimes don't need to.
            vjs.Player.prototype.techGet = function(method){
                if (this.tech && this.tech.isReady_) {

                    // Flash likes to die and reload when you hide or reposition it.
                    // In these cases the object methods go away and we get errors.
                    // When that happens we'll catch the errors and inform tech that it's not ready any more.
                    try {
                        return this.tech[method]();
                    } catch(e) {
                        // When building additional tech libs, an expected method may not be defined yet
                        if (this.tech[method] === undefined) {
                            vjs.log('Video.js: ' + method + ' method not defined for '+this.techName+' playback technology.', e);
                        } else {
                            // When a method isn't available on the object it throws a TypeError
                            if (e.name == 'TypeError') {
                                vjs.log('Video.js: ' + method + ' unavailable on '+this.techName+' playback technology element.', e);
                                this.tech.isReady_ = false;
                            } else {
                                vjs.log(e);
                            }
                        }
                        throw e;
                    }
                }

                return;
            };

            /**
             * start media playback
             *
             *     myPlayer.play();
             *
             * @return {vjs.Player} self
             */
            vjs.Player.prototype.play = function(){
                this.techCall('play');
                return this;
            };

            /**
             * Pause the video playback
             *
             *     myPlayer.pause();
             *
             * @return {vjs.Player} self
             */
            vjs.Player.prototype.pause = function(){
                this.techCall('pause');
                this.trigger("apn-vpaid-pause");//VID-2405, VID-2406
                return this;
            };

            /**
             * Check if the player is paused
             *
             *     var isPaused = myPlayer.paused();
             *     var isPlaying = !myPlayer.paused();
             *
             * @return {Boolean} false if the media is currently playing, or true otherwise
             */
            vjs.Player.prototype.paused = function(){
                // The initial state of paused should be true (in Safari it's actually false)
                return (this.techGet('paused') === false) ? false : true;
            };

            /**
             * Get or set the current time (in seconds)
             *
             *     // get
             *     var whereYouAt = myPlayer.currentTime();
             *
             *     // set
             *     myPlayer.currentTime(120); // 2 minutes into the video
             *
             * @param  {Number|String=} seconds The time to seek to
             * @return {Number}        The time in seconds, when not setting
             * @return {vjs.Player}    self, when the current time is set
             */
            vjs.Player.prototype.currentTime = function(seconds){
                if (seconds !== undefined) {

                    this.techCall('setCurrentTime', seconds);

                    return this;
                }

                // cache last currentTime and return. default to 0 seconds
                //
                // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
                // currentTime when scrubbing, but may not provide much performance benefit afterall.
                // Should be tested. Also something has to read the actual current time or the cache will
                // never get updated.
                return this.cache_.currentTime = (this.techGet('currentTime') || 0);
            };

            /**
             * Get the length in time of the video in seconds
             *
             *     var lengthOfVideo = myPlayer.duration();
             *
             * **NOTE**: The video must have started loading before the duration can be
             * known, and in the case of Flash, may not be known until the video starts
             * playing.
             *
             * @return {Number} The duration of the video in seconds
             */
            vjs.Player.prototype.duration = function(seconds){
                if (seconds !== undefined) {

                    // cache the last set value for optimized scrubbing (esp. Flash)
                    this.cache_.duration = parseFloat(seconds);

                    return this;
                }

                if (this.cache_.duration === undefined) {
                    this.onDurationChange();
                }

                return this.cache_.duration || 0;
            };

            /**
             * Calculates how much time is left.
             *
             *     var timeLeft = myPlayer.remainingTime();
             *
             * Not a native video element function, but useful
             * @return {Number} The time remaining in seconds
             */
            vjs.Player.prototype.remainingTime = function(){
                return this.duration() - this.currentTime();
            };

            // http://dev.w3.org/html5/spec/video.html#dom-media-buffered
            // Buffered returns a timerange object.
            // Kind of like an array of portions of the video that have been downloaded.

            /**
             * Get a TimeRange object with the times of the video that have been downloaded
             *
             * If you just want the percent of the video that's been downloaded,
             * use bufferedPercent.
             *
             *     // Number of different ranges of time have been buffered. Usually 1.
             *     numberOfRanges = bufferedTimeRange.length,
             *
             *     // Time in seconds when the first range starts. Usually 0.
             *     firstRangeStart = bufferedTimeRange.start(0),
             *
             *     // Time in seconds when the first range ends
             *     firstRangeEnd = bufferedTimeRange.end(0),
             *
             *     // Length in seconds of the first time range
             *     firstRangeLength = firstRangeEnd - firstRangeStart;
             *
             * @return {Object} A mock TimeRange object (following HTML spec)
             */
            vjs.Player.prototype.buffered = function(){
                var buffered = this.techGet('buffered');

                if (!buffered || !buffered.length) {
                    buffered = vjs.createTimeRange(0,0);
                }

                return buffered;
            };

            /**
             * Get the percent (as a decimal) of the video that's been downloaded
             *
             *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
             *
             * 0 means none, 1 means all.
             * (This method isn't in the HTML5 spec, but it's very convenient)
             *
             * @return {Number} A decimal between 0 and 1 representing the percent
             */
            vjs.Player.prototype.bufferedPercent = function(){
                var duration = this.duration(),
                    buffered = this.buffered(),
                    bufferedDuration = 0,
                    start, end;

                if (!duration) {
                    return 0;
                }

                for (var i=0; i<buffered.length; i++){
                    start = buffered.start(i);
                    end   = buffered.end(i);

                    // buffered end can be bigger than duration by a very small fraction
                    if (end > duration) {
                        end = duration;
                    }

                    bufferedDuration += end - start;
                }

                return bufferedDuration / duration;
            };

            /**
             * Get the ending time of the last buffered time range
             *
             * This is used in the progress bar to encapsulate all time ranges.
             * @return {Number} The end of the last buffered time range
             */
            vjs.Player.prototype.bufferedEnd = function(){
                var buffered = this.buffered(),
                    duration = this.duration(),
                    end = buffered.end(buffered.length-1);

                if (end > duration) {
                    end = duration;
                }

                return end;
            };

            /**
             * Get or set the current volume of the media
             *
             *     // get
             *     var howLoudIsIt = myPlayer.volume();
             *
             *     // set
             *     myPlayer.volume(0.5); // Set volume to half
             *
             * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
             *
             * @param  {Number} percentAsDecimal The new volume as a decimal percent
             * @return {Number}                  The current volume, when getting
             * @return {vjs.Player}              self, when setting
             */
            vjs.Player.prototype.volume = function(percentAsDecimal){
                var vol;

                if (percentAsDecimal !== undefined) {
                    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
                    this.cache_.volume = vol;
                    this.techCall('setVolume', vol);
                    vjs.setLocalStorage('volume', vol);
                    return this;
                }

                // Default to 1 when returning current volume.
                vol = parseFloat(this.techGet('volume'));
                return (isNaN(vol)) ? 1 : vol;
            };


            /**
             * Get the current muted state, or turn mute on or off
             *
             *     // get
             *     var isVolumeMuted = myPlayer.muted();
             *
             *     // set
             *     myPlayer.muted(true); // mute the volume
             *
             * @param  {Boolean=} muted True to mute, false to unmute
             * @return {Boolean} True if mute is on, false if not, when getting
             * @return {vjs.Player} self, when setting mute
             */
            vjs.Player.prototype.muted = function(muted){
                if (muted !== undefined) {
                    //for VID-2793 this mute doesn't need to be invoked if inline module enabled because the module has own mute/unmute features
                    var supressMutedForIOS = vjs.IS_IOS && this.options_['enableInlineVideoForIos'];
                    if (!supressMutedForIOS) {
                        this.techCall('setMuted', muted);
                    }
                    return this;
                }
                return this.techGet('muted') || false; // Default to false
            };

            // Check if current tech can support native fullscreen
            // (e.g. with built in controls like iOS, so not our flash swf)
            vjs.Player.prototype.supportsFullScreen = function(){
                return this.techGet('supportsFullScreen') || false;
            };

            /**
             * is the player in fullscreen
             * @type {Boolean}
             * @private
             */
            vjs.Player.prototype.isFullscreen_ = false;

            /**
             * Check if the player is in fullscreen mode
             *
             *     // get
             *     var fullscreenOrNot = myPlayer.isFullscreen();
             *
             *     // set
             *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
             *
             * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
             * property and instead document.fullscreenElement is used. But isFullscreen is
             * still a valuable property for internal player workings.
             *
             * @param  {Boolean=} isFS Update the player's fullscreen state
             * @return {Boolean} true if fullscreen, false if not
             * @return {vjs.Player} self, when setting
             */
            vjs.Player.prototype.isFullscreen = function(isFS){
                if (isFS !== undefined) {
                    this.isFullscreen_ = !!isFS;
                    return this;
                }
                return this.isFullscreen_;
            };

            /**
             * Old naming for isFullscreen()
             * @deprecated for lowercase 's' version
             */
            vjs.Player.prototype.isFullScreen = function(isFS){
                vjs.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
                return this.isFullscreen(isFS);
            };

            /**
             * Increase the size of the video to full screen
             *
             *     myPlayer.requestFullscreen();
             *
             * In some browsers, full screen is not supported natively, so it enters
             * "full window mode", where the video fills the browser window.
             * In browsers and devices that support native full screen, sometimes the
             * browser's default controls will be shown, and not the Video.js custom skin.
             * This includes most mobile devices (iOS, Android) and older versions of
             * Safari.
             *
             * @return {vjs.Player} self
             */
            vjs.Player.prototype.requestFullscreen = function(){
                var fsApi = vjs.browser.fullscreenAPI;

                this.isFullscreen(true);

                if (fsApi) {
                    // the browser supports going fullscreen at the element level so we can
                    // take the controls fullscreen as well as the video

                    // Trigger fullscreenchange event after change
                    // We have to specifically add this each time, and remove
                    // when canceling fullscreen. Otherwise if there's multiple
                    // players on a page, they would all be reacting to the same fullscreen
                    // events
                    vjs.on(document, fsApi['fullscreenchange'], vjs.bind(this, function(e){
                        this.isFullscreen(document[fsApi.fullscreenElement]);

                        // If cancelling fullscreen, remove event listener.
                        if (this.isFullscreen() === false) {
                            vjs.off(document, fsApi['fullscreenchange'], arguments.callee);
                        }

                        this.trigger('fullscreenchange');
                    }));

                    this.el_[fsApi.requestFullscreen]();

                } else if (this.tech.supportsFullScreen()) {
                    // we can't take the video.js controls fullscreen but we can go fullscreen
                    // with native controls
                    this.techCall('enterFullScreen');
                } else {
                    // fullscreen isn't supported so we'll just stretch the video element to
                    // fill the viewport
                    this.enterFullWindow();
                    this.trigger('fullscreenchange');
                }

                return this;
            };

            /**
             * Old naming for requestFullscreen
             * @deprecated for lower case 's' version
             */
            vjs.Player.prototype.requestFullScreen = function(){
                vjs.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
                return this.requestFullscreen();
            };


            /**
             * Return the video to its normal size after having been in full screen mode
             *
             *     myPlayer.exitFullscreen();
             *
             * @return {vjs.Player} self
             */
            vjs.Player.prototype.exitFullscreen = function(){
                var fsApi = vjs.browser.fullscreenAPI;
                this.isFullscreen(false);

                // Check for browser element fullscreen support
                if (fsApi) {
                    document[fsApi.exitFullscreen]();
                } else if (this.tech.supportsFullScreen()) {
                    this.techCall('exitFullScreen');
                } else {
                    this.exitFullWindow();
                    this.trigger('fullscreenchange');
                }

                return this;
            };

            /**
             * Old naming for exitFullscreen
             * @deprecated for exitFullscreen
             */
            vjs.Player.prototype.cancelFullScreen = function(){
                vjs.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
                return this.exitFullscreen();
            };

            // When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
            vjs.Player.prototype.enterFullWindow = function(){
                this.isFullWindow = true;

                // Storing original doc overflow value to return to when fullscreen is off
                this.docOrigOverflow = document.documentElement.style.overflow;

                // Add listener for esc key to exit fullscreen
                vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));

                // Hide any scroll bars
                document.documentElement.style.overflow = 'hidden';

                // Apply fullscreen styles
                vjs.addClass(document.body, 'vjs-full-window');

                this.trigger('enterFullWindow');
            };
            vjs.Player.prototype.fullWindowOnEscKey = function(event){
                if (event.keyCode === 27) {
                    if (this.isFullscreen() === true) {
                        this.exitFullscreen();
                    } else {
                        this.exitFullWindow();
                    }
                }
            };

            vjs.Player.prototype.exitFullWindow = function(){
                this.isFullWindow = false;
                vjs.off(document, 'keydown', this.fullWindowOnEscKey);

                // Unhide scroll bars.
                document.documentElement.style.overflow = this.docOrigOverflow;

                // Remove fullscreen styles
                vjs.removeClass(document.body, 'vjs-full-window');

                // Resize the box, controller, and poster to original sizes
                // this.positionAll();
                this.trigger('exitFullWindow');
            };

            vjs.Player.prototype.selectSource = function(sources){
                // Loop through each playback technology in the options order
                for (var i=0,j=this.options_['techOrder'];i<j.length;i++) {
                    var techName = vjs.capitalize(j[i]),
                        tech = window['videojs_apn'][techName];

                    // Check if the current tech is defined before continuing
                    if (!tech) {
                        vjs.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
                        continue;
                    }

                    // Check if the browser supports this technology
                    if (tech.isSupported()) {
                        // Loop through each source object
                        for (var a=0,b=sources;a<b.length;a++) {
                            var source = b[a];

                            // Check if source can be played with this technology
                            if (tech['canPlaySource'](source)) {
                                return { source: source, tech: techName };
                            }
                        }
                    }
                }

                return false;
            };

            /**
             * The source function updates the video source
             *
             * There are three types of variables you can pass as the argument.
             *
             * **URL String**: A URL to the the video file. Use this method if you are sure
             * the current playback technology (HTML5/Flash) can support the source you
             * provide. Currently only MP4 files can be used in both HTML5 and Flash.
             *
             *     myPlayer.src("http://www.example.com/path/to/video.mp4");
             *
             * **Source Object (or element):** A javascript object containing information
             * about the source file. Use this method if you want the player to determine if
             * it can support the file using the type information.
             *
             *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
             *
             * **Array of Source Objects:** To provide multiple versions of the source so
             * that it can be played using HTML5 across browsers you can use an array of
             * source objects. Video.js will detect which version is supported and load that
             * file.
             *
             *     myPlayer.src([
             *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
             *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
             *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
             *     ]);
             *
             * @param  {String|Object|Array=} source The source URL, object, or array of sources
             * @return {String} The current video source when getting
             * @return {String} The player when setting
             */
            vjs.Player.prototype.src = function(source){
                if (source === undefined) {
                    return this.techGet('src');
                }

                // case: Array of source objects to choose from and pick the best to play
                if (vjs.obj.isArray(source)) {
                    this.sourceList_(source);

                    // case: URL String (http://myvideo...)
                } else if (typeof source === 'string') {
                    // create a source object from the string
                    this.src({ src: source });

                    // case: Source object { src: '', type: '' ... }
                } else if (source instanceof Object) {
                    // check if the source has a type and the loaded tech cannot play the source
                    // if there's no type we'll just try the current tech
                    if (source.type && !window['videojs_apn'][this.techName]['canPlaySource'](source)) {
                        // create a source list with the current source and send through
                        // the tech loop to check for a compatible technology
                        this.sourceList_([source]);
                    } else {
                        this.cache_.src = source.src;
                        this.currentType_ = source.type || '';

                        // wait until the tech is ready to set the source
                        this.ready(function(){

                            // The setSource tech method was added with source handlers
                            // so older techs won't support it
                            // We need to check the direct prototype for the case where subclasses
                            // of the tech do not support source handlers
                            if (window['videojs_apn'][this.techName].prototype.hasOwnProperty('setSource')) {
                                this.techCall('setSource', source);
                            } else {
                                this.techCall('src', source.src);
                            }

                            if (this.options_['preload'] == 'auto') {
                                this.load();
                            }

                            if (this.options_['autoplay']) {
                                this.play();
                            }
                        });
                    }
                }

                return this;
            };

            /**
             * Handle an array of source objects
             * @param  {[type]} sources Array of source objects
             * @private
             */
            vjs.Player.prototype.sourceList_ = function(sources){
                var sourceTech = this.selectSource(sources);

                if (sourceTech) {
                    if (sourceTech.tech === this.techName) {
                        // if this technology is already loaded, set the source
                        this.src(sourceTech.source);
                    } else {
                        // load this technology with the chosen source
                        this.loadTech(sourceTech.tech, sourceTech.source);
                    }
                } else {
                    // We need to wrap this in a timeout to give folks a chance to add error event handlers
                    this.setTimeout( function() {
                        this.error({ code: 4, message: this.localize(this.options()['notSupportedMessage']) });
                    }, 0);

                    // we could not find an appropriate tech, but let's still notify the delegate that this is it
                    // this needs a better comment about why this is needed
                    this.triggerReady();
                }
            };

            /**
             * Begin loading the src data.
             * @return {vjs.Player} Returns the player
             */
            vjs.Player.prototype.load = function(){
                this.techCall('load');
                return this;
            };

            /**
             * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
             * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
             * @return {String} The current source
             */
            vjs.Player.prototype.currentSrc = function(){
                return this.techGet('currentSrc') || this.cache_.src || '';
            };

            /**
             * Get the current source type e.g. video/mp4
             * This can allow you rebuild the current source object so that you could load the same
             * source and tech later
             * @return {String} The source MIME type
             */
            vjs.Player.prototype.currentType = function(){
                return this.currentType_ || '';
            };

            /**
             * Get or set the preload attribute.
             * @return {String} The preload attribute value when getting
             * @return {vjs.Player} Returns the player when setting
             */
            vjs.Player.prototype.preload = function(value){
                if (value !== undefined) {
                    this.techCall('setPreload', value);
                    this.options_['preload'] = value;
                    return this;
                }
                return this.techGet('preload');
            };

            /**
             * Get or set the autoplay attribute.
             * @return {String} The autoplay attribute value when getting
             * @return {vjs.Player} Returns the player when setting
             */
            vjs.Player.prototype.autoplay = function(value){
                if (value !== undefined) {
                    this.techCall('setAutoplay', value);
                    this.options_['autoplay'] = value;
                    return this;
                }
                return this.techGet('autoplay', value);
            };

            /**
             * Get or set the loop attribute on the video element.
             * @return {String} The loop attribute value when getting
             * @return {vjs.Player} Returns the player when setting
             */
            vjs.Player.prototype.loop = function(value){
                if (value !== undefined) {
                    this.techCall('setLoop', value);
                    this.options_['loop'] = value;
                    return this;
                }
                return this.techGet('loop');
            };

            /**
             * the url of the poster image source
             * @type {String}
             * @private
             */
            vjs.Player.prototype.poster_;

            /**
             * get or set the poster image source url
             *
             * ##### EXAMPLE:
             *
             *     // getting
             *     var currentPoster = myPlayer.poster();
             *
             *     // setting
             *     myPlayer.poster('http://example.com/myImage.jpg');
             *
             * @param  {String=} [src] Poster image source URL
             * @return {String} poster URL when getting
             * @return {vjs.Player} self when setting
             */
            vjs.Player.prototype.poster = function(src){
                if (src === undefined) {
                    return this.poster_;
                }

                // The correct way to remove a poster is to set as an empty string
                // other falsey values will throw errors
                if (!src) {
                    src = '';
                }

                // update the internal poster variable
                this.poster_ = src;

                // update the tech's poster
                this.techCall('setPoster', src);

                // alert components that the poster has been set
                this.trigger('posterchange');

                return this;
            };

            /**
             * Whether or not the controls are showing
             * @type {Boolean}
             * @private
             */
            vjs.Player.prototype.controls_;

            /**
             * Get or set whether or not the controls are showing.
             * @param  {Boolean} controls Set controls to showing or not
             * @return {Boolean}    Controls are showing
             */
            vjs.Player.prototype.controls = function(bool){
                if (bool !== undefined) {
                    bool = !!bool; // force boolean
                    // Don't trigger a change event unless it actually changed
                    if (this.controls_ !== bool) {
                        this.controls_ = bool;
                        if (bool) {
                            this.removeClass('vjs-controls-disabled');
                            this.addClass('vjs-controls-enabled');
                            this.trigger('controlsenabled');
                        } else {
                            this.removeClass('vjs-controls-enabled');
                            this.addClass('vjs-controls-disabled');
                            this.trigger('controlsdisabled');
                        }
                    }
                    return this;
                }
                return this.controls_;
            };

            vjs.Player.prototype.usingNativeControls_;

            /**
             * Toggle native controls on/off. Native controls are the controls built into
             * devices (e.g. default iPhone controls), Flash, or other techs
             * (e.g. Vimeo Controls)
             *
             * **This should only be set by the current tech, because only the tech knows
             * if it can support native controls**
             *
             * @param  {Boolean} bool    True signals that native controls are on
             * @return {vjs.Player}      Returns the player
             * @private
             */
            vjs.Player.prototype.usingNativeControls = function(bool){
                if (bool !== undefined) {
                    bool = !!bool; // force boolean
                    // Don't trigger a change event unless it actually changed
                    if (this.usingNativeControls_ !== bool) {
                        this.usingNativeControls_ = bool;
                        if (bool) {
                            this.addClass('vjs-using-native-controls');

                            /**
                             * player is using the native device controls
                             *
                             * @event usingnativecontrols
                             * @memberof vjs.Player
                             * @instance
                             * @private
                             */
                            this.trigger('usingnativecontrols');
                        } else {
                            this.removeClass('vjs-using-native-controls');

                            /**
                             * player is using the custom HTML controls
                             *
                             * @event usingcustomcontrols
                             * @memberof vjs.Player
                             * @instance
                             * @private
                             */
                            this.trigger('usingcustomcontrols');
                        }
                    }
                    return this;
                }
                return this.usingNativeControls_;
            };

            /**
             * Store the current media error
             * @type {Object}
             * @private
             */
            vjs.Player.prototype.error_ = null;

            /**
             * Set or get the current MediaError
             * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
             * @return {vjs.MediaError|null}     when getting
             * @return {vjs.Player}              when setting
             */
            vjs.Player.prototype.error = function(err){
                if (err === undefined) {
                    return this.error_;
                }

                // restoring to default
                if (err === null) {
                    this.error_ = err;
                    this.removeClass('vjs-error');
                    return this;
                }

                // error instance
                if (err instanceof vjs.MediaError) {
                    this.error_ = err;
                } else {
                    this.error_ = new vjs.MediaError(err);
                }

                // fire an error event on the player
                this.trigger('error');

                // add the vjs-error classname to the player
                this.addClass('vjs-error');

                // log the name of the error type and any message
                // ie8 just logs "[object object]" if you just log the error object
                vjs.log.error('(CODE:'+this.error_.code+' '+vjs.MediaError.errorTypes[this.error_.code]+')', this.error_.message, this.error_);

                return this;
            };

            /**
             * Returns whether or not the player is in the "ended" state.
             * @return {Boolean} True if the player is in the ended state, false if not.
             */
            vjs.Player.prototype.ended = function(){ return this.techGet('ended'); };

            /**
             * Returns whether or not the player is in the "seeking" state.
             * @return {Boolean} True if the player is in the seeking state, false if not.
             */
            vjs.Player.prototype.seeking = function(){ return this.techGet('seeking'); };

            /**
             * Returns the TimeRanges of the media that are currently available
             * for seeking to.
             * @return {TimeRanges} the seekable intervals of the media timeline
             */
            vjs.Player.prototype.seekable = function(){ return this.techGet('seekable'); };

            // When the player is first initialized, trigger activity so components
            // like the control bar show themselves if needed
            vjs.Player.prototype.userActivity_ = true;
            vjs.Player.prototype.reportUserActivity = function(event){
                this.userActivity_ = true;
            };

            vjs.Player.prototype.userActive_ = true;
            vjs.Player.prototype.userActive = function(bool){
                if (bool !== undefined) {
                    bool = !!bool;
                    if (bool !== this.userActive_) {
                        this.userActive_ = bool;
                        if (bool) {
                            // If the user was inactive and is now active we want to reset the
                            // inactivity timer
                            this.userActivity_ = true;
                            this.removeClass('vjs-user-inactive');
                            this.addClass('vjs-user-active');
                            this.trigger('useractive');
                        } else {
                            // We're switching the state to inactive manually, so erase any other
                            // activity
                            this.userActivity_ = false;

                            // Chrome/Safari/IE have bugs where when you change the cursor it can
                            // trigger a mousemove event. This causes an issue when you're hiding
                            // the cursor when the user is inactive, and a mousemove signals user
                            // activity. Making it impossible to go into inactive mode. Specifically
                            // this happens in fullscreen when we really need to hide the cursor.
                            //
                            // When this gets resolved in ALL browsers it can be removed
                            // https://code.google.com/p/chromium/issues/detail?id=103041
                            if(this.tech) {
                                this.tech.one('mousemove', function(e){
                                    e.stopPropagation();
                                    e.preventDefault();
                                });
                            }

                            this.removeClass('vjs-user-active');
                            this.addClass('vjs-user-inactive');
                            this.trigger('userinactive');
                        }
                    }
                    return this;
                }
                return this.userActive_;
            };

            vjs.Player.prototype.listenForUserActivity = function(){
                var onActivity, onMouseMove, onMouseDown, mouseInProgress, onMouseUp,
                    activityCheck, inactivityTimeout, lastMoveX, lastMoveY;

                onActivity = vjs.bind(this, this.reportUserActivity);

                onMouseMove = function(e) {
                    // #1068 - Prevent mousemove spamming
                    // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
                    if(e.screenX != lastMoveX || e.screenY != lastMoveY) {
                        lastMoveX = e.screenX;
                        lastMoveY = e.screenY;
                        onActivity();
                    }
                };

                onMouseDown = function() {
                    onActivity();
                    // For as long as the they are touching the device or have their mouse down,
                    // we consider them active even if they're not moving their finger or mouse.
                    // So we want to continue to update that they are active
                    this.clearInterval(mouseInProgress);
                    // Setting userActivity=true now and setting the interval to the same time
                    // as the activityCheck interval (250) should ensure we never miss the
                    // next activityCheck
                    mouseInProgress = this.setInterval(onActivity, 250);
                };

                onMouseUp = function(event) {
                    onActivity();
                    // Stop the interval that maintains activity if the mouse/touch is down
                    this.clearInterval(mouseInProgress);
                };

                // Any mouse movement will be considered user activity
                this.on('mousedown', onMouseDown);
                this.on('mousemove', onMouseMove);
                this.on('mouseup', onMouseUp);

                // Listen for keyboard navigation
                // Shouldn't need to use inProgress interval because of key repeat
                this.on('keydown', onActivity);
                this.on('keyup', onActivity);

                // Run an interval every 250 milliseconds instead of stuffing everything into
                // the mousemove/touchmove function itself, to prevent performance degradation.
                // `this.reportUserActivity` simply sets this.userActivity_ to true, which
                // then gets picked up by this loop
                // http://ejohn.org/blog/learning-from-twitter/
                activityCheck = this.setInterval(function() {
                    // Check to see if mouse/touch activity has happened
                    if (this.userActivity_) {
                        // Reset the activity tracker
                        this.userActivity_ = false;

                        // If the user state was inactive, set the state to active
                        this.userActive(true);

                        // Clear any existing inactivity timeout to start the timer over
                        this.clearTimeout(inactivityTimeout);

                        var timeout = this.options()['inactivityTimeout'];
                        if (timeout > 0) {
                            // In <timeout> milliseconds, if no more activity has occurred the
                            // user will be considered inactive
                            inactivityTimeout = this.setTimeout(function () {
                                // Protect against the case where the inactivityTimeout can trigger just
                                // before the next user activity is picked up by the activityCheck loop
                                // causing a flicker
                                if (!this.userActivity_) {
                                    this.userActive(false);
                                }
                            }, timeout);
                        }
                    }
                }, 250);
            };

            /**
             * Gets or sets the current playback rate.
             * @param  {Boolean} rate   New playback rate to set.
             * @return {Number}         Returns the new playback rate when setting
             * @return {Number}         Returns the current playback rate when getting
             */
            vjs.Player.prototype.playbackRate = function(rate) {
                if (rate !== undefined) {
                    this.techCall('setPlaybackRate', rate);
                    return this;
                }

                if (this.tech && this.tech['featuresPlaybackRate']) {
                    return this.techGet('playbackRate');
                } else {
                    return 1.0;
                }

            };

            /**
             * Store the current audio state
             * @type {Boolean}
             * @private
             */
            vjs.Player.prototype.isAudio_ = false;

            /**
             * Gets or sets the audio flag
             *
             * @param  {Boolean} bool    True signals that this is an audio player.
             * @return {Boolean}         Returns true if player is audio, false if not when getting
             * @return {vjs.Player}      Returns the player if setting
             * @private
             */
            vjs.Player.prototype.isAudio = function(bool) {
                if (bool !== undefined) {
                    this.isAudio_ = !!bool;
                    return this;
                }

                return this.isAudio_;
            };

            /**
             * Returns the current state of network activity for the element, from
             * the codes in the list below.
             * - NETWORK_EMPTY (numeric value 0)
             *   The element has not yet been initialised. All attributes are in
             *   their initial states.
             * - NETWORK_IDLE (numeric value 1)
             *   The element's resource selection algorithm is active and has
             *   selected a resource, but it is not actually using the network at
             *   this time.
             * - NETWORK_LOADING (numeric value 2)
             *   The user agent is actively trying to download data.
             * - NETWORK_NO_SOURCE (numeric value 3)
             *   The element's resource selection algorithm is active, but it has
             *   not yet found a resource to use.
             * @return {Number} the current network activity state
             * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
             */
            vjs.Player.prototype.networkState = function(){
                return this.techGet('networkState');
            };

            /**
             * Returns a value that expresses the current state of the element
             * with respect to rendering the current playback position, from the
             * codes in the list below.
             * - HAVE_NOTHING (numeric value 0)
             *   No information regarding the media resource is available.
             * - HAVE_METADATA (numeric value 1)
             *   Enough of the resource has been obtained that the duration of the
             *   resource is available.
             * - HAVE_CURRENT_DATA (numeric value 2)
             *   Data for the immediate current playback position is available.
             * - HAVE_FUTURE_DATA (numeric value 3)
             *   Data for the immediate current playback position is available, as
             *   well as enough data for the user agent to advance the current
             *   playback position in the direction of playback.
             * - HAVE_ENOUGH_DATA (numeric value 4)
             *   The user agent estimates that enough data is available for
             *   playback to proceed uninterrupted.
             * @return {Number} the current playback rendering state
             * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
             */
            vjs.Player.prototype.readyState = function(){
                return this.techGet('readyState');
            };

            /**
             * Text tracks are tracks of timed text events.
             * Captions - text displayed over the video for the hearing impaired
             * Subtitles - text displayed over the video for those who don't understand language in the video
             * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
             * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
             */

            /**
             * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
             * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
             * @return {Array}           Array of track objects
             */
            vjs.Player.prototype.textTracks = function(){
                // cannot use techGet directly because it checks to see whether the tech is ready.
                // Flash is unlikely to be ready in time but textTracks should still work.
                return this.tech && this.tech['textTracks']();
            };

            vjs.Player.prototype.remoteTextTracks = function() {
                return this.tech && this.tech['remoteTextTracks']();
            };

            /**
             * Add a text track
             * In addition to the W3C settings we allow adding additional info through options.
             * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
             * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
             * @param {String=} label       Optional label
             * @param {String=} language    Optional language
             */
            vjs.Player.prototype.addTextTrack = function(kind, label, language) {
                return this.tech && this.tech['addTextTrack'](kind, label, language);
            };

            vjs.Player.prototype.addRemoteTextTrack = function(options) {
                return this.tech && this.tech['addRemoteTextTrack'](options);
            };

            vjs.Player.prototype.removeRemoteTextTrack = function(track) {
                this.tech && this.tech['removeRemoteTextTrack'](track);
            };

            // Methods to add support for
            // initialTime: function(){ return this.techCall('initialTime'); },
            // startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
            // played: function(){ return this.techCall('played'); },
            // seekable: function(){ return this.techCall('seekable'); },
            // videoTracks: function(){ return this.techCall('videoTracks'); },
            // audioTracks: function(){ return this.techCall('audioTracks'); },
            // videoWidth: function(){ return this.techCall('videoWidth'); },
            // videoHeight: function(){ return this.techCall('videoHeight'); },
            // defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
            // mediaGroup: function(){ return this.techCall('mediaGroup'); },
            // controller: function(){ return this.techCall('controller'); },
            // defaultMuted: function(){ return this.techCall('defaultMuted'); }

            // TODO
            // currentSrcList: the array of sources including other formats and bitrates
            // playList: array of source lists in order of playback

            /**
             * Container of main controls
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             * @extends vjs.Component
             */
            vjs.ControlBar = vjs.Component.extend();

            vjs.ControlBar.prototype.options_ = {
                loadEvent: 'play',
                children: {
                    'playToggle': {},
                    'currentTimeDisplay': {},
                    'timeDivider': {},
                    'durationDisplay': {},
                    'remainingTimeDisplay': {},
                    // 'liveDisplay': {},
                    'progressControl': {},
                    'fullscreenToggle': {},
                    'volumeControl': {},
                    'muteToggle': {},
                    // 'volumeMenuButton': {},
                    'playbackRateMenuButton': {}
                    // 'subtitlesButton': {},
                    // 'captionsButton': {},
                    // 'chaptersButton': {}
                }
            };

            vjs.ControlBar.prototype.createEl = function(){
                return vjs.createEl('div', {
                    className: 'vjs-control-bar'
                });
            };

            /**
             * Displays the live indicator
             * TODO - Future make it click to snap to live
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.LiveDisplay = vjs.Component.extend({
                init: function(player, options){
                    vjs.Component.call(this, player, options);
                }
            });

            vjs.LiveDisplay.prototype.createEl = function(){
                var el = vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-live-controls vjs-control'
                });

                this.contentEl_ = vjs.createEl('div', {
                    className: 'vjs-live-display',
                    innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
                    'aria-live': 'off'
                });

                el.appendChild(this.contentEl_);

                return el;
            };

            /**
             * Button to toggle between play and pause
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             */
            vjs.PlayToggle = vjs.Button.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Button.call(this, player, options);

                    this.on(player, 'play', this.onPlay);
                    this.on(player, 'pause', this.onPause);
                }
            });

            vjs.PlayToggle.prototype.buttonText = 'Play';

            vjs.PlayToggle.prototype.buildCSSClass = function(){
                return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);
            };

            // OnClick - Toggle between play and pause
            vjs.PlayToggle.prototype.onClick = function(){
                if (this.player_.paused()) {
                    this.player_.play();
                } else {
                    this.player_.pause();
                }
            };

            // OnPlay - Add the vjs-playing class to the element so it can change appearance
            vjs.PlayToggle.prototype.onPlay = function(){
                this.removeClass('vjs-paused');
                this.addClass('vjs-playing');
                this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
            };

            // OnPause - Add the vjs-paused class to the element so it can change appearance
            vjs.PlayToggle.prototype.onPause = function(){
                this.removeClass('vjs-playing');
                this.addClass('vjs-paused');
                this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
            };

            /**
             * Displays the current time
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.CurrentTimeDisplay = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    this.on(player, 'timeupdate', this.updateContent);
                }
            });

            vjs.CurrentTimeDisplay.prototype.createEl = function(){
                var el = vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-current-time vjs-time-controls vjs-control'
                });

                this.contentEl_ = vjs.createEl('div', {
                    className: 'vjs-current-time-display',
                    innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00', // label the current time for screen reader users
                    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
                });

                el.appendChild(this.contentEl_);
                return el;
            };

            vjs.CurrentTimeDisplay.prototype.updateContent = function(){
                // Allows for smooth scrubbing, when player can't keep up.
                var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
                this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Current Time') + '</span> ' + vjs.formatTime(time, this.player_.duration());
            };

            /**
             * Displays the duration
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.DurationDisplay = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    // this might need to be changed to 'durationchange' instead of 'timeupdate' eventually,
                    // however the durationchange event fires before this.player_.duration() is set,
                    // so the value cannot be written out using this method.
                    // Once the order of durationchange and this.player_.duration() being set is figured out,
                    // this can be updated.
                    this.on(player, 'timeupdate', this.updateContent);
                    this.on(player, 'loadedmetadata', this.updateContent);
                }
            });

            vjs.DurationDisplay.prototype.createEl = function(){
                var el = vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-duration vjs-time-controls vjs-control'
                });

                this.contentEl_ = vjs.createEl('div', {
                    className: 'vjs-duration-display',
                    innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + '0:00', // label the duration time for screen reader users
                    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
                });

                el.appendChild(this.contentEl_);
                return el;
            };

            vjs.DurationDisplay.prototype.updateContent = function(){
                var duration = this.player_.duration();
                if (duration) {
                    this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + vjs.formatTime(duration); // label the duration time for screen reader users
                }
            };

            /**
             * The separator between the current time and duration
             *
             * Can be hidden if it's not needed in the design.
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.TimeDivider = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);
                }
            });

            vjs.TimeDivider.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-time-divider',
                    innerHTML: '<div><span>/</span></div>'
                });
            };

            /**
             * Displays the time left in the video
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.RemainingTimeDisplay = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    this.on(player, 'timeupdate', this.updateContent);
                }
            });

            vjs.RemainingTimeDisplay.prototype.createEl = function(){
                var el = vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-remaining-time vjs-time-controls vjs-control'
                });

                this.contentEl_ = vjs.createEl('div', {
                    className: 'vjs-remaining-time-display',
                    innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-0:00', // label the remaining time for screen reader users
                    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
                });

                el.appendChild(this.contentEl_);
                return el;
            };

            vjs.RemainingTimeDisplay.prototype.updateContent = function(){
                if (this.player_.duration()) {
                    this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-'+ vjs.formatTime(this.player_.remainingTime());
                }

                // Allows for smooth scrubbing, when player can't keep up.
                // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
                // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
            };

            /**
             * Toggle fullscreen video
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @extends vjs.Button
             */
            vjs.FullscreenToggle = vjs.Button.extend({
                /**
                 * @constructor
                 * @memberof vjs.FullscreenToggle
                 * @instance
                 */
                init: function(player, options){
                    vjs.Button.call(this, player, options);
                }
            });

            vjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';

            vjs.FullscreenToggle.prototype.buildCSSClass = function(){
                return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);
            };

            vjs.FullscreenToggle.prototype.onClick = function(){
                if (!this.player_.isFullscreen()) {
                    this.player_.requestFullscreen();
                    this.controlText_.innerHTML = this.localize('Non-Fullscreen');
                } else {
                    this.player_.exitFullscreen();
                    this.controlText_.innerHTML = this.localize('Fullscreen');
                }
            };

            /**
             * The Progress Control component contains the seek bar, load progress,
             * and play progress
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.ProgressControl = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);
                }
            });

            vjs.ProgressControl.prototype.options_ = {
                children: {
                    'seekBar': {}
                }
            };

            vjs.ProgressControl.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-progress-control vjs-control'
                });
            };

            /**
             * Seek Bar and holder for the progress bars
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.SeekBar = vjs.Slider.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Slider.call(this, player, options);
                    this.on(player, 'timeupdate', this.updateARIAAttributes);
                    player.ready(vjs.bind(this, this.updateARIAAttributes));
                }
            });

            vjs.SeekBar.prototype.options_ = {
                children: {
                    'loadProgressBar': {},
                    'playProgressBar': {},
                    'seekHandle': {}
                },
                'barName': 'playProgressBar',
                'handleName': 'seekHandle'
            };

            vjs.SeekBar.prototype.playerEvent = 'timeupdate';

            vjs.SeekBar.prototype.createEl = function(){
                return vjs.Slider.prototype.createEl.call(this, 'div', {
                    className: 'vjs-progress-holder',
                    'aria-label': 'video progress bar'
                });
            };

            vjs.SeekBar.prototype.updateARIAAttributes = function(){
                // Allows for smooth scrubbing, when player can't keep up.
                var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
                this.el_.setAttribute('aria-valuenow',vjs.round(this.getPercent()*100, 2)); // machine readable value of progress bar (percentage complete)
                this.el_.setAttribute('aria-valuetext',vjs.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
            };

            vjs.SeekBar.prototype.getPercent = function(){
                return this.player_.currentTime() / this.player_.duration();
            };




            //remove all Seek Bar interactivity VID-2782
            /*
             ///----- start seek bar interactivity section -----
             vjs.SeekBar.prototype.onMouseDown = function(event){
             vjs.Slider.prototype.onMouseDown.call(this, event);

             this.player_.scrubbing = true;
             this.player_.addClass('vjs-scrubbing');

             this.videoWasPlaying = !this.player_.paused();
             this.player_.pause();
             };

             vjs.SeekBar.prototype.onMouseMove = function(event){
             var newTime = this.calculateDistance(event) * this.player_.duration();

             // Don't let video end while scrubbing.
             if (newTime == this.player_.duration()) { newTime = newTime - 0.1; }

             // Set new time (tell player to seek to new time)
             this.player_.currentTime(newTime);
             };

             vjs.SeekBar.prototype.onMouseUp = function(event){
             vjs.Slider.prototype.onMouseUp.call(this, event);

             this.player_.scrubbing = false;
             this.player_.removeClass('vjs-scrubbing');
             if (this.videoWasPlaying) {
             this.player_.play();
             }
             };

             vjs.SeekBar.prototype.stepForward = function(){
             this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
             };

             vjs.SeekBar.prototype.stepBack = function(){
             this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users

             };
             ///----- end seek bar interactivity section -----
             */




            /**
             * Shows load progress
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.LoadProgressBar = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);
                    this.on(player, 'progress', this.update);
                }
            });

            vjs.LoadProgressBar.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-load-progress',
                    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
                });
            };

            vjs.LoadProgressBar.prototype.update = function(){
                var i, start, end, part,
                    buffered = this.player_.buffered(),
                    duration = this.player_.duration(),
                    bufferedEnd = this.player_.bufferedEnd(),
                    children = this.el_.children,
                    // get the percent width of a time compared to the total end
                    percentify = function (time, end){
                        var percent = (time / end) || 0; // no NaN
                        return (percent * 100) + '%';
                    };

                // update the width of the progress bar
                this.el_.style.width = percentify(bufferedEnd, duration);

                // add child elements to represent the individual buffered time ranges
                for (i = 0; i < buffered.length; i++) {
                    start = buffered.start(i),
                        end = buffered.end(i),
                        part = children[i];

                    if (!part) {
                        part = this.el_.appendChild(vjs.createEl());
                    }

                    // set the percent based on the width of the progress bar (bufferedEnd)
                    part.style.left = percentify(start, bufferedEnd);
                    part.style.width = percentify(end - start, bufferedEnd);
                }

                // remove unused buffered range elements
                for (i = children.length; i > buffered.length; i--) {
                    this.el_.removeChild(children[i-1]);
                }
            };

            /**
             * Shows play progress
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.PlayProgressBar = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);
                }
            });

            vjs.PlayProgressBar.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-play-progress',
                    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
                });
            };

            /**
             * The Seek Handle shows the current position of the playhead during playback,
             * and can be dragged to adjust the playhead.
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.SeekHandle = vjs.SliderHandle.extend({
                init: function(player, options) {
                    vjs.SliderHandle.call(this, player, options);
                    this.on(player, 'timeupdate', this.updateContent);
                }
            });

            /**
             * The default value for the handle content, which may be read by screen readers
             *
             * @type {String}
             * @private
             */
            vjs.SeekHandle.prototype.defaultValue = '00:00';

            /** @inheritDoc */
            vjs.SeekHandle.prototype.createEl = function() {
                return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
                    className: 'vjs-seek-handle',
                    'aria-live': 'off'
                });
            };

            vjs.SeekHandle.prototype.updateContent = function() {
                var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
                this.el_.innerHTML = '<span class="vjs-control-text">' + vjs.formatTime(time, this.player_.duration()) + '</span>';
            };

            /**
             * The component for controlling the volume level
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.VolumeControl = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    // hide volume controls when they're not supported by the current tech
                    if (player.tech && player.tech['featuresVolumeControl'] === false) {
                        this.addClass('vjs-hidden');
                    }
                    this.on(player, 'loadstart', function(){
                        if (player.tech['featuresVolumeControl'] === false) {
                            this.addClass('vjs-hidden');
                        } else {
                            this.removeClass('vjs-hidden');
                        }
                    });
                }
            });

            vjs.VolumeControl.prototype.options_ = {
                children: {
                    'volumeBar': {}
                }
            };

            vjs.VolumeControl.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-volume-control vjs-control'
                });
            };

            /**
             * The bar that contains the volume level and can be clicked on to adjust the level
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.VolumeBar = vjs.Slider.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Slider.call(this, player, options);
                    this.on(player, 'volumechange', this.updateARIAAttributes);
                    player.ready(vjs.bind(this, this.updateARIAAttributes));
                }
            });

            vjs.VolumeBar.prototype.updateARIAAttributes = function(){
                // Current value of volume bar as a percentage
                this.el_.setAttribute('aria-valuenow',vjs.round(this.player_.volume()*100, 2));
                this.el_.setAttribute('aria-valuetext',vjs.round(this.player_.volume()*100, 2)+'%');
            };

            vjs.VolumeBar.prototype.options_ = {
                children: {
                    'volumeLevel': {},
                    'volumeHandle': {}
                },
                'barName': 'volumeLevel',
                'handleName': 'volumeHandle'
            };

            vjs.VolumeBar.prototype.playerEvent = 'volumechange';

            vjs.VolumeBar.prototype.createEl = function(){
                return vjs.Slider.prototype.createEl.call(this, 'div', {
                    className: 'vjs-volume-bar',
                    'aria-label': 'volume level'
                });
            };

            vjs.VolumeBar.prototype.onMouseMove = function(event) {
                if (this.player_.muted()) {
                    //this.player_.muted(false);
                }

                //console.log("================ id : " + global_options.iframeVideoWrapperId);
                //TODO minthe added to fix VID-209
                var targetDocument = document.getElementById(global_options.iframeVideoWrapperId).contentWindow.document;
                var targetElement = targetDocument.elementFromPoint(event.clientX, event.clientY);
                if (targetElement && targetElement.tagName!="VIDEO" && targetElement.className.indexOf("vjs") >= 0) {
                    this.player_.volume(this.calculateDistance(event));
                }

            };

            vjs.VolumeBar.prototype.getPercent = function(){
                if (this.player_.muted()) {
                    return 0;
                } else {
                    return this.player_.volume();
                }
            };

            vjs.VolumeBar.prototype.stepForward = function(){
                this.player_.volume(this.player_.volume() + 0.1);
            };

            vjs.VolumeBar.prototype.stepBack = function(){
                this.player_.volume(this.player_.volume() - 0.1);
            };

            /**
             * Shows volume level
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.VolumeLevel = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);
                }
            });

            vjs.VolumeLevel.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-volume-level',
                    innerHTML: '<span class="vjs-control-text"></span>'
                });
            };

            /**
             * The volume handle can be dragged to adjust the volume level
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.VolumeHandle = vjs.SliderHandle.extend();

            vjs.VolumeHandle.prototype.defaultValue = '00:00';

            /** @inheritDoc */
            vjs.VolumeHandle.prototype.createEl = function(){
                return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
                    className: 'vjs-volume-handle'
                });
            };

            /**
             * A button component for muting the audio
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.MuteToggle = vjs.Button.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Button.call(this, player, options);

                    this.on(player, 'volumechange', this.update);
                    var showMuteForIOS10 = player.getMuteSettingsForIOS10();
                    // hide mute toggle if the current tech doesn't support volume control
                    if (player.tech && player.tech['featuresVolumeControl'] === false && !showMuteForIOS10) {
                        this.addClass('vjs-hidden');
                    }

                    this.on(player, 'loadstart', function(){
                        if (player.tech['featuresVolumeControl'] === false && !showMuteForIOS10) {
                            this.addClass('vjs-hidden');
                        } else {
                            this.removeClass('vjs-hidden');
                        }
                    });
                }
            });

            vjs.MuteToggle.prototype.createEl = function(){
                return vjs.Button.prototype.createEl.call(this, 'div', {
                    className: 'vjs-mute-control vjs-control',
                    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
                });
            };

            vjs.MuteToggle.prototype.onClick = function(){
                this.player_.muted( this.player_.muted() ? false : true );
            };

            vjs.MuteToggle.prototype.update = function(){
                var vol = this.player_.volume(),
                    level = 3;

                if (vol === 0 || this.player_.muted()) {
                    level = 0;
                } else if (vol < 0.33) {
                    level = 1;
                } else if (vol < 0.67) {
                    level = 2;
                }

                // Don't rewrite the button text if the actual text doesn't change.
                // This causes unnecessary and confusing information for screen reader users.
                // This check is needed because this function gets called every time the volume level is changed.
                if(this.player_.muted()){
                    if(this.el_.children[0].children[0].innerHTML!=this.localize('Unmute')){
                        this.el_.children[0].children[0].innerHTML = this.localize('Unmute'); // change the button text to "Unmute"
                    }
                } else {
                    if(this.el_.children[0].children[0].innerHTML!=this.localize('Mute')){
                        this.el_.children[0].children[0].innerHTML = this.localize('Mute'); // change the button text to "Mute"
                    }
                }

                /* TODO improve muted icon classes */
                for (var i = 0; i < 4; i++) {
                    vjs.removeClass(this.el_, 'vjs-vol-'+i);
                }
                vjs.addClass(this.el_, 'vjs-vol-'+level);
            };

            /**
             * Menu button with a popup for showing the volume slider.
             * @constructor
             */
            vjs.VolumeMenuButton = vjs.MenuButton.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.MenuButton.call(this, player, options);

                    // Same listeners as MuteToggle
                    this.on(player, 'volumechange', this.volumeUpdate);

                    // hide mute toggle if the current tech doesn't support volume control
                    if (player.tech && player.tech['featuresVolumeControl'] === false) {
                        this.addClass('vjs-hidden');
                    }

                    this.on(player, 'loadstart', function(){
                        if (player.tech['featuresVolumeControl'] === false) {
                            this.addClass('vjs-hidden');
                        } else {
                            this.removeClass('vjs-hidden');
                        }
                    });
                    this.addClass('vjs-menu-button');
                }
            });

            vjs.VolumeMenuButton.prototype.createMenu = function(){
                var menu = new vjs.Menu(this.player_, {
                    contentElType: 'div'
                });
                var vc = new vjs.VolumeBar(this.player_, this.options_['volumeBar']);
                vc.on('focus', function() {
                    menu.lockShowing();
                });
                vc.on('blur', function() {
                    menu.unlockShowing();
                });
                menu.addChild(vc);
                return menu;
            };

            vjs.VolumeMenuButton.prototype.onClick = function(){
                vjs.MuteToggle.prototype.onClick.call(this);
                vjs.MenuButton.prototype.onClick.call(this);
            };

            vjs.VolumeMenuButton.prototype.createEl = function(){
                return vjs.Button.prototype.createEl.call(this, 'div', {
                    className: 'vjs-volume-menu-button vjs-menu-button vjs-control',
                    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
                });
            };
            vjs.VolumeMenuButton.prototype.volumeUpdate = vjs.MuteToggle.prototype.update;

            /**
             * The component for controlling the playback rate
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.PlaybackRateMenuButton = vjs.MenuButton.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.MenuButton.call(this, player, options);

                    this.updateVisibility();
                    this.updateLabel();

                    this.on(player, 'loadstart', this.updateVisibility);
                    this.on(player, 'ratechange', this.updateLabel);
                }
            });

            vjs.PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
            vjs.PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';

            vjs.PlaybackRateMenuButton.prototype.createEl = function(){
                var el = vjs.MenuButton.prototype.createEl.call(this);

                this.labelEl_ = vjs.createEl('div', {
                    className: 'vjs-playback-rate-value',
                    innerHTML: 1.0
                });

                el.appendChild(this.labelEl_);

                return el;
            };

            // Menu creation
            vjs.PlaybackRateMenuButton.prototype.createMenu = function(){
                var menu = new vjs.Menu(this.player());
                var rates = this.player().options()['playbackRates'];

                if (rates) {
                    for (var i = rates.length - 1; i >= 0; i--) {
                        menu.addChild(
                            new vjs.PlaybackRateMenuItem(this.player(), { 'rate': rates[i] + 'x'})
                        );
                    }
                }

                return menu;
            };

            vjs.PlaybackRateMenuButton.prototype.updateARIAAttributes = function(){
                // Current playback rate
                this.el().setAttribute('aria-valuenow', this.player().playbackRate());
            };

            vjs.PlaybackRateMenuButton.prototype.onClick = function(){
                // select next rate option
                var currentRate = this.player().playbackRate();
                var rates = this.player().options()['playbackRates'];
                // this will select first one if the last one currently selected
                var newRate = rates[0];
                for (var i = 0; i <rates.length ; i++) {
                    if (rates[i] > currentRate) {
                        newRate = rates[i];
                        break;
                    }
                }
                this.player().playbackRate(newRate);
            };

            vjs.PlaybackRateMenuButton.prototype.playbackRateSupported = function(){
                return this.player().tech
                    && this.player().tech['featuresPlaybackRate']
                    && this.player().options()['playbackRates']
                    && this.player().options()['playbackRates'].length > 0
                    ;
            };

            /**
             * Hide playback rate controls when they're no playback rate options to select
             */
            vjs.PlaybackRateMenuButton.prototype.updateVisibility = function(){
                if (this.playbackRateSupported()) {
                    this.removeClass('vjs-hidden');
                } else {
                    this.addClass('vjs-hidden');
                }
            };

            /**
             * Update button label when rate changed
             */
            vjs.PlaybackRateMenuButton.prototype.updateLabel = function(){
                if (this.playbackRateSupported()) {
                    this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
                }
            };

            /**
             * The specific menu item type for selecting a playback rate
             *
             * @constructor
             */
            vjs.PlaybackRateMenuItem = vjs.MenuItem.extend({
                contentElType: 'button',
                /** @constructor */
                init: function(player, options){
                    var label = this.label = options['rate'];
                    var rate = this.rate = parseFloat(label, 10);

                    // Modify options for parent MenuItem class's init.
                    options['label'] = label;
                    options['selected'] = rate === 1;
                    vjs.MenuItem.call(this, player, options);

                    this.on(player, 'ratechange', this.update);
                }
            });

            vjs.PlaybackRateMenuItem.prototype.onClick = function(){
                vjs.MenuItem.prototype.onClick.call(this);
                this.player().playbackRate(this.rate);
            };

            vjs.PlaybackRateMenuItem.prototype.update = function(){
                this.selected(this.player().playbackRate() == this.rate);
            };

            /* Poster Image
             ================================================================================ */
            /**
             * The component that handles showing the poster image.
             *
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.PosterImage = vjs.Button.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Button.call(this, player, options);

                    this.update();
                    player.on('posterchange', vjs.bind(this, this.update));
                }
            });

            /**
             * Clean up the poster image
             */
            vjs.PosterImage.prototype.dispose = function(){
                this.player().off('posterchange', this.update);
                vjs.Button.prototype.dispose.call(this);
            };

            /**
             * Create the poster image element
             * @return {Element}
             */
            vjs.PosterImage.prototype.createEl = function(){
                var el = vjs.createEl('div', {
                    className: 'vjs-poster',

                    // Don't want poster to be tabbable.
                    tabIndex: -1
                });

                // To ensure the poster image resizes while maintaining its original aspect
                // ratio, use a div with `background-size` when available. For browsers that
                // do not support `background-size` (e.g. IE8), fall back on using a regular
                // img element.
                if (!vjs.BACKGROUND_SIZE_SUPPORTED) {
                    this.fallbackImg_ = vjs.createEl('img');
                    el.appendChild(this.fallbackImg_);
                }

                return el;
            };

            /**
             * Event handler for updates to the player's poster source
             */
            vjs.PosterImage.prototype.update = function(){
                var url = this.player().poster();

                this.setSrc(url);

                // If there's no poster source we should display:none on this component
                // so it's not still clickable or right-clickable
                if (url) {
                    this.show();
                } else {
                    this.hide();
                }
            };

            /**
             * Set the poster source depending on the display method
             */
            vjs.PosterImage.prototype.setSrc = function(url){
                var backgroundImage;

                if (this.fallbackImg_) {
                    this.fallbackImg_.src = url;
                } else {
                    backgroundImage = '';
                    // Any falsey values should stay as an empty string, otherwise
                    // this will throw an extra error
                    if (url) {
                        backgroundImage = 'url("' + url + '")';
                    }

                    this.el_.style.backgroundImage = backgroundImage;
                }
            };

            /**
             * Event handler for clicks on the poster image
             */
            vjs.PosterImage.prototype.onClick = function(){
                // We don't want a click to trigger playback when controls are disabled
                // but CSS should be hiding the poster to prevent that from happening
                this.player_.play();
            };

            /* Loading Spinner
             ================================================================================ */
            /**
             * Loading spinner for waiting events
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             */
            vjs.LoadingSpinner = vjs.Component.extend({
                /** @constructor */
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    // MOVING DISPLAY HANDLING TO CSS

                    // player.on('canplay', vjs.bind(this, this.hide));
                    // player.on('canplaythrough', vjs.bind(this, this.hide));
                    // player.on('playing', vjs.bind(this, this.hide));
                    // player.on('seeking', vjs.bind(this, this.show));

                    // in some browsers seeking does not trigger the 'playing' event,
                    // so we also need to trap 'seeked' if we are going to set a
                    // 'seeking' event
                    // player.on('seeked', vjs.bind(this, this.hide));

                    // player.on('ended', vjs.bind(this, this.hide));

                    // Not showing spinner on stalled any more. Browsers may stall and then not trigger any events that would remove the spinner.
                    // Checked in Chrome 16 and Safari 5.1.2. http://help.videojs.com/discussions/problems/883-why-is-the-download-progress-showing
                    // player.on('stalled', vjs.bind(this, this.show));

                    // player.on('waiting', vjs.bind(this, this.show));
                }
            });

            vjs.LoadingSpinner.prototype.createEl = function(){
                return vjs.Component.prototype.createEl.call(this, 'div', {
                    className: 'vjs-loading-spinner'
                });
            };

            /* Big Play Button
             ================================================================================ */
            /**
             * Initial play button. Shows before the video has played. The hiding of the
             * big play button is done via CSS and player states.
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @class
             * @constructor
             */
            vjs.BigPlayButton = vjs.Button.extend();

            vjs.BigPlayButton.prototype.createEl = function(){
                return vjs.Button.prototype.createEl.call(this, 'div', {
                    className: 'vjs-big-play-button',
                    innerHTML: '<span aria-hidden="true"></span>',
                    'aria-label': 'play video'
                });
            };

            vjs.BigPlayButton.prototype.onClick = function(){
                this.player_.play();
            };

            /**
             * Display that an error has occurred making the video unplayable
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @constructor
             */
            vjs.ErrorDisplay = vjs.Component.extend({
                init: function(player, options){
                    vjs.Component.call(this, player, options);

                    this.update();
                    this.on(player, 'error', this.update);
                }
            });

            vjs.ErrorDisplay.prototype.createEl = function(){
                var el = vjs.Component.prototype.createEl.call(this, 'div', {
                });//VID-1444

                this.contentEl_ = vjs.createEl('div');
                el.appendChild(this.contentEl_);

                return el;
            };

            vjs.ErrorDisplay.prototype.update = function(){
                if (this.player().error()) {
                    this.contentEl_.innerHTML = this.localize(this.player().error().message);
                }
            };

            (function() {
                var createTrackHelper;
                /**
                 * @fileoverview Media Technology Controller - Base class for media playback
                 * technology controllers like Flash and HTML5
                 */

                /**
                 * Base class for media (HTML5 Video, Flash) controllers
                 * @param {vjs.Player|Object} player  Central player instance
                 * @param {Object=} options Options object
                 * @constructor
                 */
                vjs.MediaTechController = vjs.Component.extend({
                    /** @constructor */
                    init: function(player, options, ready){
                        options = options || {};
                        // we don't want the tech to report user activity automatically.
                        // This is done manually in addControlsListeners
                        options.reportTouchActivity = false;
                        vjs.Component.call(this, player, options, ready);

                        // Manually track progress in cases where the browser/flash player doesn't report it.
                        if (!this['featuresProgressEvents']) {
                            this.manualProgressOn();
                        }

                        // Manually track timeupdates in cases where the browser/flash player doesn't report it.
                        if (!this['featuresTimeupdateEvents']) {
                            this.manualTimeUpdatesOn();
                        }

                        this.initControlsListeners();

                        //if (!this['featuresNativeTextTracks']) {
                        //  this.emulateTextTracks();
                        //}

                        this.initTextTrackListeners();
                    }
                });

                /**
                 * Set up click and touch listeners for the playback element
                 * On desktops, a click on the video itself will toggle playback,
                 * on a mobile device a click on the video toggles controls.
                 * (toggling controls is done by toggling the user state between active and
                 * inactive)
                 *
                 * A tap can signal that a user has become active, or has become inactive
                 * e.g. a quick tap on an iPhone movie should reveal the controls. Another
                 * quick tap should hide them again (signaling the user is in an inactive
                 * viewing state)
                 *
                 * In addition to this, we still want the user to be considered inactive after
                 * a few seconds of inactivity.
                 *
                 * Note: the only part of iOS interaction we can't mimic with this setup
                 * is a touch and hold on the video element counting as activity in order to
                 * keep the controls showing, but that shouldn't be an issue. A touch and hold on
                 * any controls will still keep the user active
                 */
                vjs.MediaTechController.prototype.initControlsListeners = function(){
                    var player, activateControls;

                    player = this.player();

                    activateControls = function(){
                        if (player.controls() && !player.usingNativeControls()) {
                            this.addControlsListeners();
                        }
                    };

                    // Set up event listeners once the tech is ready and has an element to apply
                    // listeners to
                    this.ready(activateControls);
                    this.on(player, 'controlsenabled', activateControls);
                    this.on(player, 'controlsdisabled', this.removeControlsListeners);

                    // if we're loading the playback object after it has started loading or playing the
                    // video (often with autoplay on) then the loadstart event has already fired and we
                    // need to fire it manually because many things rely on it.
                    // Long term we might consider how we would do this for other events like 'canplay'
                    // that may also have fired.
                    this.ready(function(){
                        if (this.networkState && this.networkState() > 0) {
                            this.player().trigger('loadstart');
                        }
                    });
                };

                vjs.MediaTechController.prototype.addControlsListeners = function(){
                    var userWasActive;

                    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
                    // trigger mousedown/up.
                    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
                    // Any touch events are set to block the mousedown event from happening
                    this.on('mousedown', this.onClick);

                    // If the controls were hidden we don't want that to change without a tap event
                    // so we'll check if the controls were already showing before reporting user
                    // activity
                    this.on('touchstart', function(event) {
                        userWasActive = this.player_.userActive();
                    });

                    this.on('touchmove', function(event) {
                        if (userWasActive){
                            this.player().reportUserActivity();
                        }
                    });

                    this.on('touchend', function(event) {
                        // Stop the mouse events from also happening
                        event.preventDefault();
                    });

                    // Turn on component tap events
                    this.emitTapEvents();

                    // The tap listener needs to come after the touchend listener because the tap
                    // listener cancels out any reportedUserActivity when setting userActive(false)
                    this.on('tap', this.onTap);
                };

                /**
                 * Remove the listeners used for click and tap controls. This is needed for
                 * toggling to controls disabled, where a tap/touch should do nothing.
                 */
                vjs.MediaTechController.prototype.removeControlsListeners = function(){
                    // We don't want to just use `this.off()` because there might be other needed
                    // listeners added by techs that extend this.
                    this.off('tap');
                    this.off('touchstart');
                    this.off('touchmove');
                    this.off('touchleave');
                    this.off('touchcancel');
                    this.off('touchend');
                    this.off('click');
                    this.off('mousedown');
                };

                /**
                 * Handle a click on the media element. By default will play/pause the media.
                 */
                vjs.MediaTechController.prototype.onClick = function(event){
                    // We're using mousedown to detect clicks thanks to Flash, but mousedown
                    // will also be triggered with right-clicks, so we need to prevent that
                    if (event.button !== 0) return;

                    // When controls are disabled a click should not toggle playback because
                    // the click is considered a control
                    if (this.player().controls()) {
                        if (this.player().paused()) {
                            this.player().play();
                        } else {
                            this.player().pause();
                        }
                    }
                };

                /**
                 * Handle a tap on the media element. By default it will toggle the user
                 * activity state, which hides and shows the controls.
                 */
                vjs.MediaTechController.prototype.onTap = function(){
                    this.player().userActive(!this.player().userActive());
                };

                /* Fallbacks for unsupported event types
                 ================================================================================ */
                // Manually trigger progress events based on changes to the buffered amount
                // Many flash players and older HTML5 browsers don't send progress or progress-like events
                vjs.MediaTechController.prototype.manualProgressOn = function(){
                    this.manualProgress = true;

                    // Trigger progress watching when a source begins loading
                    this.trackProgress();
                };

                vjs.MediaTechController.prototype.manualProgressOff = function(){
                    this.manualProgress = false;
                    this.stopTrackingProgress();
                };

                vjs.MediaTechController.prototype.trackProgress = function(){
                    this.progressInterval = this.setInterval(function(){
                        // Don't trigger unless buffered amount is greater than last time

                        var bufferedPercent = this.player().bufferedPercent();

                        if (this.bufferedPercent_ != bufferedPercent) {
                            this.player().trigger('progress');
                        }

                        this.bufferedPercent_ = bufferedPercent;

                        if (bufferedPercent === 1) {
                            this.stopTrackingProgress();
                        }
                    }, 500);
                };
                vjs.MediaTechController.prototype.stopTrackingProgress = function(){ this.clearInterval(this.progressInterval); };

                /*! Time Tracking -------------------------------------------------------------- */
                vjs.MediaTechController.prototype.manualTimeUpdatesOn = function(){
                    var player = this.player_;

                    this.manualTimeUpdates = true;

                    this.on(player, 'play', this.trackCurrentTime);
                    this.on(player, 'pause', this.stopTrackingCurrentTime);
                    // timeupdate is also called by .currentTime whenever current time is set

                    // Watch for native timeupdate event
                    this.one('timeupdate', function(){
                        // Update known progress support for this playback technology
                        this['featuresTimeupdateEvents'] = true;
                        // Turn off manual progress tracking
                        this.manualTimeUpdatesOff();
                    });
                };

                vjs.MediaTechController.prototype.manualTimeUpdatesOff = function(){
                    var player = this.player_;

                    this.manualTimeUpdates = false;
                    this.stopTrackingCurrentTime();
                    this.off(player, 'play', this.trackCurrentTime);
                    this.off(player, 'pause', this.stopTrackingCurrentTime);
                };

                vjs.MediaTechController.prototype.trackCurrentTime = function(){
                    if (this.currentTimeInterval) { this.stopTrackingCurrentTime(); }
                    this.currentTimeInterval = this.setInterval(function(){
                        this.player().trigger('timeupdate');
                    }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
                };

                // Turn off play progress tracking (when paused or dragging)
                vjs.MediaTechController.prototype.stopTrackingCurrentTime = function(){
                    this.clearInterval(this.currentTimeInterval);

                    // #1002 - if the video ends right before the next timeupdate would happen,
                    // the progress bar won't make it all the way to the end
                    this.player().trigger('timeupdate');
                };

                vjs.MediaTechController.prototype.dispose = function() {
                    // Turn off any manual progress or timeupdate tracking
                    if (this.manualProgress) { this.manualProgressOff(); }

                    if (this.manualTimeUpdates) { this.manualTimeUpdatesOff(); }

                    vjs.Component.prototype.dispose.call(this);
                };

                vjs.MediaTechController.prototype.setCurrentTime = function() {
                    // improve the accuracy of manual timeupdates
                    if (this.manualTimeUpdates) { this.player().trigger('timeupdate'); }
                };

                // TODO: Consider looking at moving this into the text track display directly
                // https://github.com/videojs/video.js/issues/1863
                vjs.MediaTechController.prototype.initTextTrackListeners = function() {
                    var player = this.player_,
                        tracks,
                        textTrackListChanges = function() {
                            var textTrackDisplay = player.getChild('textTrackDisplay'),
                                controlBar;

                            if (textTrackDisplay) {
                                textTrackDisplay.updateDisplay();
                            }
                        };

                    tracks = this.textTracks();

                    if (!tracks) {
                        return;
                    }

                    tracks.addEventListener('removetrack', textTrackListChanges);
                    tracks.addEventListener('addtrack', textTrackListChanges);

                    this.on('dispose', vjs.bind(this, function() {
                        tracks.removeEventListener('removetrack', textTrackListChanges);
                        tracks.removeEventListener('addtrack', textTrackListChanges);
                    }));
                };

                vjs.MediaTechController.prototype.emulateTextTracks = function() {
                    var player = this.player_,
                        textTracksChanges,
                        tracks,
                        script;

                    if (!window['WebVTT']) {
                        //script = document.createElement('script');
                        //script.src = player.options()['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
                        //player.el().appendChild(script);
                        //window['WebVTT'] = true;
                    }

                    tracks = this.textTracks();
                    if (!tracks) {
                        return;
                    }

                    textTracksChanges = function() {
                        var i, track, textTrackDisplay;

                        textTrackDisplay = player.getChild('textTrackDisplay'),

                            textTrackDisplay.updateDisplay();

                        for (i = 0; i < this.length; i++) {
                            track = this[i];
                            track.removeEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
                            if (track.mode === 'showing') {
                                track.addEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
                            }
                        }
                    };

                    tracks.addEventListener('change', textTracksChanges);

                    this.on('dispose', vjs.bind(this, function() {
                        tracks.removeEventListener('change', textTracksChanges);
                    }));
                };

                /**
                 * Provide default methods for text tracks.
                 *
                 * Html5 tech overrides these.
                 */

                /**
                 * List of associated text tracks
                 * @type {Array}
                 * @private
                 */
                vjs.MediaTechController.prototype.textTracks_;

                vjs.MediaTechController.prototype.textTracks = function() {
                    this.player_.textTracks_ = this.player_.textTracks_ || new vjs.TextTrackList();
                    return this.player_.textTracks_;
                };

                vjs.MediaTechController.prototype.remoteTextTracks = function() {
                    this.player_.remoteTextTracks_ = this.player_.remoteTextTracks_ || new vjs.TextTrackList();
                    return this.player_.remoteTextTracks_;
                };

                createTrackHelper = function(self, kind, label, language, options) {
                    var tracks = self.textTracks(),
                        track;

                    options = options || {};

                    options['kind'] = kind;
                    if (label) {
                        options['label'] = label;
                    }
                    if (language) {
                        options['language'] = language;
                    }
                    options['player'] = self.player_;

                    track = new vjs.TextTrack(options);
                    tracks.addTrack_(track);

                    return track;
                };

                vjs.MediaTechController.prototype.addTextTrack = function(kind, label, language) {
                    if (!kind) {
                        throw new Error('TextTrack kind is required but was not provided');
                    }

                    return createTrackHelper(this, kind, label, language);
                };

                vjs.MediaTechController.prototype.addRemoteTextTrack = function(options) {
                    var track = createTrackHelper(this, options['kind'], options['label'], options['language'], options);
                    this.remoteTextTracks().addTrack_(track);
                    return {
                        track: track
                    };
                };

                vjs.MediaTechController.prototype.removeRemoteTextTrack = function(track) {
                    this.textTracks().removeTrack_(track);
                    this.remoteTextTracks().removeTrack_(track);
                };

                /**
                 * Provide a default setPoster method for techs
                 *
                 * Poster support for techs should be optional, so we don't want techs to
                 * break if they don't have a way to set a poster.
                 */
                vjs.MediaTechController.prototype.setPoster = function(){};

                vjs.MediaTechController.prototype['featuresVolumeControl'] = true;

                // Resizing plugins using request fullscreen reloads the plugin
                vjs.MediaTechController.prototype['featuresFullscreenResize'] = false;
                vjs.MediaTechController.prototype['featuresPlaybackRate'] = false;

                // Optional events that we can manually mimic with timers
                // currently not triggered by video-js-swf
                vjs.MediaTechController.prototype['featuresProgressEvents'] = false;
                vjs.MediaTechController.prototype['featuresTimeupdateEvents'] = false;

                vjs.MediaTechController.prototype['featuresNativeTextTracks'] = false;

                /**
                 * A functional mixin for techs that want to use the Source Handler pattern.
                 *
                 * ##### EXAMPLE:
                 *
                 *   videojs.MediaTechController.withSourceHandlers.call(MyTech);
                 *
                 */
                vjs.MediaTechController.withSourceHandlers = function(Tech){
                    /**
                     * Register a source handler
                     * Source handlers are scripts for handling specific formats.
                     * The source handler pattern is used for adaptive formats (HLS, DASH) that
                     * manually load video data and feed it into a Source Buffer (Media Source Extensions)
                     * @param  {Function} handler  The source handler
                     * @param  {Boolean}  first    Register it before any existing handlers
                     */
                    Tech.registerSourceHandler = function(handler, index){
                        var handlers = Tech.sourceHandlers;

                        if (!handlers) {
                            handlers = Tech.sourceHandlers = [];
                        }

                        if (index === undefined) {
                            // add to the end of the list
                            index = handlers.length;
                        }

                        handlers.splice(index, 0, handler);
                    };

                    /**
                     * Return the first source handler that supports the source
                     * TODO: Answer question: should 'probably' be prioritized over 'maybe'
                     * @param  {Object} source The source object
                     * @returns {Object}       The first source handler that supports the source
                     * @returns {null}         Null if no source handler is found
                     */
                    Tech.selectSourceHandler = function(source){
                        var handlers = Tech.sourceHandlers || [],
                            can;

                        for (var i = 0; i < handlers.length; i++) {
                            can = handlers[i].canHandleSource(source);

                            if (can) {
                                return handlers[i];
                            }
                        }

                        return null;
                    };

                    /**
                     * Check if the tech can support the given source
                     * @param  {Object} srcObj  The source object
                     * @return {String}         'probably', 'maybe', or '' (empty string)
                     */
                    Tech.canPlaySource = function(srcObj){
                        var sh = Tech.selectSourceHandler(srcObj);

                        if (sh) {
                            return sh.canHandleSource(srcObj);
                        }

                        return '';
                    };

                    /**
                     * Create a function for setting the source using a source object
                     * and source handlers.
                     * Should never be called unless a source handler was found.
                     * @param {Object} source  A source object with src and type keys
                     * @return {vjs.MediaTechController} self
                     */
                    Tech.prototype.setSource = function(source){
                        var sh = Tech.selectSourceHandler(source);

                        if (!sh) {
                            // Fall back to a native source hander when unsupported sources are
                            // deliberately set
                            if (Tech.nativeSourceHandler) {
                                sh = Tech.nativeSourceHandler;
                            } else {
                                vjs.log.error('No source hander found for the current source.');
                            }
                        }

                        // Dispose any existing source handler
                        this.disposeSourceHandler();
                        this.off('dispose', this.disposeSourceHandler);

                        this.currentSource_ = source;
                        this.sourceHandler_ = sh.handleSource(source, this);
                        this.on('dispose', this.disposeSourceHandler);

                        return this;
                    };

                    /**
                     * Clean up any existing source handler
                     */
                    Tech.prototype.disposeSourceHandler = function(){
                        if (this.sourceHandler_ && this.sourceHandler_.dispose) {
                            this.sourceHandler_.dispose();
                        }
                    };

                };

                vjs.media = {};

            })();

            /**
             * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
             */

            /**
             * HTML5 Media Controller - Wrapper for HTML5 Media API
             * @param {vjs.Player|Object} player
             * @param {Object=} options
             * @param {Function=} ready
             * @constructor
             */
            vjs.Html5 = vjs.MediaTechController.extend({
                /** @constructor */
                init: function(player, options, ready){
                    var  nodes, nodesLength, i, node, nodeName, removeNodes;

                    if (options['nativeCaptions'] === false || options['nativeTextTracks'] === false) {
                        this['featuresNativeTextTracks'] = false;
                    }

                    vjs.MediaTechController.call(this, player, options, ready);

                    this.setupTriggers();

                    var source = options['source'];

                    // Set the source if one is provided
                    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
                    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
                    // anyway so the error gets fired.
                    if (source && (this.el_.currentSrc !== source.src || (player.tag && player.tag.initNetworkState_ === 3))) {
                        this.setSource(source);
                    }

                    if (this.el_.hasChildNodes()) {

                        nodes = this.el_.childNodes;
                        nodesLength = nodes.length;
                        removeNodes = [];

                        while (nodesLength--) {
                            node = nodes[nodesLength];
                            nodeName = node.nodeName.toLowerCase();
                            if (nodeName === 'track') {
                                if (!this['featuresNativeTextTracks']) {
                                    // Empty video tag tracks so the built-in player doesn't use them also.
                                    // This may not be fast enough to stop HTML5 browsers from reading the tags
                                    // so we'll need to turn off any default tracks if we're manually doing
                                    // captions and subtitles. videoElement.textTracks
                                    removeNodes.push(node);
                                } else {
                                    this.remoteTextTracks().addTrack_(node['track']);
                                }
                            }
                        }

                        for (i=0; i<removeNodes.length; i++) {
                            this.el_.removeChild(removeNodes[i]);
                        }
                    }

                    if (this['featuresNativeTextTracks']) {
                        this.on('loadstart', vjs.bind(this, this.hideCaptions));
                    }

                    // Determine if native controls should be used
                    // Our goal should be to get the custom controls on mobile solid everywhere
                    // so we can remove this all together. Right now this will block custom
                    // controls on touch enabled laptops like the Chrome Pixel
                    if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] === true) {
                        this.useNativeControls();
                    }

                    // Chrome and Safari both have issues with autoplay.
                    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
                    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
                    // This fixes both issues. Need to wait for API, so it updates displays correctly
                    player.ready(function(){
                        if (this.src() && this.tag && this.options_['autoplay'] && this.paused()) {
                            delete this.tag['poster']; // Chrome Fix. Fixed in Chrome v16.
                            this.play();
                        }
                    });

                    this.triggerReady();
                }
            });

            vjs.Html5.prototype.dispose = function(){
                vjs.Html5.disposeMediaElement(this.el_);
                vjs.MediaTechController.prototype.dispose.call(this);
            };

            vjs.Html5.prototype.createEl = function(){
                var player = this.player_,
                    track,
                    trackEl,
                    i,
                    // If possible, reuse original tag for HTML5 playback technology element
                    el = player.tag,
                    attributes,
                    newEl,
                    clone;

                // Check if this browser supports moving the element into the box.
                // On the iPhone video will break if you move the element,
                // So we have to create a brand new element.
                if (!el || this['movingMediaElementInDOM'] === false) {

                    // If the original tag is still there, clone and remove it.
                    if (el) {
                        clone = el.cloneNode(false);
                        vjs.Html5.disposeMediaElement(el);
                        el = clone;
                        player.tag = null;
                    } else {
                        el = vjs.createEl('video');

                        // determine if native controls should be used
                        attributes = videojs.util.mergeOptions({}, player.tagAttributes);
                        if (!vjs.TOUCH_ENABLED || player.options()['nativeControlsForTouch'] !== true) {
                            delete attributes.controls;
                        }

                        vjs.setElementAttributes(el,
                            vjs.obj.merge(attributes, {
                                id:player.id() + '_html5_api',
                                'class':'vjs-tech'
                            })
                        );
                    }
                    // associate the player with the new tag
                    el['player'] = player;

                    if (player.options_.tracks) {
                        for (i = 0; i < player.options_.tracks.length; i++) {
                            track = player.options_.tracks[i];
                            trackEl = document.createElement('track');
                            trackEl.kind = track.kind;
                            trackEl.label = track.label;
                            trackEl.srclang = track.srclang;
                            trackEl.src = track.src;
                            if ('default' in track) {
                                trackEl.setAttribute('default', 'default');
                            }
                            el.appendChild(trackEl);
                        }
                    }

                    vjs.insertFirst(el, player.el());
                }

                // Update specific tag settings, in case they were overridden
                var settingsAttrs = ['autoplay','preload','loop','muted'];
                for (i = settingsAttrs.length - 1; i >= 0; i--) {
                    var attr = settingsAttrs[i];
                    var overwriteAttrs = {};
                    if (typeof player.options_[attr] !== 'undefined') {
                        overwriteAttrs[attr] = player.options_[attr];
                    }
                    vjs.setElementAttributes(el, overwriteAttrs);
                }

                //changes for VID-2669 - inline setting for Safari and Mobile SDKS's WebView as following this announcement - https://webkit.org/blog/6784/new-video-policies-for-ios/
                if (player.options_.enableNativeInline) {
                    el.setAttribute("playsinline","");//setting W3C standard inline video attribute on Safari and Mobile SDK's WebView
                    el.setAttribute("webkit-playsinline","");//setting Apple's inline video on Mobile SDK's WebView to have backward compatibility on older version of iOS(~9)
                }

                return el;
                // jenniisawesome = true;
            };


            vjs.Html5.prototype.hideCaptions = function() {
                var tracks = this.el_.querySelectorAll('track'),
                    track,
                    i = tracks.length,
                    kinds = {
                        'captions': 1,
                        'subtitles': 1
                    };

                while (i--) {
                    track = tracks[i].track;
                    if ((track && track['kind'] in kinds) &&
                        (!tracks[i]['default'])) {
                        track.mode = 'disabled';
                    }
                }
            };

            // Make video events trigger player events
            // May seem verbose here, but makes other APIs possible.
            // Triggers removed using this.off when disposed
            vjs.Html5.prototype.setupTriggers = function(){
                for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {
                    this.on(vjs.Html5.Events[i], this.eventHandler);
                }
            };

            vjs.Html5.prototype.eventHandler = function(evt){
                // In the case of an error on the video element, set the error prop
                // on the player and let the player handle triggering the event. On
                // some platforms, error events fire that do not cause the error
                // property on the video element to be set. See #1465 for an example.
                if (evt.type == 'error' && this.error()) {
                    this.player().error(this.error().code);

                    // in some cases we pass the event directly to the player
                } else {
                    // No need for media events to bubble up.
                    evt.bubbles = false;

                    this.player().trigger(evt);
                }
            };

            vjs.Html5.prototype.useNativeControls = function(){
                var tech, player, controlsOn, controlsOff, cleanUp;

                tech = this;
                player = this.player();

                // If the player controls are enabled turn on the native controls
                tech.setControls(player.controls());

                // Update the native controls when player controls state is updated
                controlsOn = function(){
                    tech.setControls(true);
                };
                controlsOff = function(){
                    tech.setControls(false);
                };
                player.on('controlsenabled', controlsOn);
                player.on('controlsdisabled', controlsOff);

                // Clean up when not using native controls anymore
                cleanUp = function(){
                    player.off('controlsenabled', controlsOn);
                    player.off('controlsdisabled', controlsOff);
                };
                tech.on('dispose', cleanUp);
                player.on('usingcustomcontrols', cleanUp);

                // Update the state of the player to using native controls
                player.usingNativeControls(true);
            };


            vjs.Html5.prototype.play = function(){ this.el_.play(); };
            vjs.Html5.prototype.pause = function(){ this.el_.pause(); };
            vjs.Html5.prototype.paused = function(){ return this.el_.paused; };

            // vjs.Html5.prototype.currentTime = function(){ return this.el_.currentTime; };
            // vjs.Html5.prototype.setCurrentTime = function(seconds){
            //   try {
            //     this.el_.currentTime = seconds;
            //   } catch(e) {
            //     vjs.log(e, 'Video is not ready. (Video.js)');
            //     // this.warning(VideoJS.warnings.videoNotReady);
            //   }
            // };

            vjs.Html5.prototype.currentTime = function(){
                return this.el_.currentTime || this.el_.currentTimeForOutstream || 0;//ks : comment out due to Safari, FireFox, doesn't set currentTime of the video element if the video element doesn't have propoer source, so if JSVPAID creative getnerates their own video element, this current Time will not be set on Desktop Safari, Firefox
            };

            vjs.Html5.prototype.setCurrentTime = function(seconds){
                try {
                    this.el_.currentTimeForOutstream = seconds;
                    this.el_.currentTime = seconds;
                } catch(e) {
                    vjs.log(e, 'Video is not ready. (Video.js)');
                }
            };



            vjs.Html5.prototype.duration = function(){ return this.el_.duration || 0; };
            vjs.Html5.prototype.buffered = function(){ return this.el_.buffered; };

            vjs.Html5.prototype.volume = function(){ return this.el_.volume; };
            vjs.Html5.prototype.setVolume = function(percentAsDecimal){ this.el_.volume = percentAsDecimal; };
            vjs.Html5.prototype.muted = function(){ return this.el_.muted; };
            vjs.Html5.prototype.setMuted = function(muted){ this.el_.muted = muted; };

            vjs.Html5.prototype.width = function(){ return this.el_.offsetWidth; };
            vjs.Html5.prototype.height = function(){ return this.el_.offsetHeight; };

            vjs.Html5.prototype.supportsFullScreen = function(){
                if (typeof this.el_.webkitEnterFullScreen == 'function') {

                    // Seems to be broken in Chromium/Chrome && Safari in Leopard
                    if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {
                        return true;
                    }
                }
                return false;
            };

            vjs.Html5.prototype.enterFullScreen = function(){
                var video = this.el_;

                if ('webkitDisplayingFullscreen' in video) {
                    this.one('webkitbeginfullscreen', function() {
                        this.player_.isFullscreen(true);

                        this.one('webkitendfullscreen', function() {
                            this.player_.isFullscreen(false);
                            this.player_.trigger('fullscreenchange');
                        });

                        this.player_.trigger('fullscreenchange');
                    });
                }

                if (video.paused && video.networkState <= video.HAVE_METADATA) {
                    // attempt to prime the video element for programmatic access
                    // this isn't necessary on the desktop but shouldn't hurt
                    this.el_.play();

                    // playing and pausing synchronously during the transition to fullscreen
                    // can get iOS ~6.1 devices into a play/pause loop
                    this.setTimeout(function(){
                        video.pause();
                        video.webkitEnterFullScreen();
                    }, 0);
                } else {
                    video.webkitEnterFullScreen();
                }
            };

            vjs.Html5.prototype.exitFullScreen = function(){
                this.el_.webkitExitFullScreen();
            };

            // Checks to see if the element's reported URI (either from `el_.src`
            // or `el_.currentSrc`) is a blob-uri and, if so, returns the uri that
            // was passed into the source-handler when it was first invoked instead
            // of the blob-uri
            vjs.Html5.prototype.returnOriginalIfBlobURI_ = function (elementURI, originalURI) {
                var blobURIRegExp = /^blob\:/i;

                // If originalURI is undefined then we are probably in a non-source-handler-enabled
                // tech that inherits from the Html5 tech so we should just return the elementURI
                // regardless of it's blobby-ness
                if (originalURI && elementURI && blobURIRegExp.test(elementURI)) {
                    return originalURI;
                }
                return elementURI;
            };

            vjs.Html5.prototype.src = function(src) {
                var elementSrc = this.el_.src;

                if (src === undefined) {
                    return this.returnOriginalIfBlobURI_(elementSrc, this.source_);
                } else {
                    // Setting src through `src` instead of `setSrc` will be deprecated
                    this.setSrc(src);
                }
            };

            vjs.Html5.prototype.setSrc = function(src) {
                this.el_.src = src;
            };

            vjs.Html5.prototype.load = function(){ this.el_.load(); };
            vjs.Html5.prototype.currentSrc = function(){
                var elementSrc = this.el_.currentSrc;

                if (!this.currentSource_) {
                    return elementSrc;
                }

                return this.returnOriginalIfBlobURI_(elementSrc, this.currentSource_.src);
            };

            vjs.Html5.prototype.poster = function(){ return this.el_.poster; };
            vjs.Html5.prototype.setPoster = function(val){ this.el_.poster = val; };

            vjs.Html5.prototype.preload = function(){ return this.el_.preload; };
            vjs.Html5.prototype.setPreload = function(val){ this.el_.preload = val; };

            vjs.Html5.prototype.autoplay = function(){ return this.el_.autoplay; };
            vjs.Html5.prototype.setAutoplay = function(val){ this.el_.autoplay = val; };

            vjs.Html5.prototype.controls = function(){ return this.el_.controls; };
            vjs.Html5.prototype.setControls = function(val){ this.el_.controls = !!val; };

            vjs.Html5.prototype.loop = function(){ return this.el_.loop; };
            vjs.Html5.prototype.setLoop = function(val){ this.el_.loop = val; };

            vjs.Html5.prototype.error = function(){ return this.el_.error; };
            vjs.Html5.prototype.seeking = function(){ return this.el_.seeking; };
            vjs.Html5.prototype.seekable = function(){ return this.el_.seekable; };
            vjs.Html5.prototype.ended = function(){ return this.el_.ended; };
            vjs.Html5.prototype.defaultMuted = function(){ return this.el_.defaultMuted; };

            vjs.Html5.prototype.playbackRate = function(){ return this.el_.playbackRate; };
            vjs.Html5.prototype.setPlaybackRate = function(val){ this.el_.playbackRate = val; };

            vjs.Html5.prototype.networkState = function(){ return this.el_.networkState; };
            vjs.Html5.prototype.readyState = function(){ return this.el_.readyState; };

            vjs.Html5.prototype.textTracks = function() {
                if (!this['featuresNativeTextTracks']) {
                    return vjs.MediaTechController.prototype.textTracks.call(this);
                }

                return this.el_.textTracks;
            };
            vjs.Html5.prototype.addTextTrack = function(kind, label, language) {
                if (!this['featuresNativeTextTracks']) {
                    return vjs.MediaTechController.prototype.addTextTrack.call(this, kind, label, language);
                }

                return this.el_.addTextTrack(kind, label, language);
            };

            vjs.Html5.prototype.addRemoteTextTrack = function(options) {
                if (!this['featuresNativeTextTracks']) {
                    return vjs.MediaTechController.prototype.addRemoteTextTrack.call(this, options);
                }

                var track = document.createElement('track');
                options = options || {};

                if (options['kind']) {
                    track['kind'] = options['kind'];
                }
                if (options['label']) {
                    track['label'] = options['label'];
                }
                if (options['language'] || options['srclang']) {
                    track['srclang'] = options['language'] || options['srclang'];
                }
                if (options['default']) {
                    track['default'] = options['default'];
                }
                if (options['id']) {
                    track['id'] = options['id'];
                }
                if (options['src']) {
                    track['src'] = options['src'];
                }

                this.el().appendChild(track);

                if (track.track['kind'] === 'metadata') {
                    track['track']['mode'] = 'hidden';
                } else {
                    track['track']['mode'] = 'disabled';
                }

                track['onload'] = function() {
                    var tt = track['track'];
                    if (track.readyState >= 2) {
                        if (tt['kind'] === 'metadata' && tt['mode'] !== 'hidden') {
                            tt['mode'] = 'hidden';
                        } else if (tt['kind'] !== 'metadata' && tt['mode'] !== 'disabled') {
                            tt['mode'] = 'disabled';
                        }
                        track['onload'] = null;
                    }
                };

                this.remoteTextTracks().addTrack_(track.track);

                return track;
            };

            vjs.Html5.prototype.removeRemoteTextTrack = function(track) {
                if (!this['featuresNativeTextTracks']) {
                    return vjs.MediaTechController.prototype.removeRemoteTextTrack.call(this, track);
                }

                var tracks, i;

                this.remoteTextTracks().removeTrack_(track);

                tracks = this.el()['querySelectorAll']('track');

                for (i = 0; i < tracks.length; i++) {
                    if (tracks[i] === track || tracks[i]['track'] === track) {
                        tracks[i]['parentNode']['removeChild'](tracks[i]);
                        break;
                    }
                }
            };

            /* HTML5 Support Testing ---------------------------------------------------- */

            /**
             * Check if HTML5 video is supported by this browser/device
             * @return {Boolean}
             */
            vjs.Html5.isSupported = function(){
                // IE9 with no Media Player is a LIAR! (#984)
                try {
                    vjs.TEST_VID['volume'] = 0.5;
                } catch (e) {
                    return false;
                }

                return !!vjs.TEST_VID.canPlayType;
            };

            // Add Source Handler pattern functions to this tech
            vjs.MediaTechController.withSourceHandlers(vjs.Html5);

            /*
             * Override the withSourceHandler mixin's methods with our own because
             * the HTML5 Media Element returns blob urls when utilizing MSE and we
             * want to still return proper source urls even when in that case
             */
            (function(){
                var
                    origSetSource = vjs.Html5.prototype.setSource,
                    origDisposeSourceHandler = vjs.Html5.prototype.disposeSourceHandler;

                vjs.Html5.prototype.setSource = function (source) {
                    var retVal = origSetSource.call(this, source);
                    this.source_ = source.src;
                    return retVal;
                };

                vjs.Html5.prototype.disposeSourceHandler = function () {
                    this.source_ = undefined;
                    return origDisposeSourceHandler.call(this);
                };
            })();

            /**
             * The default native source handler.
             * This simply passes the source to the video element. Nothing fancy.
             * @param  {Object} source   The source object
             * @param  {vjs.Html5} tech  The instance of the HTML5 tech
             */
            vjs.Html5.nativeSourceHandler = {};

            /**
             * Check if the video element can handle the source natively
             * @param  {Object} source  The source object
             * @return {String}         'probably', 'maybe', or '' (empty string)
             */
            vjs.Html5.nativeSourceHandler.canHandleSource = function(source){
                var match, ext;

                function canPlayType(type){
                    // IE9 on Windows 7 without MediaPlayer throws an error here
                    // https://github.com/videojs/video.js/issues/519
                    try {
                        return vjs.TEST_VID.canPlayType(type);
                    } catch(e) {
                        return '';
                    }
                }

                // If a type was provided we should rely on that
                if (source.type) {
                    return canPlayType(source.type);
                } else if (source.src) {
                    // If no type, fall back to checking 'video/[EXTENSION]'
                    match = source.src.match(/\.([^.\/\?]+)(\?[^\/]+)?$/i);
                    ext = match && match[1];

                    return canPlayType('video/'+ext);
                }

                return '';
            };

            /**
             * Pass the source to the video element
             * Adaptive source handlers will have more complicated workflows before passing
             * video data to the video element
             * @param  {Object} source    The source object
             * @param  {vjs.Html5} tech   The instance of the Html5 tech
             */
            vjs.Html5.nativeSourceHandler.handleSource = function(source, tech){
                tech.setSrc(source.src);
            };

            /**
             * Clean up the source handler when disposing the player or switching sources..
             * (no cleanup is needed when supporting the format natively)
             */
            vjs.Html5.nativeSourceHandler.dispose = function(){};

            // Register the native source handler
            vjs.Html5.registerSourceHandler(vjs.Html5.nativeSourceHandler);

            /**
             * Check if the volume can be changed in this browser/device.
             * Volume cannot be changed in a lot of mobile devices.
             * Specifically, it can't be changed from 1 on iOS.
             * @return {Boolean}
             */
            vjs.Html5.canControlVolume = function(){
                var volume =  vjs.TEST_VID.volume;
                vjs.TEST_VID.volume = (volume / 2) + 0.1;
                return volume !== vjs.TEST_VID.volume;
            };

            /**
             * Check if playbackRate is supported in this browser/device.
             * @return {[type]} [description]
             */
            vjs.Html5.canControlPlaybackRate = function(){
                var playbackRate =  vjs.TEST_VID.playbackRate;
                vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;
                return playbackRate !== vjs.TEST_VID.playbackRate;
            };

            /**
             * Check to see if native text tracks are supported by this browser/device
             * @return {Boolean}
             */
            vjs.Html5.supportsNativeTextTracks = function() {
                var supportsTextTracks;

                // Figure out native text track support
                // If mode is a number, we cannot change it because it'll disappear from view.
                // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
                // Firefox isn't playing nice either with modifying the mode
                // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
                supportsTextTracks = !!vjs.TEST_VID.textTracks;
                if (supportsTextTracks && vjs.TEST_VID.textTracks.length > 0) {
                    supportsTextTracks = typeof vjs.TEST_VID.textTracks[0]['mode'] !== 'number';
                }
                if (supportsTextTracks && vjs.IS_FIREFOX) {
                    supportsTextTracks = false;
                }

                return supportsTextTracks;
            };

            /**
             * Set the tech's volume control support status
             * @type {Boolean}
             */
            vjs.Html5.prototype['featuresVolumeControl'] = vjs.Html5.canControlVolume();

            /**
             * Set the tech's playbackRate support status
             * @type {Boolean}
             */
            vjs.Html5.prototype['featuresPlaybackRate'] = vjs.Html5.canControlPlaybackRate();

            /**
             * Set the tech's status on moving the video element.
             * In iOS, if you move a video element in the DOM, it breaks video playback.
             * @type {Boolean}
             */
            vjs.Html5.prototype['movingMediaElementInDOM'] = !vjs.IS_IOS;

            /**
             * Set the the tech's fullscreen resize support status.
             * HTML video is able to automatically resize when going to fullscreen.
             * (No longer appears to be used. Can probably be removed.)
             */
            vjs.Html5.prototype['featuresFullscreenResize'] = true;

            /**
             * Set the tech's progress event support status
             * (this disables the manual progress events of the MediaTechController)
             */
            vjs.Html5.prototype['featuresProgressEvents'] = true;

            /**
             * Sets the tech's status on native text track support
             * @type {Boolean}
             */
            vjs.Html5.prototype['featuresNativeTextTracks'] = vjs.Html5.supportsNativeTextTracks();

            // HTML5 Feature detection and Device Fixes --------------------------------- //
            (function() {
                var canPlayType,
                    mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i,
                    mp4RE = /^video\/mp4/i;

                vjs.Html5.patchCanPlayType = function() {
                    // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
                    if (vjs.ANDROID_VERSION >= 4.0) {
                        if (!canPlayType) {
                            canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
                        }

                        vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
                            if (type && mpegurlRE.test(type)) {
                                return 'maybe';
                            }
                            return canPlayType.call(this, type);
                        };
                    }

                    // Override Android 2.2 and less canPlayType method which is broken
                    if (vjs.IS_OLD_ANDROID) {
                        if (!canPlayType) {
                            canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
                        }

                        vjs.TEST_VID.constructor.prototype.canPlayType = function(type){
                            if (type && mp4RE.test(type)) {
                                return 'maybe';
                            }
                            return canPlayType.call(this, type);
                        };
                    }
                };

                vjs.Html5.unpatchCanPlayType = function() {
                    var r = vjs.TEST_VID.constructor.prototype.canPlayType;
                    vjs.TEST_VID.constructor.prototype.canPlayType = canPlayType;
                    canPlayType = null;
                    return r;
                };

                // by default, patch the video element
                vjs.Html5.patchCanPlayType();
            })();

            // List of all HTML5 events (various uses).
            vjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');

            vjs.Html5.disposeMediaElement = function(el){
                if (!el) { return; }

                el['player'] = null;

                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }

                // remove any child track or source nodes to prevent their loading
                while(el.hasChildNodes()) {
                    el.removeChild(el.firstChild);
                }

                // remove any src reference. not setting `src=''` because that causes a warning
                // in firefox
                el.removeAttribute('src');

                // force the media element to update its loading state by calling load()
                // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
                if (typeof el.load === 'function') {
                    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
                    (function() {
                        try {
                            el.load();
                        } catch (e) {
                            // not supported
                        }
                    })();
                }
            };

            /**
             * The Media Loader is the component that decides which playback technology to load
             * when the player is initialized.
             *
             * @constructor
             */
            vjs.MediaLoader = vjs.Component.extend({
                /** @constructor */
                init: function(player, options, ready){
                    vjs.Component.call(this, player, options, ready);

                    // If there are no sources when the player is initialized,
                    // load the first supported playback technology.
                    if (!player.options_['sources'] || player.options_['sources'].length === 0) {
                        for (var i=0,j=player.options_['techOrder']; i<j.length; i++) {
                            var techName = vjs.capitalize(j[i]),
                                tech = window['videojs_apn'][techName];

                            // Check if the browser supports this technology
                            if (tech && tech.isSupported()) {
                                player.loadTech(techName);
                                break;
                            }
                        }
                    } else {
                        // // Loop through playback technologies (HTML5, Flash) and check for support.
                        // // Then load the best source.
                        // // A few assumptions here:
                        // //   All playback technologies respect preload false.
                        player.src(player.options_['sources']);
                    }
                }
            });

            /*
             * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
             *
             * enum TextTrackMode { "disabled",  "hidden",  "showing" };
             */
            vjs.TextTrackMode = {
                'disabled': 'disabled',
                'hidden': 'hidden',
                'showing': 'showing'
            };

            /*
             * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
             *
             * enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
             */
            vjs.TextTrackKind = {
                'subtitles': 'subtitles',
                'captions': 'captions',
                'descriptions': 'descriptions',
                'chapters': 'chapters',
                'metadata': 'metadata'
            };

            (function() {
                /*
                 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
                 *
                 * interface TextTrack : EventTarget {
                 *   readonly attribute TextTrackKind kind;
                 *   readonly attribute DOMString label;
                 *   readonly attribute DOMString language;
                 *
                 *   readonly attribute DOMString id;
                 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
                 *
                 *   attribute TextTrackMode mode;
                 *
                 *   readonly attribute TextTrackCueList? cues;
                 *   readonly attribute TextTrackCueList? activeCues;
                 *
                 *   void addCue(TextTrackCue cue);
                 *   void removeCue(TextTrackCue cue);
                 *
                 *   attribute EventHandler oncuechange;
                 * };
                 */

                vjs.TextTrack = function(options) {
                    var tt, id, mode, kind, label, language, cues, activeCues, timeupdateHandler, changed, prop;

                    options = options || {};

                    if (!options['player']) {
                        throw new Error('A player was not provided.');
                    }

                    tt = this;
                    if (vjs.IS_IE8) {
                        tt = document.createElement('custom');

                        for (prop in vjs.TextTrack.prototype) {
                            tt[prop] = vjs.TextTrack.prototype[prop];
                        }
                    }

                    tt.player_ = options['player'];

                    mode = vjs.TextTrackMode[options['mode']] || 'disabled';
                    kind = vjs.TextTrackKind[options['kind']] || 'subtitles';
                    label = options['label'] || '';
                    language = options['language'] || options['srclang'] || '';
                    id = options['id'] || 'vjs_text_track_' + vjs.guid++;

                    if (kind === 'metadata' || kind === 'chapters') {
                        mode = 'hidden';
                    }

                    tt.cues_ = [];
                    tt.activeCues_ = [];

                    cues = new vjs.TextTrackCueList(tt.cues_);
                    activeCues = new vjs.TextTrackCueList(tt.activeCues_);

                    changed = false;
                    timeupdateHandler = vjs.bind(tt, function() {
                        this['activeCues'];
                        if (changed) {
                            this['trigger']('cuechange');
                            changed = false;
                        }
                    });
                    if (mode !== 'disabled') {
                        tt.player_.on('timeupdate', timeupdateHandler);
                    }

                    Object.defineProperty(tt, 'kind', {
                        get: function() {
                            return kind;
                        },
                        set: Function.prototype
                    });

                    Object.defineProperty(tt, 'label', {
                        get: function() {
                            return label;
                        },
                        set: Function.prototype
                    });

                    Object.defineProperty(tt, 'language', {
                        get: function() {
                            return language;
                        },
                        set: Function.prototype
                    });

                    Object.defineProperty(tt, 'id', {
                        get: function() {
                            return id;
                        },
                        set: Function.prototype
                    });

                    Object.defineProperty(tt, 'mode', {
                        get: function() {
                            return mode;
                        },
                        set: function(newMode) {
                            if (!vjs.TextTrackMode[newMode]) {
                                return;
                            }
                            mode = newMode;
                            if (mode === 'showing') {
                                this.player_.on('timeupdate', timeupdateHandler);
                            }
                            this.trigger('modechange');
                        }
                    });

                    Object.defineProperty(tt, 'cues', {
                        get: function() {
                            if (!this.loaded_) {
                                return null;
                            }

                            return cues;
                        },
                        set: Function.prototype
                    });

                    Object.defineProperty(tt, 'activeCues', {
                        get: function() {
                            var i, l, active, ct, cue;

                            if (!this.loaded_) {
                                return null;
                            }

                            if (this['cues'].length === 0) {
                                return activeCues; // nothing to do
                            }

                            ct = this.player_.currentTime();
                            i = 0;
                            l = this['cues'].length;
                            active = [];

                            for (; i < l; i++) {
                                cue = this['cues'][i];
                                if (cue['startTime'] <= ct && cue['endTime'] >= ct) {
                                    active.push(cue);
                                } else if (cue['startTime'] === cue['endTime'] && cue['startTime'] <= ct && cue['startTime'] + 0.5 >= ct) {
                                    active.push(cue);
                                }
                            }

                            changed = false;

                            if (active.length !== this.activeCues_.length) {
                                changed = true;
                            } else {
                                for (i = 0; i < active.length; i++) {
                                    if (indexOf.call(this.activeCues_, active[i]) === -1) {
                                        changed = true;
                                    }
                                }
                            }

                            this.activeCues_ = active;
                            activeCues.setCues_(this.activeCues_);

                            return activeCues;
                        },
                        set: Function.prototype
                    });

                    if (options.src) {
                        loadTrack(options.src, tt);
                    } else {
                        tt.loaded_ = true;
                    }

                    if (vjs.IS_IE8) {
                        return tt;
                    }
                };

                vjs.TextTrack.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
                vjs.TextTrack.prototype.constructor = vjs.TextTrack;

                /*
                 * cuechange - One or more cues in the track have become active or stopped being active.
                 */
                vjs.TextTrack.prototype.allowedEvents_ = {
                    'cuechange': 'cuechange'
                };

                vjs.TextTrack.prototype.addCue = function(cue) {
                    var tracks = this.player_.textTracks(),
                        i = 0;

                    if (tracks) {
                        for (; i < tracks.length; i++) {
                            if (tracks[i] !== this) {
                                tracks[i].removeCue(cue);
                            }
                        }
                    }

                    this.cues_.push(cue);
                    this['cues'].setCues_(this.cues_);
                };

                vjs.TextTrack.prototype.removeCue = function(removeCue) {
                    var i = 0,
                        l = this.cues_.length,
                        cue,
                        removed = false;

                    for (; i < l; i++) {
                        cue = this.cues_[i];
                        if (cue === removeCue) {
                            this.cues_.splice(i, 1);
                            removed = true;
                        }
                    }

                    if (removed) {
                        this.cues.setCues_(this.cues_);
                    }
                };

                /*
                 * Downloading stuff happens below this point
                 */
                var loadTrack, parseCues, indexOf;

                loadTrack = function(src, track) {
                    vjs.xhr(src, vjs.bind(this, function(err, response, responseBody){
                        if (err) {
                            return vjs.log.error(err);
                        }


                        track.loaded_ = true;
                        parseCues(responseBody, track);
                    }));
                };

                parseCues = function(srcContent, track) {
                    if (typeof window['WebVTT'] !== 'function') {
                        //try again a bit later
                        return window.setTimeout(function() {
                            parseCues(srcContent, track);
                        }, 25);
                    }

                    var parser = new window['WebVTT']['Parser'](window, window['vttjs'], window['WebVTT']['StringDecoder']());

                    parser['oncue'] = function(cue) {
                        track.addCue(cue);
                    };
                    parser['onparsingerror'] = function(error) {
                        vjs.log.error(error);
                    };

                    parser['parse'](srcContent);
                    parser['flush']();
                };

                indexOf = function(searchElement, fromIndex) {

                    var k;

                    if (this == null) {
                        throw new TypeError('"this" is null or not defined');
                    }

                    var O = Object(this);

                    var len = O.length >>> 0;

                    if (len === 0) {
                        return -1;
                    }

                    var n = +fromIndex || 0;

                    if (Math.abs(n) === Infinity) {
                        n = 0;
                    }

                    if (n >= len) {
                        return -1;
                    }

                    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

                    while (k < len) {
                        if (k in O && O[k] === searchElement) {
                            return k;
                        }
                        k++;
                    }
                    return -1;
                };

            })();

            /*
             * https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
             *
             * interface TextTrackList : EventTarget {
             *   readonly attribute unsigned long length;
             *   getter TextTrack (unsigned long index);
             *   TextTrack? getTrackById(DOMString id);
             *
             *   attribute EventHandler onchange;
             *   attribute EventHandler onaddtrack;
             *   attribute EventHandler onremovetrack;
             * };
             */
            vjs.TextTrackList = function(tracks) {
                var list = this,
                    prop,
                    i = 0;

                if (vjs.IS_IE8) {
                    list = document.createElement('custom');

                    for (prop in vjs.TextTrackList.prototype) {
                        list[prop] = vjs.TextTrackList.prototype[prop];
                    }
                }

                tracks = tracks || [];
                list.tracks_ = [];

                Object.defineProperty(list, 'length', {
                    get: function() {
                        return this.tracks_.length;
                    }
                });

                for (; i < tracks.length; i++) {
                    list.addTrack_(tracks[i]);
                }

                if (vjs.IS_IE8) {
                    return list;
                }
            };

            vjs.TextTrackList.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
            vjs.TextTrackList.prototype.constructor = vjs.TextTrackList;

            /*
             * change - One or more tracks in the track list have been enabled or disabled.
             * addtrack - A track has been added to the track list.
             * removetrack - A track has been removed from the track list.
             */
            vjs.TextTrackList.prototype.allowedEvents_ = {
                'change': 'change',
                'addtrack': 'addtrack',
                'removetrack': 'removetrack'
            };

            // emulate attribute EventHandler support to allow for feature detection
            (function() {
                var event;

                for (event in vjs.TextTrackList.prototype.allowedEvents_) {
                    vjs.TextTrackList.prototype['on' + event] = null;
                }
            })();

            vjs.TextTrackList.prototype.addTrack_ = function(track) {
                var index = this.tracks_.length;
                if (!(''+index in this)) {
                    Object.defineProperty(this, index, {
                        get: function() {
                            return this.tracks_[index];
                        }
                    });
                }

                track.addEventListener('modechange', vjs.bind(this, function() {
                    this.trigger('change');
                }));
                this.tracks_.push(track);

                this.trigger({
                    type: 'addtrack',
                    track: track
                });
            };

            vjs.TextTrackList.prototype.removeTrack_ = function(rtrack) {
                var i = 0,
                    l = this.length,
                    result = null,
                    track;

                for (; i < l; i++) {
                    track = this[i];
                    if (track === rtrack) {
                        this.tracks_.splice(i, 1);
                        break;
                    }
                }

                this.trigger({
                    type: 'removetrack',
                    track: rtrack
                });
            };

            vjs.TextTrackList.prototype.getTrackById = function(id) {
                var i = 0,
                    l = this.length,
                    result = null,
                    track;

                for (; i < l; i++) {
                    track = this[i];
                    if (track.id === id) {
                        result = track;
                        break;
                    }
                }

                return result;
            };

            /*
             * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
             *
             * interface TextTrackCueList {
             *   readonly attribute unsigned long length;
             *   getter TextTrackCue (unsigned long index);
             *   TextTrackCue? getCueById(DOMString id);
             * };
             */

            vjs.TextTrackCueList = function(cues) {
                var list = this,
                    prop;

                if (vjs.IS_IE8) {
                    list = document.createElement('custom');

                    for (prop in vjs.TextTrackCueList.prototype) {
                        list[prop] = vjs.TextTrackCueList.prototype[prop];
                    }
                }

                vjs.TextTrackCueList.prototype.setCues_.call(list, cues);

                Object.defineProperty(list, 'length', {
                    get: function() {
                        return this.length_;
                    }
                });

                if (vjs.IS_IE8) {
                    return list;
                }
            };

            vjs.TextTrackCueList.prototype.setCues_ = function(cues) {
                var oldLength = this.length || 0,
                    i = 0,
                    l = cues.length,
                    defineProp;

                this.cues_ = cues;
                this.length_ = cues.length;

                defineProp = function(i) {
                    if (!(''+i in this)) {
                        Object.defineProperty(this, '' + i, {
                            get: function() {
                                return this.cues_[i];
                            }
                        });
                    }
                };

                if (oldLength < l) {
                    i = oldLength;
                    for(; i < l; i++) {
                        defineProp.call(this, i);
                    }
                }
            };

            vjs.TextTrackCueList.prototype.getCueById = function(id) {
                var i = 0,
                    l = this.length,
                    result = null,
                    cue;

                for (; i < l; i++) {
                    cue = this[i];
                    if (cue.id === id) {
                        result = cue;
                        break;
                    }
                }

                return result;
            };

            (function() {
                'use strict';

                /* Text Track Display
                 ============================================================================= */
                // Global container for both subtitle and captions text. Simple div container.

                /**
                 * The component for displaying text track cues
                 *
                 * @constructor
                 */
                vjs.TextTrackDisplay = vjs.Component.extend({
                    /** @constructor */
                    init: function(player, options, ready){
                        vjs.Component.call(this, player, options, ready);

                        player.on('loadstart', vjs.bind(this, this.toggleDisplay));

                        // This used to be called during player init, but was causing an error
                        // if a track should show by default and the display hadn't loaded yet.
                        // Should probably be moved to an external track loader when we support
                        // tracks that don't need a display.
                        player.ready(vjs.bind(this, function() {
                            if (player.tech && player.tech['featuresNativeTextTracks']) {
                                this.hide();
                                return;
                            }

                            var i, tracks, track;

                            player.on('fullscreenchange', vjs.bind(this, this.updateDisplay));

                            tracks = player.options_['tracks'] || [];
                            for (i = 0; i < tracks.length; i++) {
                                track = tracks[i];
                                this.player_.addRemoteTextTrack(track);
                            }
                        }));
                    }
                });

                vjs.TextTrackDisplay.prototype.toggleDisplay = function() {
                    if (this.player_.tech && this.player_.tech['featuresNativeTextTracks']) {
                        this.hide();
                    } else {
                        this.show();
                    }
                };

                vjs.TextTrackDisplay.prototype.createEl = function(){
                    return vjs.Component.prototype.createEl.call(this, 'div', {
                        className: 'vjs-text-track-display'
                    });
                };

                vjs.TextTrackDisplay.prototype.clearDisplay = function() {
                    if (typeof window['WebVTT'] === 'function') {
                        window['WebVTT']['processCues'](window, [], this.el_);
                    }
                };

                // Add cue HTML to display
                var constructColor = function(color, opacity) {
                    return 'rgba(' +
                        // color looks like "#f0e"
                        parseInt(color[1] + color[1], 16) + ',' +
                        parseInt(color[2] + color[2], 16) + ',' +
                        parseInt(color[3] + color[3], 16) + ',' +
                        opacity + ')';
                };
                var darkGray = '#222';
                var lightGray = '#ccc';
                var fontMap = {
                    monospace:             'monospace',
                    sansSerif:             'sans-serif',
                    serif:                 'serif',
                    monospaceSansSerif:    '"Andale Mono", "Lucida Console", monospace',
                    monospaceSerif:        '"Courier New", monospace',
                    proportionalSansSerif: 'sans-serif',
                    proportionalSerif:     'serif',
                    casual:                '"Comic Sans MS", Impact, fantasy',
                    script:                '"Monotype Corsiva", cursive',
                    smallcaps:             '"Andale Mono", "Lucida Console", monospace, sans-serif'
                };
                var tryUpdateStyle = function(el, style, rule) {
                    // some style changes will throw an error, particularly in IE8. Those should be noops.
                    try {
                        el.style[style] = rule;
                    } catch (e) {}
                };

                vjs.TextTrackDisplay.prototype.updateDisplay = function() {
                    var tracks = this.player_.textTracks(),
                        i = 0,
                        track;

                    this.clearDisplay();

                    if (!tracks) {
                        return;
                    }

                    for (; i < tracks.length; i++) {
                        track = tracks[i];
                        if (track['mode'] === 'showing') {
                            this.updateForTrack(track);
                        }
                    }
                };

                vjs.TextTrackDisplay.prototype.updateForTrack = function(track) {
                    if (typeof window['WebVTT'] !== 'function' || !track['activeCues']) {
                        return;
                    }

                    var i = 0,
                        property,
                        cueDiv,
                        overrides = this.player_['textTrackSettings'].getValues(),
                        fontSize,
                        cues = [];

                    for (; i < track['activeCues'].length; i++) {
                        cues.push(track['activeCues'][i]);
                    }

                    window['WebVTT']['processCues'](window, track['activeCues'], this.el_);

                    i = cues.length;
                    while (i--) {
                        cueDiv = cues[i].displayState;
                        if (overrides.color) {
                            cueDiv.firstChild.style.color = overrides.color;
                        }
                        if (overrides.textOpacity) {
                            tryUpdateStyle(cueDiv.firstChild,
                                'color',
                                constructColor(overrides.color || '#fff',
                                    overrides.textOpacity));
                        }
                        if (overrides.backgroundColor) {
                            cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
                        }
                        if (overrides.backgroundOpacity) {
                            tryUpdateStyle(cueDiv.firstChild,
                                'backgroundColor',
                                constructColor(overrides.backgroundColor || '#000',
                                    overrides.backgroundOpacity));
                        }
                        if (overrides.windowColor) {
                            if (overrides.windowOpacity) {
                                tryUpdateStyle(cueDiv,
                                    'backgroundColor',
                                    constructColor(overrides.windowColor, overrides.windowOpacity));
                            } else {
                                cueDiv.style.backgroundColor = overrides.windowColor;
                            }
                        }
                        if (overrides.edgeStyle) {
                            if (overrides.edgeStyle === 'dropshadow') {
                                cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
                            } else if (overrides.edgeStyle === 'raised') {
                                cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
                            } else if (overrides.edgeStyle === 'depressed') {
                                cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
                            } else if (overrides.edgeStyle === 'uniform') {
                                cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
                            }
                        }
                        if (overrides.fontPercent && overrides.fontPercent !== 1) {
                            fontSize = window.parseFloat(cueDiv.style.fontSize);
                            cueDiv.style.fontSize = (fontSize * overrides.fontPercent) + 'px';
                            cueDiv.style.height = 'auto';
                            cueDiv.style.top = 'auto';
                            cueDiv.style.bottom = '2px';
                        }
                        if (overrides.fontFamily && overrides.fontFamily !== 'default') {
                            if (overrides.fontFamily === 'small-caps') {
                                cueDiv.firstChild.style.fontVariant = 'small-caps';
                            } else {
                                cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
                            }
                        }
                    }
                };


                /**
                 * The specific menu item type for selecting a language within a text track kind
                 *
                 * @constructor
                 */
                vjs.TextTrackMenuItem = vjs.MenuItem.extend({
                    /** @constructor */
                    init: function(player, options){
                        var track = this.track = options['track'],
                            tracks = player.textTracks(),
                            changeHandler,
                            event;

                        if (tracks) {
                            changeHandler = vjs.bind(this, function() {
                                var selected = this.track['mode'] === 'showing',
                                    track,
                                    i,
                                    l;

                                if (this instanceof vjs.OffTextTrackMenuItem) {
                                    selected = true;

                                    i = 0,
                                        l = tracks.length;

                                    for (; i < l; i++) {
                                        track = tracks[i];
                                        if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {
                                            selected = false;
                                            break;
                                        }
                                    }
                                }

                                this.selected(selected);
                            });
                            tracks.addEventListener('change', changeHandler);
                            player.on('dispose', function() {
                                tracks.removeEventListener('change', changeHandler);
                            });
                        }

                        // Modify options for parent MenuItem class's init.
                        options['label'] = track['label'] || track['language'] || 'Unknown';
                        options['selected'] = track['default'] || track['mode'] === 'showing';
                        vjs.MenuItem.call(this, player, options);

                        // iOS7 doesn't dispatch change events to TextTrackLists when an
                        // associated track's mode changes. Without something like
                        // Object.observe() (also not present on iOS7), it's not
                        // possible to detect changes to the mode attribute and polyfill
                        // the change event. As a poor substitute, we manually dispatch
                        // change events whenever the controls modify the mode.
                        if (tracks && tracks.onchange === undefined) {
                            this.on(['tap', 'click'], function() {
                                if (typeof window.Event !== 'object') {
                                    // Android 2.3 throws an Illegal Constructor error for window.Event
                                    try {
                                        event = new window.Event('change');
                                    } catch(err){}
                                }

                                if (!event) {
                                    event = document.createEvent('Event');
                                    event.initEvent('change', true, true);
                                }

                                tracks.dispatchEvent(event);
                            });
                        }
                    }
                });

                vjs.TextTrackMenuItem.prototype.onClick = function(){
                    var kind = this.track['kind'],
                        tracks = this.player_.textTracks(),
                        mode,
                        track,
                        i = 0;

                    vjs.MenuItem.prototype.onClick.call(this);

                    if (!tracks) {
                        return;
                    }

                    for (; i < tracks.length; i++) {
                        track = tracks[i];

                        if (track['kind'] !== kind) {
                            continue;
                        }

                        if (track === this.track) {
                            track['mode'] = 'showing';
                        } else {
                            track['mode'] = 'disabled';
                        }
                    }
                };

                /**
                 * A special menu item for turning of a specific type of text track
                 *
                 * @constructor
                 */
                vjs.OffTextTrackMenuItem = vjs.TextTrackMenuItem.extend({
                    /** @constructor */
                    init: function(player, options){
                        // Create pseudo track info
                        // Requires options['kind']
                        options['track'] = {
                            'kind': options['kind'],
                            'player': player,
                            'label': options['kind'] + ' off',
                            'default': false,
                            'mode': 'disabled'
                        };
                        vjs.TextTrackMenuItem.call(this, player, options);
                        this.selected(true);
                    }
                });

                vjs.CaptionSettingsMenuItem = vjs.TextTrackMenuItem.extend({
                    init: function(player, options) {
                        options['track'] = {
                            'kind': options['kind'],
                            'player': player,
                            'label': options['kind'] + ' settings',
                            'default': false,
                            mode: 'disabled'
                        };

                        vjs.TextTrackMenuItem.call(this, player, options);
                        this.addClass('vjs-texttrack-settings');
                    }
                });

                vjs.CaptionSettingsMenuItem.prototype.onClick = function() {
                    this.player().getChild('textTrackSettings').show();
                };

                /**
                 * The base class for buttons that toggle specific text track types (e.g. subtitles)
                 *
                 * @constructor
                 */
                vjs.TextTrackButton = vjs.MenuButton.extend({
                    /** @constructor */
                    init: function(player, options){
                        var tracks, updateHandler;

                        vjs.MenuButton.call(this, player, options);

                        tracks = this.player_.textTracks();

                        if (this.items.length <= 1) {
                            this.hide();
                        }

                        if (!tracks) {
                            return;
                        }

                        updateHandler = vjs.bind(this, this.update);
                        tracks.addEventListener('removetrack', updateHandler);
                        tracks.addEventListener('addtrack', updateHandler);

                        this.player_.on('dispose', function() {
                            tracks.removeEventListener('removetrack', updateHandler);
                            tracks.removeEventListener('addtrack', updateHandler);
                        });
                    }
                });

                // Create a menu item for each text track
                vjs.TextTrackButton.prototype.createItems = function(){
                    var items = [], track, tracks;

                    if (this instanceof vjs.CaptionsButton && !(this.player().tech && this.player().tech['featuresNativeTextTracks'])) {
                        items.push(new vjs.CaptionSettingsMenuItem(this.player_, { 'kind': this.kind_ }));
                    }

                    // Add an OFF menu item to turn all tracks off
                    items.push(new vjs.OffTextTrackMenuItem(this.player_, { 'kind': this.kind_ }));

                    tracks = this.player_.textTracks();

                    if (!tracks) {
                        return items;
                    }

                    for (var i = 0; i < tracks.length; i++) {
                        track = tracks[i];

                        // only add tracks that are of the appropriate kind and have a label
                        if (track['kind'] === this.kind_) {
                            items.push(new vjs.TextTrackMenuItem(this.player_, {
                                'track': track
                            }));
                        }
                    }

                    return items;
                };

                /**
                 * The button component for toggling and selecting captions
                 *
                 * @constructor
                 */
                vjs.CaptionsButton = vjs.TextTrackButton.extend({
                    /** @constructor */
                    init: function(player, options, ready){
                        vjs.TextTrackButton.call(this, player, options, ready);
                        this.el_.setAttribute('aria-label','Captions Menu');
                    }
                });
                vjs.CaptionsButton.prototype.kind_ = 'captions';
                vjs.CaptionsButton.prototype.buttonText = 'Captions';
                vjs.CaptionsButton.prototype.className = 'vjs-captions-button';

                vjs.CaptionsButton.prototype.update = function() {
                    var threshold = 2;
                    vjs.TextTrackButton.prototype.update.call(this);

                    // if native, then threshold is 1 because no settings button
                    if (this.player().tech && this.player().tech['featuresNativeTextTracks']) {
                        threshold = 1;
                    }

                    if (this.items && this.items.length > threshold) {
                        this.show();
                    } else {
                        this.hide();
                    }
                };

                /**
                 * The button component for toggling and selecting subtitles
                 *
                 * @constructor
                 */
                vjs.SubtitlesButton = vjs.TextTrackButton.extend({
                    /** @constructor */
                    init: function(player, options, ready){
                        vjs.TextTrackButton.call(this, player, options, ready);
                        this.el_.setAttribute('aria-label','Subtitles Menu');
                    }
                });
                vjs.SubtitlesButton.prototype.kind_ = 'subtitles';
                vjs.SubtitlesButton.prototype.buttonText = 'Subtitles';
                vjs.SubtitlesButton.prototype.className = 'vjs-subtitles-button';

                // Chapters act much differently than other text tracks
                // Cues are navigation vs. other tracks of alternative languages
                /**
                 * The button component for toggling and selecting chapters
                 *
                 * @constructor
                 */
                vjs.ChaptersButton = vjs.TextTrackButton.extend({
                    /** @constructor */
                    init: function(player, options, ready){
                        vjs.TextTrackButton.call(this, player, options, ready);
                        this.el_.setAttribute('aria-label','Chapters Menu');
                    }
                });
                vjs.ChaptersButton.prototype.kind_ = 'chapters';
                vjs.ChaptersButton.prototype.buttonText = 'Chapters';
                vjs.ChaptersButton.prototype.className = 'vjs-chapters-button';

                // Create a menu item for each text track
                vjs.ChaptersButton.prototype.createItems = function(){
                    var items = [], track, tracks;

                    tracks = this.player_.textTracks();

                    if (!tracks) {
                        return items;
                    }

                    for (var i = 0; i < tracks.length; i++) {
                        track = tracks[i];
                        if (track['kind'] === this.kind_) {
                            items.push(new vjs.TextTrackMenuItem(this.player_, {
                                'track': track
                            }));
                        }
                    }

                    return items;
                };

                vjs.ChaptersButton.prototype.createMenu = function(){
                    var tracks = this.player_.textTracks() || [],
                        i = 0,
                        l = tracks.length,
                        track, chaptersTrack,
                        items = this.items = [];

                    for (; i < l; i++) {
                        track = tracks[i];
                        if (track['kind'] == this.kind_) {
                            if (!track.cues) {
                                track['mode'] = 'hidden';
                                /* jshint loopfunc:true */
                                // TODO see if we can figure out a better way of doing this https://github.com/videojs/video.js/issues/1864
                                window.setTimeout(vjs.bind(this, function() {
                                    this.createMenu();
                                }), 100);
                                /* jshint loopfunc:false */
                            } else {
                                chaptersTrack = track;
                                break;
                            }
                        }
                    }

                    var menu = this.menu;
                    if (menu === undefined) {
                        menu = new vjs.Menu(this.player_);
                        menu.contentEl().appendChild(vjs.createEl('li', {
                            className: 'vjs-menu-title',
                            innerHTML: vjs.capitalize(this.kind_),
                            tabindex: -1
                        }));
                    }

                    if (chaptersTrack) {
                        var cues = chaptersTrack['cues'], cue, mi;
                        i = 0;
                        l = cues.length;

                        for (; i < l; i++) {
                            cue = cues[i];

                            mi = new vjs.ChaptersTrackMenuItem(this.player_, {
                                'track': chaptersTrack,
                                'cue': cue
                            });

                            items.push(mi);

                            menu.addChild(mi);
                        }
                        this.addChild(menu);
                    }

                    if (this.items.length > 0) {
                        this.show();
                    }

                    return menu;
                };


                /**
                 * @constructor
                 */
                vjs.ChaptersTrackMenuItem = vjs.MenuItem.extend({
                    /** @constructor */
                    init: function(player, options){
                        var track = this.track = options['track'],
                            cue = this.cue = options['cue'],
                            currentTime = player.currentTime();

                        // Modify options for parent MenuItem class's init.
                        options['label'] = cue.text;
                        options['selected'] = (cue['startTime'] <= currentTime && currentTime < cue['endTime']);
                        vjs.MenuItem.call(this, player, options);

                        track.addEventListener('cuechange', vjs.bind(this, this.update));
                    }
                });

                vjs.ChaptersTrackMenuItem.prototype.onClick = function(){
                    vjs.MenuItem.prototype.onClick.call(this);
                    this.player_.currentTime(this.cue.startTime);
                    this.update(this.cue.startTime);
                };

                vjs.ChaptersTrackMenuItem.prototype.update = function(){
                    var cue = this.cue,
                        currentTime = this.player_.currentTime();

                    // vjs.log(currentTime, cue.startTime);
                    this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);
                };
            })();

            (function() {
                'use strict';

                vjs.TextTrackSettings = vjs.Component.extend({
                    init: function(player, options) {
                        vjs.Component.call(this, player, options);
                        this.hide();

                        vjs.on(this.el().querySelector('.vjs-done-button'), 'click', vjs.bind(this, function() {
                            this.saveSettings();
                            this.hide();
                        }));

                        vjs.on(this.el().querySelector('.vjs-default-button'), 'click', vjs.bind(this, function() {
                            this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
                            this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
                            this.el().querySelector('.window-color > select').selectedIndex = 0;
                            this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
                            this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
                            this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
                            this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
                            this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
                            this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
                            this.updateDisplay();
                        }));

                        vjs.on(this.el().querySelector('.vjs-fg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-bg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.window-color > select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-font-percent select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-edge-style select'), 'change', vjs.bind(this, this.updateDisplay));
                        vjs.on(this.el().querySelector('.vjs-font-family select'), 'change', vjs.bind(this, this.updateDisplay));

                        if (player.options()['persistTextTrackSettings']) {
                            this.restoreSettings();
                        }
                    }
                });

                vjs.TextTrackSettings.prototype.createEl = function() {
                    return vjs.Component.prototype.createEl.call(this, 'div', {
                        className: 'vjs-caption-settings vjs-modal-overlay',
                        innerHTML: captionOptionsMenuTemplate()
                    });
                };

                vjs.TextTrackSettings.prototype.getValues = function() {
                    var el, bgOpacity, textOpacity, windowOpacity, textEdge, fontFamily, fgColor, bgColor, windowColor, result, name, fontPercent;

                    el = this.el();

                    textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
                    fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
                    fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
                    textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
                    bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
                    bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
                    windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
                    windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
                    fontPercent = window['parseFloat'](getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));

                    result = {
                        'backgroundOpacity': bgOpacity,
                        'textOpacity': textOpacity,
                        'windowOpacity': windowOpacity,
                        'edgeStyle': textEdge,
                        'fontFamily': fontFamily,
                        'color': fgColor,
                        'backgroundColor': bgColor,
                        'windowColor': windowColor,
                        'fontPercent': fontPercent
                    };
                    for (name in result) {
                        if (result[name] === '' || result[name] === 'none' || (name === 'fontPercent' && result[name] === 1.00)) {
                            delete result[name];
                        }
                    }
                    return result;
                };

                vjs.TextTrackSettings.prototype.setValues = function(values) {
                    var el = this.el(), fontPercent;

                    setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
                    setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
                    setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
                    setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
                    setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
                    setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
                    setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
                    setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);

                    fontPercent = values.fontPercent;

                    if (fontPercent) {
                        fontPercent = fontPercent.toFixed(2);
                    }

                    setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
                };

                vjs.TextTrackSettings.prototype.restoreSettings = function() {
                    var values;
                    try {
                        values = JSON.parse(window.localStorage.getItem('vjs-text-track-settings'));
                    } catch (e) {}

                    if (values) {
                        this.setValues(values);
                    }
                };

                vjs.TextTrackSettings.prototype.saveSettings = function() {
                    var values;

                    if (!this.player_.options()['persistTextTrackSettings']) {
                        return;
                    }

                    values = this.getValues();
                    try {
                        if (!vjs.isEmpty(values)) {
                            window.localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
                        } else {
                            window.localStorage.removeItem('vjs-text-track-settings');
                        }
                    } catch (e) {}
                };

                vjs.TextTrackSettings.prototype.updateDisplay = function() {
                    var ttDisplay = this.player_.getChild('textTrackDisplay');
                    if (ttDisplay) {
                        ttDisplay.updateDisplay();
                    }
                };

                function getSelectedOptionValue(target) {
                    var selectedOption;
                    // not all browsers support selectedOptions, so, fallback to options
                    if (target.selectedOptions) {
                        selectedOption = target.selectedOptions[0];
                    } else if (target.options) {
                        selectedOption = target.options[target.options.selectedIndex];
                    }

                    return selectedOption.value;
                }

                function setSelectedOption(target, value) {
                    var i, option;

                    if (!value) {
                        return;
                    }

                    for (i = 0; i < target.options.length; i++) {
                        option = target.options[i];
                        if (option.value === value) {
                            break;
                        }
                    }

                    target.selectedIndex = i;
                }

                function captionOptionsMenuTemplate() {
                    return '<div class="vjs-tracksettings">' +
                        '<div class="vjs-tracksettings-colors">' +
                        '<div class="vjs-fg-color vjs-tracksetting">' +
                        '<label class="vjs-label">Foreground</label>' +
                        '<select>' +
                        '<option value="">---</option>' +
                        '<option value="#FFF">White</option>' +
                        '<option value="#000">Black</option>' +
                        '<option value="#F00">Red</option>' +
                        '<option value="#0F0">Green</option>' +
                        '<option value="#00F">Blue</option>' +
                        '<option value="#FF0">Yellow</option>' +
                        '<option value="#F0F">Magenta</option>' +
                        '<option value="#0FF">Cyan</option>' +
                        '</select>' +
                        '<span class="vjs-text-opacity vjs-opacity">' +
                        '<select>' +
                        '<option value="">---</option>' +
                        '<option value="1">Opaque</option>' +
                        '<option value="0.5">Semi-Opaque</option>' +
                        '</select>' +
                        '</span>' +
                        '</div>' + // vjs-fg-color
                        '<div class="vjs-bg-color vjs-tracksetting">' +
                        '<label class="vjs-label">Background</label>' +
                        '<select>' +
                        '<option value="">---</option>' +
                        '<option value="#FFF">White</option>' +
                        '<option value="#000">Black</option>' +
                        '<option value="#F00">Red</option>' +
                        '<option value="#0F0">Green</option>' +
                        '<option value="#00F">Blue</option>' +
                        '<option value="#FF0">Yellow</option>' +
                        '<option value="#F0F">Magenta</option>' +
                        '<option value="#0FF">Cyan</option>' +
                        '</select>' +
                        '<span class="vjs-bg-opacity vjs-opacity">' +
                        '<select>' +
                        '<option value="">---</option>' +
                        '<option value="1">Opaque</option>' +
                        '<option value="0.5">Semi-Transparent</option>' +
                        '<option value="0">Transparent</option>' +
                        '</select>' +
                        '</span>' +
                        '</div>' + // vjs-bg-color
                        '<div class="window-color vjs-tracksetting">' +
                        '<label class="vjs-label">Window</label>' +
                        '<select>' +
                        '<option value="">---</option>' +
                        '<option value="#FFF">White</option>' +
                        '<option value="#000">Black</option>' +
                        '<option value="#F00">Red</option>' +
                        '<option value="#0F0">Green</option>' +
                        '<option value="#00F">Blue</option>' +
                        '<option value="#FF0">Yellow</option>' +
                        '<option value="#F0F">Magenta</option>' +
                        '<option value="#0FF">Cyan</option>' +
                        '</select>' +
                        '<span class="vjs-window-opacity vjs-opacity">' +
                        '<select>' +
                        '<option value="">---</option>' +
                        '<option value="1">Opaque</option>' +
                        '<option value="0.5">Semi-Transparent</option>' +
                        '<option value="0">Transparent</option>' +
                        '</select>' +
                        '</span>' +
                        '</div>' + // vjs-window-color
                        '</div>' + // vjs-tracksettings
                        '<div class="vjs-tracksettings-font">' +
                        '<div class="vjs-font-percent vjs-tracksetting">' +
                        '<label class="vjs-label">Font Size</label>' +
                        '<select>' +
                        '<option value="0.50">50%</option>' +
                        '<option value="0.75">75%</option>' +
                        '<option value="1.00" selected>100%</option>' +
                        '<option value="1.25">125%</option>' +
                        '<option value="1.50">150%</option>' +
                        '<option value="1.75">175%</option>' +
                        '<option value="2.00">200%</option>' +
                        '<option value="3.00">300%</option>' +
                        '<option value="4.00">400%</option>' +
                        '</select>' +
                        '</div>' + // vjs-font-percent
                        '<div class="vjs-edge-style vjs-tracksetting">' +
                        '<label class="vjs-label">Text Edge Style</label>' +
                        '<select>' +
                        '<option value="none">None</option>' +
                        '<option value="raised">Raised</option>' +
                        '<option value="depressed">Depressed</option>' +
                        '<option value="uniform">Uniform</option>' +
                        '<option value="dropshadow">Dropshadow</option>' +
                        '</select>' +
                        '</div>' + // vjs-edge-style
                        '<div class="vjs-font-family vjs-tracksetting">' +
                        '<label class="vjs-label">Font Family</label>' +
                        '<select>' +
                        '<option value="">Default</option>' +
                        '<option value="monospaceSerif">Monospace Serif</option>' +
                        '<option value="proportionalSerif">Proportional Serif</option>' +
                        '<option value="monospaceSansSerif">Monospace Sans-Serif</option>' +
                        '<option value="proportionalSansSerif">Proportional Sans-Serif</option>' +
                        '<option value="casual">Casual</option>' +
                        '<option value="script">Script</option>' +
                        '<option value="small-caps">Small Caps</option>' +
                        '</select>' +
                        '</div>' + // vjs-font-family
                        '</div>' +
                        '</div>' +
                        '<div class="vjs-tracksettings-controls">' +
                        '<button class="vjs-default-button">Defaults</button>' +
                        '<button class="vjs-done-button">Done</button>' +
                        '</div>';
                }

            })();

            /**
             * @fileoverview Add JSON support
             * @suppress {undefinedVars}
             * (Compiler doesn't like JSON not being declared)
             */

            /**
             * Javascript JSON implementation
             * (Parse Method Only)
             * https://github.com/douglascrockford/JSON-js/blob/master/json2.js
             * Only using for parse method when parsing data-setup attribute JSON.
             * @suppress {undefinedVars}
             * @namespace
             * @private
             */
            vjs.JSON;

            if (typeof window.JSON !== 'undefined' && typeof window.JSON.parse === 'function') {
                vjs.JSON = window.JSON;

            } else {
                vjs.JSON = {};

                var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

                /**
                 * parse the json
                 *
                 * @memberof vjs.JSON
                 * @param {String} text The JSON string to parse
                 * @param {Function=} [reviver] Optional function that can transform the results
                 * @return {Object|Array} The parsed JSON
                 */
                vjs.JSON.parse = function (text, reviver) {
                    var j;

                    function walk(holder, key) {
                        var k, v, value = holder[key];
                        if (value && typeof value === 'object') {
                            for (k in value) {
                                if (Object.prototype.hasOwnProperty.call(value, k)) {
                                    v = walk(value, k);
                                    if (v !== undefined) {
                                        value[k] = v;
                                    } else {
                                        delete value[k];
                                    }
                                }
                            }
                        }
                        return reviver.call(holder, key, value);
                    }
                    text = String(text);
                    cx.lastIndex = 0;
                    if (cx.test(text)) {
                        text = text.replace(cx, function (a) {
                            return '\\u' +
                                ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                        });
                    }

                    if (/^[\],:{}\s]*$/
                            .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                                .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                                .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                        j = eval('(' + text + ')');

                        return typeof reviver === 'function' ?
                            walk({'': j}, '') : j;
                    }

                    throw new SyntaxError('JSON.parse(): invalid or malformed JSON data');
                };
            }

            /**
             * @fileoverview Functions for automatically setting up a player
             * based on the data-setup attribute of the video tag
             */

            // Automatically set up any tags that have a data-setup attribute
            vjs.autoSetup = function(){
                var options, mediaEl, player, i, e;

                // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
                // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
                // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
                // var mediaEls = vids.concat(audios);

                // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
                // to build up a new, combined list of elements.
                var vids = document.getElementsByTagName('video');
                var audios = document.getElementsByTagName('audio');
                var mediaEls = [];
                if (vids && vids.length > 0) {
                    for(i=0, e=vids.length; i<e; i++) {
                        mediaEls.push(vids[i]);
                    }
                }
                if (audios && audios.length > 0) {
                    for(i=0, e=audios.length; i<e; i++) {
                        mediaEls.push(audios[i]);
                    }
                }

                // Check if any media elements exist
                if (mediaEls && mediaEls.length > 0) {

                    for (i=0,e=mediaEls.length; i<e; i++) {
                        mediaEl = mediaEls[i];

                        // Check if element exists, has getAttribute func.
                        // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
                        if (mediaEl && mediaEl.getAttribute) {

                            // Make sure this player hasn't already been set up.
                            if (mediaEl['player'] === undefined) {
                                options = mediaEl.getAttribute('data-setup');

                                // Check if data-setup attr exists.
                                // We only auto-setup if they've added the data-setup attr.
                                if (options !== null) {
                                    // Create new video.js instance.
                                    player = videojs(mediaEl);
                                }
                            }

                            // If getAttribute isn't defined, we need to wait for the DOM.
                        } else {
                            vjs.autoSetupTimeout(1);
                            break;
                        }
                    }

                    // No videos were found, so keep looping unless page is finished loading.
                } else if (!vjs.windowLoaded) {
                    vjs.autoSetupTimeout(1);
                }
            };

            // Pause to let the DOM keep processing
            vjs.autoSetupTimeout = function(wait){
                setTimeout(vjs.autoSetup, wait);
            };

            if (document.readyState === 'complete') {
                vjs.windowLoaded = true;
            } else {
                vjs.one(window, 'load', function(){
                    vjs.windowLoaded = true;
                });
            }

            // Run Auto-load players
            // You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
            vjs.autoSetupTimeout(1);

            /**
             * the method for registering a video.js plugin
             *
             * @param  {String} name The name of the plugin
             * @param  {Function} init The function that is run when the player inits
             */
            vjs.plugin = function(name, init){
                vjs.Player.prototype[name] = init;
            };

            /* jshint ignore:end */
            /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))

        /***/ },
    /* 5 */
    /***/ function(module, exports) {

        module.exports = function(module) {
            if(!module.webpackPolyfill) {
                module.deprecate = function() {};
                module.paths = [];
                // module.parent = undefined by default
                module.children = [];
                module.webpackPolyfill = 1;
            }
            return module;
        }


        /***/ },
    /* 6 */
    /***/ function(module, exports) {

        module.exports = function() { throw new Error("define cannot be used indirect"); };


        /***/ },
    /* 7 */
    /***/ function(module, exports, __webpack_require__) {

        var Html5PlayerObj = __webpack_require__(8);//html5 player framework
        var Html5IosPlayerObj = __webpack_require__(13);//iOS inline video player framework
        var FlashPlayerObj = __webpack_require__(19);
        var VideoSizeHandler = __webpack_require__(20);


        var prefixOfLog = "PlayerManager_BuildPlayer";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(message, prefixOfLog);
        };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };

        var buildPlayer = function (_callbackForAdUnit, _options, playerManager) {


            debug("buildPlayer");
            var triggerCheckingMouseLeave;

            //join parameter and object in outside of this object
            var options = _options;

            var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);

            var isMobile = function () {
                var index = navigator.appVersion.indexOf("Mobile");
                var indexForAndroid = navigator.appVersion.indexOf("Android");
                return (index > -1) || (indexForAndroid > -1);
            };

            var isIOS = function () {
                var indexForIOS = /iPad|iPhone|iPod/.test(navigator.appVersion);
                return indexForIOS;
            };


            //define and set default options by parameters
            var setDefaultOptions = function (_options) {

                _options.nativeControlsForTouch = false;
                _options.controls = true;
                _options.preload = "auto";

                if (!_options.extensions) {
                    _options.extensions = '';
                }

                VideoSizeHandler.setSizeForInitialRender(_options);


                if (isIOS()) {
                    if (_options.sideStream && _options.sideStream.enabled === false) {//side options should be allowed for iOS
                        _options.nonViewableBehavior = "pause";
                    }
                }

                switch (_options.initialPlayback) {
                    case "auto":
                        _options.autoplay = false;
                        break;
                    case "click":
                        _options.autoplay = false;
                        break;
                    case "mouseover":
                        _options.autoplay = false;
                        break;
                    default:

                }

                if (!_options.hasOwnProperty("disableTopBar")) {
                    _options.disableTopBar = false;
                }

                //define communicator with flash
                _options.communicator = playerManager.externalNameOfVideoPlayer;


                return _options;
            };


            //set required default value
            options = setDefaultOptions(options);

            if (options.initialAudio === "off") {
                playerManager.isMuted = true;
            }

            //set default swf if it doesn't have
            options.flash = options.flash ? options.flash : {swf: "http://video.devnxs.net/players/flash/AppnexusFlashPlayer.swf"};


            playerManager.options = options;


            //callback for inject event to player : player should returen element of itself
            var cbInjectEventToPlayer = function (el_wholeArea, el_videoArea) {


                //set playOnMouseover
                if (options.playOnMouseover === true) {

                    var _tmpMouseoverListenerForce = function () {
                        if (playerManager.isDoneInitialPlay === true && !playerManager.explicitPaused && playerManager.isViewable && playerManager.isPlayingVideo === false) {
                            playerManager.play();
                        }
                    };
                    var _tmpMouseOutListenerForce = function () {
                        playerManager.pause();
                    };
                    el_wholeArea.addEventListener("mouseenter", _tmpMouseoverListenerForce);
                    el_wholeArea.addEventListener("mouseleave", _tmpMouseOutListenerForce);

                }

                //set audioOnMouseover
                if (options.audioOnMouseover !== false) {
                    var unmuteTimeout = 0;
                    var unmuteTimeoutFn;
                    if (typeof options.audioOnMouseover === "number") {
                        unmuteTimeout = options.audioOnMouseover;
                    }

                    var _tmpMouseoutListenerForceAudio = function () {
                        if (!playerManager.isFullscreen && playerManager.isDoneInitialPlay) {
                            clearTimeout(unmuteTimeoutFn);
                            playerManager.mute();
                            el_wholeArea.removeEventListener("mouseleave", _tmpMouseoutListenerForceAudio);
                        }
                    };

                    var _tmpMouseoverListenerForceAudio = function () {
                        if (!playerManager.isFullscreen && playerManager.isDoneInitialPlay && !playerManager.mutedByViewability) {
                            unmuteTimeoutFn = setTimeout(function () {
                                playerManager.unmute();
                            }, unmuteTimeout);
                        }
                        el_wholeArea.addEventListener("mouseleave", _tmpMouseoutListenerForceAudio, false);
                    };


                    //this shouldn't be invoked when it's iOS because it doesn't have mouse(for some reason, browsing out will cause mouseenter event in mobile Safari browser)
                    if (!isIosInlineRequired()) {

                        triggerCheckingMouseLeave = setInterval(function () {
                            if (playerManager && playerManager.isFullscreen && _tmpMouseoutListenerForceAudio && el_wholeArea) {
                                el_wholeArea.removeEventListener("mouseleave", _tmpMouseoutListenerForceAudio);
                            }
                        }, 500);

                        el_wholeArea.addEventListener("mouseenter", _tmpMouseoverListenerForceAudio, false);
                    }
                }

                //set resposive behavior on desktop for VID-1080
                //mobile already has this feature so we handles it only for desktop
                //also this should work for VID3 and VID2
                //special case : if autoInitialSize is false and a width doesn't have a value then a behavior of this will work like autoInitialSize=true, this case is declared at ExtendDefaultOption.js
                if (options.autoInitialSize && !isMobile()) {
                    window.addEventListener("resize", function () {

                        //for VID-1898 going to fullscreen on flash caused window resize on several OS, and it can interfere with CSS of outstreae like sidestream case, also it actually makes sense to not resize video if it's in fullscreen on Flash
                        //as a result if sideStream is enabled we don't need to resize video by window.resize event.
                        var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStreamObject && typeof(playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
                        if (shouldNotResizeWhenSideStreamActivated) {
                            return;
                        }


                        if (options.targetElement && options.targetElement.style && options.targetElement.style.height && Number(options.targetElement.style.height.replace("px", "")) === 0) {//returns only when collapse for VID-2149
                            //initial target element height : 0.1px which is required to avoid the blocking flash on chrome.
                            //target element height after collsapse : 0px
                            return;//don't need to resize if video is already collapsed
                        }

                        setTimeout(function () {
                            if (!options.disableCollapse && (playerManager.isSkipped || playerManager.isCompleted)) {
                                return;
                            }
                            options.width = options.targetElement.offsetWidth;

                            var isAndroid = (/android/i.test(navigator.userAgent.toLowerCase()));
                            if (isAndroid) {
                                //for android4
                                options.targetElement.style.webkitTransition = "height 0s ease";
                            } else {
                                //for most of modern browser
                                options.targetElement.style.transition = "height 0s ease";
                            }

                            playerManager.resizeVideo(-1);
                            options.targetElement.style.height = options.height + "px";
                            var videoObject = document.getElementById(playerManager.videoObjectId);
                            if (videoObject && typeof videoObject !== undefined) {
                                videoObject.style.width = options.width;
                                videoObject.style.height = options.height;
                            }

                            setTimeout(function () {
                                var convertToSeconds = function (ms) {
                                    if (ms < 0) {
                                        return 0;
                                    }
                                    return ms / 1000;
                                };
                                var animationSpeed = convertToSeconds(options.expandTime);
                                animationSpeed = (animationSpeed <= 0) ? 0.001 : animationSpeed;//because if it's under zero, transitionEnd event is not reliable
                                if (isAndroid) {
                                    //for android4
                                    options.targetElement.style.webkitTransition = "height " + animationSpeed + "s ease";
                                } else {
                                    //for most of modern browser
                                    options.targetElement.style.transition = "height " + animationSpeed + "s ease";
                                }
                            }, 500);


                        }, 0);//we have to use this timer to avoid timing issue on Safari

                    });
                }


                if (playerManager.decidePlayer(options.requiredPlayer) === 'flash') {

                    el_wholeArea.addEventListener("mouseenter", function () {
                        playerManager.mouseIn();
                    });
                    el_wholeArea.addEventListener("mouseleave", function () {
                        playerManager.mouseOut();
                    });

                }

                //define click event
                el_wholeArea.style.cursor = "pointer";

                if (el_videoArea && el_videoArea !== undefined) {

                    //handle click to browse out
                    el_videoArea.onclick = function () {

                        // For JS VPAID Ads rely on AdClickThru event sent by the creative.
                        if (playerManager.decidePlayer(options.requiredPlayer) === "html5" && !options.vpaid) {
                            playerManager.click();
                        }
                    };
                }


                //for VID-2742 some of elements which are not used for native player now has interfered with proper rendering on iOS10 and small devices
                //it may be a bug on iOS10 because iOS8 and iOS9 doesn't have this problem. this is for VID-2742

                var hasCustomPlayerSkin = playerManager.options && playerManager.options.playerSkin && playerManager.options.playerSkin.customPlayerSkin;
                if (isIOS() && playerManager.overlayPlayer && playerManager.options && playerManager.options.enableInlineVideoForIos === false && hasCustomPlayerSkin) {

                    playerManager.adVideoPlayer.controlBar.fullscreenToggle.dispose();

                    //experemental to improve more for resolving 1px moving up
                    //why this required? : even if we performed above remedy, video is still moving about 1px up so we have to re-render conrolbar where has critical part caused this issue.
                    playerManager.adVideoPlayer.one("playing",function() {//only one time! - this issue hapens only first time when we play the video, so no need to do again
                        playerManager.adVideoPlayer.controlBar.el().style.display = "none";//for re-drawing element
                        setTimeout(function() {
                            playerManager.adVideoPlayer.controlBar.el().style.display = "block";//for re-drawing element
                        },7000);//7000ms is the time iOS10 re-renders (moving element up) after playing a video for some unknown reason on the browser
                    });
                }
            };


            switch (playerManager.decidePlayer(options.requiredPlayer)) {
                case "html5":
                    //activate new inline video for iOS if only "enableInlineVideoForIos" is true
                    if (isIosInlineRequired()) {
                        new Html5IosPlayerObj(playerManager, cbInjectEventToPlayer).start();
                    } else {
                        new Html5PlayerObj(playerManager, cbInjectEventToPlayer).start();
                    }
                    break;
                case "flash":
                    FlashPlayerObj(playerManager, cbInjectEventToPlayer);
                    break;
                default:
            }






        };


        module.exports = buildPlayer;

        /***/ },
    /* 8 */
    /***/ function(module, exports, __webpack_require__) {

        //declare module
        var utils = __webpack_require__(9);
        var _logger = __webpack_require__(2);

        var info = function (message) {
            _logger.info("Video Player: " + message);
        };

        /**
         * Html5Player
         * At the end of this process, it will invoke "callbackForAdUnit.cbWhenReady" to continute a flow of video player this is asynchoronous action and Outstream will wait this callback to start doing something (expanding...)
         * @param playerManager
         * @param cbInjectEventToPlayer
         */
        module.exports = function (playerManager, cbInjectEventToPlayer) {

            var html5PlayerSelf = this;

            this.options = playerManager.options;//getting required object from adVideoPlayerManager
            this.an_video_ad_player_id = "";
            this.an_video_ad_player_html5_api_id = "";
            this.targetElement = "";
            this.videojsOrigin = playerManager.videoPlayerObj;
            this.dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
            this.callbackForAdUnit = playerManager.callbackForAdUnit;
            this.topChromeHeight = 24;
            this.pendingFullscreenExit = false;//there is a 1000ms timeout between pressing the exit fullscreen icon and the status being updated in the player,mthis variable will let us know this is the case, since a lot happens in those ms
            this.bigbuttonUnmuteTimeout = 250; // videojs takes a while to sync mute, so we wait 250ms for safari
            this.CONST_MESSAGE_GENERAL_ERROR = "General error reported from HTML5 video player";//const variables

            //redefine utitlity function to have backward compatibility
            this.isIos = utils.isIos;
            this.isAndroid = utils.isAndroid;
            this.isMobile = utils.isMobile;
            this.refreshVideoLookAndFeel = utils.refreshVideoLookAndFeel;


            this.start = function () {
                info("WE ARE USING HTML5 PLAYER");
                var UID = new Date().getTime() + Math.floor(Math.random() * 10000);//define iframe's uniqueu id

                //override options
                html5PlayerSelf.options.techOrder = ["html5"];//force to use html5 for video.js because flash will be handled by diffrent swf owned by us
                html5PlayerSelf.options.iframeVideoWrapperId = "iframeVideoWrapper_" + UID;

                //set flasg
                html5PlayerSelf.an_video_ad_player_id = "an_video_ad_player_" + UID;
                html5PlayerSelf.an_video_ad_player_html5_api_id = "an_video_ad_player_" + UID + "_html5_api";
                html5PlayerSelf.targetElement = html5PlayerSelf.options.targetElement;

                html5PlayerSelf.createIframe(html5PlayerSelf.fnMainProcess);//execute main process after create iframe
            };
            this.displayVolumeControls = function () {
                if (html5PlayerSelf.isAndroid()) {
                    if (typeof html5PlayerSelf.options.enableAndroidVolumeControls === "boolean" && html5PlayerSelf.options.enableAndroidVolumeControls === true) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return true;
                }
            };

            this.createIframe = __webpack_require__(10)(html5PlayerSelf,playerManager).createIframe;
            this.fnMainProcess = __webpack_require__(11)(html5PlayerSelf,playerManager,cbInjectEventToPlayer).fnMainProcess;

        };



        /***/ },
    /* 9 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Utility class
         */

        var prefixOfLog = "PlayerManager_Utils";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(message, prefixOfLog);
        };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };


        var isIphone = function () {
            var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        };

        var isIos = function () {
            var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        };

        var isAndroid = function () {
            return (/android/i.test(navigator.userAgent.toLowerCase()));
        };

        var isMobile = function () {
            return navigator.appVersion.indexOf("Mobile") > -1 || navigator.appVersion.indexOf("Android") > -1;
        };

        var getIOSVersion = function() {
            var match =navigator.userAgent.match(/OS (\d+)_/i);
            if (match && match[1]) {
                return match[1];
            }
        };

        var refreshVideoLookAndFeel = function (options, playerManager) {

            if (playerManager.isSkipped || !playerManager.isExpanded) {
                return;
            }

            if (options.autoInitialSize) {
                options.width = options.targetElement.offsetWidth;
            }
            playerManager.resizeVideo(-1, isMobile());
            options.targetElement.style.height = options.height + "px";
        };


        var fireEvent = function (obj, eventName) {
            var event = document.createEvent("HTMLEvents");
            event.initEvent(eventName, true, true);
            event.eventName = eventName;
            obj.dispatchEvent(event);
        };


        //rules regards VID-1529
        /*
         1.Callback(VAST) : should suppress all callback related to tracking
         2.Callback(VPAID) : don't suppress followings (which is not related to tracking or report in VAST)
         AdLoaded
         AdStarted
         AdStopped
         AdSkippableStateChange
         AdLinearChange
         AdDurationChange
         AdRemainingTimeChange
         AdLog
         AdError
         3.Callback(AdUnit) : don't suppressed
         4.Tracking url : should suppress
         5.eventCB for AST : don't suppressed
         */
        /**
         * Utility class for handling late invoking, orignally made for VID-1505
         * structure : FIFO (First in - First out)
         * @constructor
         */
        var DelayEventHandler = function () {
            this.queue = [];
            this.id = "";
            this.isSuppress = false;
            this.isPaused = false;
            this.isCompleted = false;

            var timerInterval = 100;
            var ignoreNextQueue = false;

            /**
             * push function or event
             * @param cb
             */
            this.push = function (cb) {

                if (this.isSuppress === false && typeof cb === 'function') {
                    cb();
                    return;
                }

                if (ignoreNextQueue) {
                    ignoreNextQueue = false;//TODO can occur concurrent issue but it's okay for usage of JSVPAIDConfigure.js
                    return;
                }

                if (this.isPaused === false) {
                    this.queue.push(cb);
                }
            };

            /**
             * start timer to consume this queue
             */
            this.start = function () {
                debug("delay event starts");
                var delayEventHandler = this;
                var pullAndInvoke = function () {
                    if (delayEventHandler.isSuppress === false) {
                        var cb = delayEventHandler.queue.shift();
                        if (cb && typeof(cb) === "function") {
                            cb();
                        }
                    }
                    setTimeout(function () {
                        if (delayEventHandler.isCompleted === false) {
                            pullAndInvoke();//recursion until video is completed
                        }
                    }, timerInterval);
                };
                pullAndInvoke();
            };

            /**
             * Immediate stop the timer
             * @constructor
             */
            this.ImmediateStop = function () {
                this.isCompleted = true;
            };

            /**
             * push a function to stop the timer, the timer will stop when it's order
             */
            this.lazyTerminate = function () {
                var delayEventHandler = this;
                var cb = function () {
                    delayEventHandler.ImmediateStop();
                };
                this.queue.push(cb);
            };

            /**
             * method to release suppressed functions or events
             * @param o
             */
            this.suppress = function (o) {
                this.isSuppress = o;
            };

            /**
             * clear queue for Waterfall project
             */
            this.clearQueue = function () {
                this.queue = [];
            };

            this.ignoreNextQueue = function () {
                ignoreNextQueue = true;
            };
        };


        var isEmpty = function (obj) {
            return (typeof(obj) === "undefined" || obj === "" || obj === false || obj === null) ? true : false;
        };

        var unique = function () {
            var uniqueObject = {};//clousure, uniqueObject in sub function will point this in runtime
            return {
                pushAndCheck: function (key_, str_) {
                    var key = key_ + "_" + str_;
                    if (!uniqueObject[key]) {
                        uniqueObject[key] = true;
                        return true;
                    } else {
                        return false;
                    }
                }
            };
        };


        module.exports = {
            isIphone: isIphone,
            isIos: isIos,
            isAndroid: isAndroid,
            isMobile: isMobile,
            getIOSVersion: getIOSVersion,
            refreshVideoLookAndFeel: refreshVideoLookAndFeel,
            fireEvent: fireEvent,
            DelayEventHandler: DelayEventHandler,
            isEmpty: isEmpty,
            unique: unique
        };




        /***/ },
    /* 10 */
    /***/ function(module, exports, __webpack_require__) {

        var _logger = __webpack_require__(2);
        var log = function (message) {
            _logger.log("Video Player: " + message);
        };
        var debug = function (message) {
            _logger.debug("Video Player: " + message);
        };
        var verbose = function (message) {
            _logger.verbose("Video Player: " + message);
        };

        /**
         * InitializeElements
         * @param html5PlayerSelf
         * @param playerManager
         * @returns {{createIframe: "createIframe"}}
         */
        module.exports = function (html5PlayerSelf, playerManager) {

            return {
                "createIframe": function (callback) {

                    log("createIframe");

                    var iframeVideoWrapper;
                    var found = false;

                    if (playerManager.mobileSupport.isRequiredFakeAndroidAutoStart(html5PlayerSelf.options)) {
                        verbose("Setting correct iframe for androids 'fake' autostart");
                        var iframes = html5PlayerSelf.options.targetElement.getElementsByTagName("iframe");
                        for (var i = 0; i < iframes.length; i++) {
                            var iframe = iframes[i];
                            var name = playerManager.mobileSupport.APN_OUTSTREAM_IFRAME_NAME;
                            if (html5PlayerSelf.isAndroid() && html5PlayerSelf.options.firstAdAttempted && html5PlayerSelf.options.adAttempt) {
                                name = playerManager.mobileSupport.APN_OUTSTREAM_IFRAME_NAME + "_Waterfall_" + html5PlayerSelf.options.adAttempt;
                            }
                            if (iframes && iframe.name && iframe.name === name) {
                                found = true;
                                iframeVideoWrapper = iframe;
                                break;
                            }
                        }
                    }

                    if (!found) {
                        verbose("Creating new iframe if one is not already created.");
                        iframeVideoWrapper = document.createElement("iframe");
                        iframeVideoWrapper.src = "about:blank";
                        html5PlayerSelf.targetElement.appendChild(iframeVideoWrapper);
                    }

                    //generate iframe
                    iframeVideoWrapper.id = html5PlayerSelf.options.iframeVideoWrapperId;
                    iframeVideoWrapper.style.width = html5PlayerSelf.options.width + "px";
                    iframeVideoWrapper.style.height = html5PlayerSelf.options.height + "px";
                    iframeVideoWrapper.style.display = "";
                    //TODO: maybe set all of these to initial, but IE does not support so maybe not
                    //iframeVideoWrapper.id = "iframeVideoWrapper";

                    //allow fullscreen in iframe
                    iframeVideoWrapper.setAttribute("allowfullscreen", "true");
                    iframeVideoWrapper.setAttribute("webkitallowfullscreen", "true");
                    iframeVideoWrapper.setAttribute("mozallowfullscreen", "true");

                    var handleCallback = function () {

                        var IframeDocument = iframeVideoWrapper.contentWindow.document;
                        var IframeWindow = iframeVideoWrapper.contentWindow.window;


                        //create top chrome bar
                        debug("Creating and styling top chrome bar");
                        var topChrome = IframeDocument.createElement("div");
                        topChrome.id = "top_chrome";
                        topChrome.style.height = (function () {
                            if (html5PlayerSelf.options.playerSkin && typeof html5PlayerSelf.options.playerSkin.dividerHeight === "number") {
                                return html5PlayerSelf.topChromeHeight - html5PlayerSelf.options.playerSkin.dividerHeight + "px";
                            }
                            // in order to keep the top chrome 24 px, we subtract the width of the divider
                            // (default of 1px) from the height of the chrome bar
                            return html5PlayerSelf.topChromeHeight - 1 + "px";
                        })();
                        topChrome.style.width = html5PlayerSelf.options.width + "px";
                        topChrome.style.marginRight = "auto";
                        topChrome.style.marginLeft = "auto";
                        topChrome.className = "video-js vjs-default-skin";

                        //generate video object
                        debug("Generating and styling video object");
                        var videoEl;
                        var found = false;

                        if (playerManager.mobileSupport.isRequiredFakeAndroidAutoStart(html5PlayerSelf.options)) {

                            var prebuiltVideo = iframeVideoWrapper.contentWindow[playerManager.mobileSupport.APN_OUTSTREAM_VIDEO_PLACEMENT_ID];
                            if (prebuiltVideo) {
                                found = true;
                                videoEl = prebuiltVideo;//override video object to resolve autoplay issue on Android
                            }

                        }

                        if (!found) {
                            videoEl = IframeDocument.createElement("video");
                        }

                        videoEl.id = html5PlayerSelf.an_video_ad_player_id;
                        videoEl.className = "video-js vjs-default-skin";
                        videoEl.style.marginRight = "auto";
                        videoEl.style.marginLeft = "auto";

                        topChrome.style["z-index"] = videoEl.style["z-index"] + 1;


                        //add condtition to figure out video.js problem in high latency network - video.js doesn't load video in high latency netowrk if we pass this source so that setting src should be done after video.js initalized
                        //generate source object
                        if (html5PlayerSelf.options.vpaid === false) {
                            debug("Generating source object");
                            var mp4Source = IframeDocument.createElement("source");
                            //mp4Source.type = html5PlayerSelf.options.video.type;
                            //mp4Source.src = html5PlayerSelf.options.videoUrl;

                            mp4Source.src = "http://v.adsrvr.org/tdpartnerid/cxpowqgj/r17axcdp.webm";
                            if (!html5PlayerSelf.options.vpaid) {
                                videoEl.appendChild(mp4Source);
                            }
                        }


                        //inject required object into iframe
                        debug("Injecting required elements into iframe");
                        if (!html5PlayerSelf.options.disableTopBar) {
                            IframeDocument.body.appendChild(topChrome);
                            //topChrome.appendChild(customDivider);
                        }

                        //custom skinning
                        playerManager.customSkinning.render(html5PlayerSelf,IframeDocument,false);

                        IframeDocument.body.appendChild(videoEl);
                        IframeWindow.videojs = html5PlayerSelf.videojsOrigin;

                        if (html5PlayerSelf.options.vpaid) {
                            //inject javascript vpaid module to iframe
                            var videojsVpaidScript = IframeDocument.createElement("script");
                            videojsVpaidScript.innerHTML = playerManager.videojs_vpaid;
                            IframeDocument.head.appendChild(videojsVpaidScript);
                        }


                        IframeDocument.body.style.margin = "0px";
                        IframeDocument.body.style.overflow = "hidden";
                        callback(iframeVideoWrapper);

                    };


                    var is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                    if (is_firefox) {
                        iframeVideoWrapper.onload = function () {
                            handleCallback();
                        };
                    } else {
                        handleCallback();
                    }

                },
            };
        };

        /***/ },
    /* 11 */
    /***/ function(module, exports, __webpack_require__) {

        //stop js-hint warning for dot notation
        /*jshint -W069 */

        var JSVPAIDConfigure = __webpack_require__(12);
        var _logger = __webpack_require__(2);

        var error = function(message) {
            _logger.error("Video Player: " + message);
        };
        var log = function (message) {
            _logger.log("Video Player: " + message);
        };
        var debug = function (message) {
            _logger.debug("Video Player: " + message);
        };
        var verbose = function (message) {
            _logger.verbose("Video Player: " + message);
        };

        /**
         * Events
         * @param html5PlayerSelf
         * @param playerManager
         * @param cbInjectEventToPlayer
         * @returns {{fnMainProcess: "fnMainProcess"}}
         */
        module.exports = function (html5PlayerSelf, playerManager, cbInjectEventToPlayer) {
            return {
                "fnMainProcess": function (iframeVideoWrapper) {
                    /**
                     * this method for customizing video.js player by its own API
                     * @param iframeVideoWrapper
                     */


                    log("fnMainProcess");

                    //video object in iframe
                    var an_html5_video_object = iframeVideoWrapper.contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
                    playerManager.iframeVideoWrapper = iframeVideoWrapper;


                    //activate JSVPAID plug-in this should be actiavated before video.js intialized
                    if (html5PlayerSelf.options.vpaid) {
                        try {
                            JSVPAIDConfigure(playerManager);
                        } catch (ex) {
                            error(ex);
                        }
                    } else {
                        //Cleanup previous plugin reference.
                        //VID-2023 Specific waterfall placement times out due to error on IE and Edge browsers on PC
                        if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.plugins) {
                            html5PlayerSelf.options.plugins = null;
                        }
                    }


                    var customizeVideoJS = function (videojsPlayer) {

                        debug("Customizing Video JS");

                        //TODO for debugging
                        // window.debugPlayerAN = videojsPlayer;
                        playerManager.adVideoPlayer = videojsPlayer;

                        html5PlayerSelf.options.nativeControlsForTouch = false;
                        html5PlayerSelf.options.customControlsOnMobile = false;

                        //TODO for researching mobile features
                        if (html5PlayerSelf.isMobile()) {
                            videojsPlayer.enableTouchActivity();
                        }

                        //setup html5 video player by html5PlayerSelf.options coming from impbus or publisher's site
                        (function () {

                            if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.vpaid) {
                                //For vpaid ads in waterfall hide controls untill the impression occurs to avoid flicker during failed attempts.
                                videojsPlayer.controlBar.hide();
                                if(html5PlayerSelf.options.firstAdAttempted){
                                    videojsPlayer.bigPlayButton.hide();
                                }
                            }

                            //disable scrubbing
                            verbose("disabling scrubbing");
                            videojsPlayer.controlBar.progressControl.seekBar.off("mousedown");
                            videojsPlayer.controlBar.progressControl.seekBar.off("touchstart");
                            videojsPlayer.controlBar.progressControl.seekBar.off("click");

                            verbose("setting initial audio");
                            if (html5PlayerSelf.options.initialAudio === "off") {
                                videojsPlayer.muted(true);
                                playerManager.isMuted = true;
                            } else {
                                videojsPlayer.muted(false);
                                playerManager.isMuted = false;
                            }
                            //set mouseover to play video option
                            verbose("setting initial playback");
                            if (html5PlayerSelf.options.initialPlayback === "mouseover") {

                                var _tmpMouseoverListener = function () {
                                    playerManager.play();
                                    videojsPlayer.el().removeEventListener("mouseover", _tmpMouseoverListener);
                                };
                                videojsPlayer.el().addEventListener("mouseover", _tmpMouseoverListener);
                            }

                            //set maintainAspectRatio
                            verbose("setting aspect ratio"); //this doesn't do anything, remove?
                            if (html5PlayerSelf.options.maintainAspectRatio === true) {
                            } else {
                            }

                            var isMuteNeeded = function () {
                                return (html5PlayerSelf.options.showMute === true && (html5PlayerSelf.displayVolumeControls() || html5PlayerSelf.isAndroid()));
                            };

                            //set showVolume
                            if (html5PlayerSelf.options.showVolume === false || !html5PlayerSelf.displayVolumeControls()) {
                                verbose("removing volume controls");
                                videojsPlayer.controlBar.volumeControl.dispose();
                            }

                            if (html5PlayerSelf.options.showPlayToggle === false) {
                                videojsPlayer.controlBar.playToggle.hide();
                            }

                            if (html5PlayerSelf.options.showBigPlayButton === false) {
                                videojsPlayer.bigPlayButton.hide();
                            }

                            //set showMute
                            if (isMuteNeeded()) {
                                verbose("setting mute functionality");
                                var muteHandler = function () {
                                    if (playerManager.isMuted) {
                                        if (videojsPlayer.volume() > 0) {
                                            playerManager.explicitUnmute();
                                        }
                                    } else {
                                        playerManager.explicitMute();
                                    }
                                };

                                //for browsers
                                videojsPlayer.controlBar.muteToggle.on("click", muteHandler);

                                //for devices
                                videojsPlayer.controlBar.muteToggle.on("touchend", muteHandler);
                            } else {
                                verbose("removing mute button");
                                videojsPlayer.controlBar.muteToggle.dispose();
                            }

                            //invoke mute

                            if (html5PlayerSelf.options.showVolume === true && html5PlayerSelf.displayVolumeControls()) {
                                videojsPlayer.controlBar.volumeControl.volumeBar.on("mousedown", function () {
                                    var volume = videojsPlayer.volume();
                                    if (volume <= 0 && !playerManager.isMuted) {
                                        verbose("muting from volume scrubber");
                                        playerManager.explicitMute();
                                    }
                                    if (volume > 0 && playerManager.isMuted) {
                                        verbose("unmuting from volume scrubber");
                                        playerManager.explicitUnmute();
                                    }
                                });
                            }

                            if (typeof html5PlayerSelf.options.customButton.enabled === "boolean" && html5PlayerSelf.options.customButton.enabled === true) {
                                var customButton = html5PlayerSelf.videojsOrigin.createEl('div', {
                                    'innerHTML': '<a href="'+html5PlayerSelf.options.customButton.url+'" target="_blank"><img style="height:'+html5PlayerSelf.options.customButton.imgHeight+'px;width:'+html5PlayerSelf.options.customButton.imgWidth+'px" class="home-button-image" src="'+html5PlayerSelf.options.customButton.imageSrc+'" alt="'+html5PlayerSelf.options.customButton.altText+'"></a>',
                                    'role': 'button',
                                    'aria-live': 'polite',
                                    'tabindex': '0'
                                });
                                customButton.style.cssText = "float:right;font-family:VideoJS;font-size:1.5em;line-height:2;width:50px;height:100%;text-align:center";
                                videojsPlayer.controlBar.addChild('button', {
                                    'el': customButton
                                });
                                videojsPlayer.controlBar.el().insertBefore(customButton, videojsPlayer.controlBar.fullscreenToggle.el());
                            }

                            //set showProgressBar
                            videojsPlayer.controlBar.progressControl.seekBar.seekHandle.hide();
                            videojsPlayer.controlBar.progressControl.seekBar.el_.style.pointerEvents = 'none';
                            if (typeof html5PlayerSelf.options.showProgressBar === "boolean") {
                                if (html5PlayerSelf.options.showProgressBar === false) {
                                    verbose("removing progress bar");
                                    videojsPlayer.controlBar.currentTimeDisplay.hide();
                                    videojsPlayer.controlBar.timeDivider.hide();
                                    videojsPlayer.controlBar.durationDisplay.hide();
                                }
                                videojsPlayer.controlBar.progressControl.seekBar.hide();
                            } else {
                                if (html5PlayerSelf.options.showProgressBar === "text") {
                                    verbose("removing progress text");
                                    videojsPlayer.controlBar.progressControl.seekBar.hide();
                                } else if (html5PlayerSelf.options.showProgressBar === "bar") {
                                    verbose("removing progress bar");
                                    videojsPlayer.controlBar.currentTimeDisplay.hide();
                                    videojsPlayer.controlBar.timeDivider.hide();
                                    videojsPlayer.controlBar.durationDisplay.hide();
                                }
                            }

                            //set allowFullscreen
                            if (html5PlayerSelf.options.allowFullscreen === false) {
                                verbose("removing fullscreen toggle");
                                videojsPlayer.controlBar.fullscreenToggle.el().style.visibility = "hidden";
                            }

                            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

                            debug("Creating top chrome buttons/text");
                            verbose("creating and styling ad indicator");
                            var adIndicatorText = iframeVideoWrapper.contentWindow.document.createElement("div");
                            adIndicatorText.id = "ad_indicator_text";

                            adIndicatorText.innerHTML = html5PlayerSelf.options.adText;
                            adIndicatorText.className = 'top-bar-text';
                            adIndicatorText.role = 'button';

                            adIndicatorText.style['text-align'] = "right";
                            adIndicatorText.style['margin-right'] = "1em";
                            adIndicatorText.style['margin-left'] = "1em";
                            adIndicatorText.style['font-size'] = "1em";
                            adIndicatorText.style['right'] = "0px";
                            adIndicatorText.style['left'] = "";
                            adIndicatorText.style['line-height'] = "24px";
                            adIndicatorText.style['outline'] = "0";
                            adIndicatorText.style['position'] = "absolute";
                            adIndicatorText.style['padding'] = "0";
                            adIndicatorText.style['height'] = "auto";
                            adIndicatorText.style['width'] = "auto";
                            adIndicatorText.style['max-width'] = "35%";
                            adIndicatorText.style['white-space'] = "nowrap";
                            adIndicatorText.style['overflow'] = "hidden";
                            adIndicatorText.style['text-overflow'] = "ellipsis";
                            adIndicatorText.style['pointer-events'] = "none";

                            var floatingAdIndicator = html5PlayerSelf.videojsOrigin.createEl('div', {
                                'role': 'button',
                                'innerHTML': html5PlayerSelf.options.adText,
                                'className': "top-bar-text"
                            });
                            var floatingSkipButton;
                            var floatingAdSkipText;
                            var readyForSkip = false;

                            floatingAdIndicator.style['text-align'] = "right";
                            floatingAdIndicator.style['margin-right'] = "1em";
                            floatingAdIndicator.style['margin-left'] = "1em";
                            floatingAdIndicator.style['font-size'] = "1em";
                            floatingAdIndicator.style['right'] = "0px";
                            floatingAdIndicator.style['left'] = "";
                            floatingAdIndicator.style['line-height'] = "3em";
                            floatingAdIndicator.style['outline'] = "0";
                            floatingAdIndicator.style['position'] = "absolute";
                            floatingAdIndicator.style['padding'] = "0";
                            floatingAdIndicator.style['height'] = "3em";
                            floatingAdIndicator.style['max-width'] = "35%";
                            floatingAdIndicator.style['width'] = "auto";
                            floatingAdIndicator.style['text-overflow'] = "ellipsis";
                            floatingAdIndicator.style['white-space'] = "nowrap";
                            floatingAdIndicator.style['overflow'] = "hidden";
                            floatingAdIndicator.style['pointer-events'] = "none";
                            floatingAdIndicator.style['display'] = "none";

                            videojsPlayer.addChild('button', {
                                'el': floatingAdIndicator
                            });

                            var skipButton;
                            var adSkipText;
                            //set skip button
                            if (html5PlayerSelf.options.skippable.enabled === true) {
                                verbose("creating and styling skip buttons and skip texts");

                                var videoThreshold = html5PlayerSelf.options.skippable.videoThreshold;
                                var skipText = html5PlayerSelf.options.skippable.skipText;
                                var skipButtonText = html5PlayerSelf.options.skippable.skipButtonText;

                                skipButton = iframeVideoWrapper.contentWindow.document.createElement("div");
                                skipButton.id = "skip_button";

                                skipButton.innerHTML = skipButtonText;
                                skipButton.className = 'top-bar-text';
                                skipButton.role = 'button';

                                skipButton.style['display'] = "none";
                                skipButton.style['cursor'] = "pointer";
                                skipButton.style['font-weight'] = "bold";
                                skipButton.style['margin-right'] = "1em";
                                skipButton.style['margin-left'] = "1em";
                                skipButton.style['font-size'] = "1em";
                                skipButton.style['right'] = "";
                                skipButton.style['left'] = "0px";
                                skipButton.style['line-height'] = "24px";
                                skipButton.style['outline'] = "0";
                                skipButton.style['position'] = "absolute";
                                skipButton.style['padding'] = "0";
                                skipButton.style['height'] = "5em";
                                skipButton.style['width'] = "auto";
                                skipButton.style['min-width'] = "5em";
                                skipButton.style['text-align'] = "left";

                                //skip button
                                floatingSkipButton = html5PlayerSelf.videojsOrigin.createEl('div', {
                                    'className': 'top-bar-text',
                                    'role': 'button',
                                    'innerHTML': skipButtonText
                                });

                                floatingSkipButton.style['display'] = "none";
                                floatingSkipButton.style['cursor'] = "pointer";
                                floatingSkipButton.style['font-weight'] = "bold";
                                floatingSkipButton.style['margin-right'] = "1em";
                                floatingSkipButton.style['margin-left'] = "1em";
                                floatingSkipButton.style['font-size'] = "1em";
                                floatingSkipButton.style['right'] = "";
                                floatingSkipButton.style['left'] = "0px";
                                floatingSkipButton.style['line-height'] = "3em";
                                floatingSkipButton.style['outline'] = "0";
                                floatingSkipButton.style['position'] = "absolute";
                                floatingSkipButton.style['padding'] = "0";
                                floatingSkipButton.style['height'] = "5em";
                                floatingSkipButton.style['min-width'] = "5em";
                                floatingSkipButton.style['width'] = "auto";
                                floatingSkipButton.style['display'] = "none";
                                floatingSkipButton.style['text-align'] = "left";

                                videojsPlayer.addChild('button', {
                                    'el': floatingSkipButton
                                });

                                var skipHandler = function (e) {
                                    debug("SKIP clicked, destroying player");
                                    // Must call this *before* setting isCompleted flag for skip tracking events to be sent
                                    playerManager.destroy();

                                    if (html5PlayerSelf.isMobile()) {
                                        e.stopPropagation();
                                        e.preventDefault(); // prevents a touch event from also triggering a click event
                                        playerManager.isCompleted = true;//added for VID-1047
                                    }
                                };

                                if (html5PlayerSelf.isMobile()) {
                                    skipButton.addEventListener("touchend", skipHandler);
                                    floatingSkipButton.addEventListener("touchend", skipHandler);
                                    floatingSkipButton.addEventListener("mousedown", function (e) {
                                        e.preventDefault();
                                    });
                                }

                                skipButton.addEventListener("click", skipHandler);
                                floatingSkipButton.addEventListener("click", skipHandler);

                                //skip text
                                floatingAdSkipText = html5PlayerSelf.videojsOrigin.createEl('div', {
                                    'className': 'top-bar-text',
                                    'role': 'button',
                                    'innerHTML': ""
                                });

                                floatingAdSkipText.style['margin-left'] = "1em";
                                floatingAdSkipText.style['margin-right'] = "1em";
                                floatingAdSkipText.style['right'] = "";
                                floatingAdSkipText.style['left'] = "0px";
                                floatingAdSkipText.style['font-size'] = "1em";
                                floatingAdSkipText.style['line-height'] = "3em";
                                floatingAdSkipText.style['outline'] = "0";
                                floatingAdSkipText.style['position'] = "absolute";
                                floatingAdSkipText.style['text-align'] = "left";
                                floatingAdSkipText.style['padding'] = "0";
                                floatingAdSkipText.style['height'] = "3em";
                                floatingAdSkipText.style['width'] = "auto";
                                floatingAdSkipText.style['pointer-events'] = "none";
                                floatingAdSkipText.style['display'] = "none";

                                videojsPlayer.addChild('button', {
                                    'el': floatingAdSkipText
                                });

                                //skip text
                                adSkipText = iframeVideoWrapper.contentWindow.document.createElement("div");
                                adSkipText.id = "ad_skip_text";

                                adSkipText.innerHTML = skipButtonText;
                                adSkipText.className = 'top-bar-text';
                                adSkipText.role = 'button';

                                adSkipText.style['margin-left'] = "1em";
                                adSkipText.style['margin-right'] = "1em";
                                adSkipText.style['right'] = "";
                                adSkipText.style['left'] = "0px";
                                adSkipText.style['font-size'] = "1em";
                                adSkipText.style['line-height'] = "24px";
                                adSkipText.style['outline'] = "0";
                                adSkipText.style['position'] = "absolute";
                                adSkipText.style['text-align'] = "left";
                                adSkipText.style['padding'] = "0";
                                adSkipText.style['height'] = "3em";
                                adSkipText.style['width'] = "auto";
                                adSkipText.style['pointer-events'] = "none";
                                adSkipText.style['display'] = "none";

                                //switch position by option
                                switch (html5PlayerSelf.options.skippable.skipLocation) {
                                    case "top-right":
                                        skipButton.style['right'] = "0px";
                                        skipButton.style['left'] = "";
                                        skipButton.style['text-align'] = "right";

                                        adSkipText.style['right'] = "0px";
                                        adSkipText.style['left'] = "";

                                        floatingSkipButton.style['right'] = "0px";
                                        floatingSkipButton.style['left'] = "";
                                        floatingSkipButton.style['text-align'] = "right";

                                        floatingAdSkipText.style['right'] = "0px";
                                        floatingAdSkipText.style['left'] = "";
                                        break;
                                    default :
                                        break;
                                }

                                //quartile status to invoke only once
                                var quartile1status = false;
                                var quartile2status = false;
                                var quartile3status = false;

                                //handle tick event from video.js
                                videojsPlayer.on("timeupdate", function () {
                                    if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.vpaid && !html5PlayerSelf.options.vpaidImpressionFired) {
                                        return;
                                    }
                                    var currentTime = Math.round(videojsPlayer.player().currentTime());
                                    var offsetTime = html5PlayerSelf.options.skippable.videoOffset;
                                    var remainTime = offsetTime - currentTime;
                                    var videoDuration = Math.round(videojsPlayer.player().duration());

                                    if (videoThreshold <= videoDuration && !html5PlayerSelf.options.disableTopBar) {
                                        if (remainTime > 0) {
                                            floatingAdSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
                                            adSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);

                                            adSkipText.style.display = "block";
                                            skipButton.style.display = "none";

                                        } else {
                                            readyForSkip = true;

                                            if (playerManager.isFullscreen && !html5PlayerSelf.pendingFullscreenExit) {
                                                floatingAdSkipText.style.display = "none";
                                                floatingSkipButton.style.display = "block";
                                            }

                                            adSkipText.style.display = "none";
                                            skipButton.style.display = "block";
                                        }
                                    }
                                });
                            }

                            //switch position by option
                            if (html5PlayerSelf.options.skippable && html5PlayerSelf.options.skippable.skipLocation) {
                                switch (html5PlayerSelf.options.skippable.skipLocation) {
                                    case "top-right":
                                        adIndicatorText.style['right'] = "";
                                        adIndicatorText.style['left'] = "0px";

                                        floatingAdIndicator.style['right'] = "";
                                        floatingAdIndicator.style['left'] = "0px";
                                        break;
                                    default :
                                        break;
                                }
                            }

                            if (!html5PlayerSelf.options.disableTopBar && topChrome) {
                                if (html5PlayerSelf.options.skippable.enabled === true) {
                                    topChrome.appendChild(skipButton);
                                    topChrome.appendChild(adSkipText);
                                }
                                topChrome.appendChild(adIndicatorText);
                            }

                            //set quartile event
                            videojsPlayer.on("timeupdate", function () {
                                if (html5PlayerSelf.options.vpaid) {
                                    return;
                                }
                                var currentTime = Math.round(videojsPlayer.player().currentTime());
                                var videoDuration = videojsPlayer.player().duration();
                                if (!videoDuration) {
                                    return;
                                }
                                var quartile1 = videoDuration / 4;
                                var quartile2 = videoDuration / 4 * 2;
                                var quartile3 = videoDuration / 4 * 3;


                                if (!quartile1status && currentTime >= quartile1 && currentTime < quartile2) {
                                    html5PlayerSelf.dispatchEventToAdunit({"name": "video-first-quartile"});
                                    quartile1status = true;
                                }

                                if (!quartile2status && currentTime >= quartile2 && currentTime < quartile3) {
                                    html5PlayerSelf.dispatchEventToAdunit({"name": "video-mid"});
                                    quartile2status = true;
                                }

                                if (!quartile3status && currentTime >= quartile3) {
                                    html5PlayerSelf.dispatchEventToAdunit({"name": "video-third-quartile"});
                                    quartile3status = true;
                                }
                            });

                            //set explictPaused
                            videojsPlayer.controlBar.playToggle.on("click", function () {
                                verbose("play button click");
                                playerManager.explicitPaused = !playerManager.explicitPaused;
                            });

                            //set explictPaused
                            videojsPlayer.controlBar.playToggle.on("touchend", function () {
                                verbose("play button touchend");
                                playerManager.explicitPaused = !playerManager.explicitPaused;
                            });

                            //set destroy event
                            videojsPlayer.on("ended", function () {
                                var callbackFunctionAfterVideoComplete = function () {
                                    verbose("hiding control bar and big play button");
                                    var _controlBar = videojsPlayer.controlBar;
                                    if (_controlBar.currentTimeDisplay) {_controlBar.currentTimeDisplay.hide();}
                                    if (_controlBar.durationDisplay) {_controlBar.durationDisplay.hide();}
                                    if (_controlBar.timeDivider) {_controlBar.timeDivider.hide();}
                                    if (_controlBar.muteToggle) {_controlBar.muteToggle.hide();}
                                    if (_controlBar.playToggle) {_controlBar.playToggle.hide();}
                                    if (_controlBar.fullscreenToggle) {_controlBar.fullscreenToggle.hide();}
                                    if (_controlBar.progressControl) {_controlBar.progressControl.hide();}
                                    if (_controlBar.volumeControl) {_controlBar.volumeControl.hide();}
                                    videojsPlayer.bigPlayButton.hide();

                                    //destroyWithoutSkip should invoke only one time, seconds time will be igonored by existing rules
                                    //for that reason if disableCollapse is true, there will be second chance to invoke destroyWithoutSkip() when user click "skip" button
                                    //so following condition is required
                                    if (!html5PlayerSelf.options.disableCollapse) {
                                        playerManager.isSkipped = true;//this flag should set for VID-1885, and if disableCollapse is false and video complete means skip, we have to set isSkipped to true.
                                        playerManager.destroyWithoutSkip();//this actual termination logic should be invoked after video_complete triggered. so this callbackFunctionAfterVideoComplete is being passed into eventHandling logic
                                    }

                                    if (playerManager.isFullscreen) {//if video is on fullscreen then it will exit out of fullscreen when video is finished
                                        // exit full-screen
                                        verbose("exiting fullscreen before destroy()");
                                        if (document.exitFullscreen) {
                                            document.exitFullscreen();
                                        } else if (document.webkitExitFullscreen) {
                                            document.webkitExitFullscreen();
                                        } else if (document.mozCancelFullScreen) {
                                            document.mozCancelFullScreen();
                                        } else if (document.msExitFullscreen) {
                                            document.msExitFullscreen();
                                        }
                                    }
                                    verbose("isCompleted = true");
                                    playerManager.isCompleted = true;
                                };

                                if (html5PlayerSelf.options.vpaid) {
                                    callbackFunctionAfterVideoComplete();//JSVPAID has it's own logic to invoke html5PlayerSelf.dispatchEventToAdunit for "video_complete", so it doesn't need to be invoked twice here
                                } else {
                                    html5PlayerSelf.dispatchEventToAdunit({"name": "video_complete"}, callbackFunctionAfterVideoComplete);//this callback will be invoked after video_complete
                                }


                            });

                            videojsPlayer.on("durationchange", function () {
                                html5PlayerSelf.dispatchEventToAdunit({"name": "durationchange"});
                            });

                            videojsPlayer.on("error", function (e) {
                                debug("error in video js");

                                var ignore_error_which_are_not_fatal = (e && e.target && e.target !== undefined && html5PlayerSelf.options && html5PlayerSelf.options.vpaid);
                                if (ignore_error_which_are_not_fatal &&
                                    (
                                        (e.target.toString().indexOf("poster=\"null\"") > 0) ||
                                        (e.target.nodeName.toLowerCase() === "video" && e.target.networkState <= 2) ||
                                        (e.target.nodeName.toLowerCase() === "div")
                                    )
                                ) {
                                    //do nothing here, this issue caused by js-vpaid player (mail online's)
                                    //do nothing, when video js's video element throws errors but which are not fatal
                                } else {
                                    verbose("destroying due to error in video js");
                                    playerManager.destroyWithoutSkip(true, html5PlayerSelf.CONST_MESSAGE_GENERAL_ERROR, null, 900);
                                }
                            });

                            videojsPlayer.on("firstplay", function () {
                                html5PlayerSelf.dispatchEventToAdunit({"name": "firstplay"});
                            });



                            //for VID-2558 VID-2554 Desktop Safari, Firefox response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation. and it is used by Outstream AdUnit
                            if (html5PlayerSelf.isMobile() === false) {
                                videojsPlayer.controlBar.fullscreenToggle.on("click",function() {
                                    //isFullscreenToggled flag will use for sideStream to have more accurate fullscreen status on desktop safari and firefox
                                    if (playerManager.isFullscreenToggled) {
                                        //do nothing because a part to handle "fullscreenchange" will set false
                                    } else {
                                        playerManager.isFullscreenToggled = true;
                                    }

                                });
                            }


                            videojsPlayer.on("fullscreenchange", function () {
                                verbose("fullscreenchange");

                                if (html5PlayerSelf.isIos() && playerManager.isFullscreen) {
                                    playerManager.play();
                                }

                                if (playerManager.isFullscreen) {
                                    html5PlayerSelf.pendingFullscreenExit = true;
                                    videojsPlayer.controlBar.el().style['bottom'] = '';
                                    if (!html5PlayerSelf.options.disableTopBar) {
                                        floatingAdIndicator.style.display = "none";
                                        if (floatingSkipButton) {
                                            floatingSkipButton.style.display = "none";
                                            floatingAdSkipText.style.display = "none";
                                        }
                                    }


                                    var delayForSuppressingMouseoutEvent;
                                    if (html5PlayerSelf.isMobile() === false) {
                                        delayForSuppressingMouseoutEvent = 1000;
                                    } else {
                                        delayForSuppressingMouseoutEvent = 0;//mobile (Android) doesn't need to delay to set isFullscreen flag for the mouseout event - it doesn't have a mouse
                                    }

                                    setTimeout(function () {
                                        html5PlayerSelf.pendingFullscreenExit = false;
                                        playerManager.isFullscreen = false;
                                        playerManager.isFullscreenToggled = false;//for sideStream activation


                                        html5PlayerSelf.dispatchEventToAdunit({
                                            name: "fullscreenchange",
                                            fullscreenStatus: "exit"
                                        });
                                    }, delayForSuppressingMouseoutEvent);//this delay must be required for supressing mouseout event when exit fullscreen





                                } else {
                                    playerManager.isFullscreen = !playerManager.isFullscreen;
                                    videojsPlayer.controlBar.el().style['bottom'] = "0.0em";


                                    if (!html5PlayerSelf.options.disableTopBar) {
                                        floatingAdIndicator.style.display = "block";
                                        if (floatingSkipButton) {
                                            if (readyForSkip) {
                                                floatingSkipButton.style.display = "block";
                                                floatingAdSkipText.style.display = "none";
                                            } else {
                                                floatingSkipButton.style.display = "none";
                                                floatingAdSkipText.style.display = "block";
                                            }
                                        }
                                    }
                                    html5PlayerSelf.dispatchEventToAdunit({
                                        name: "fullscreenchange",
                                        fullscreenStatus: "enter"
                                    });
                                }


                            });

                            videojsPlayer.on("loadstart", function () {
                                html5PlayerSelf.dispatchEventToAdunit({"name": "loadstart"});
                            });

                            videojsPlayer.on("pause", function () {
                                //html5PlayerSelf.dispatchEventToAdunit({"name": "video_pause"});

                                verbose("hiding big play button");
                                videojsPlayer.player().bigPlayButton.el().style.display = "block";
                                playerManager.isPlayingVideo = false;
                            });

                            videojsPlayer.on("play", function () {
                                videojsPlayer.player().bigPlayButton.el().style.display = "";

                                //html5PlayerSelf.dispatchEventToAdunit({"name": "video_resume"});
                                //html5PlayerSelf.dispatchEventToAdunit({"name": "impression"});
                                //html5PlayerSelf.dispatchEventToAdunit({"name": "video_start"});


                                playerManager.isPlayingVideo = true;
                            });

                            //handle click toggle manually
                            videojsPlayer.controlBar.playToggle.on("click", function () {
                                verbose("play button click");
                                if (playerManager.isPlayingVideo === true) {
                                    playerManager.explicitPause();
                                } else {
                                    playerManager.explicitPlay();
                                    playerManager.unmute();
                                }
                            });

                            videojsPlayer.controlBar.playToggle.on("touchend", function () {
                                verbose("play button touchend");
                                if (playerManager.isPlayingVideo === true) {
                                    playerManager.explicitPause();
                                } else {
                                    playerManager.explicitPlay();
                                    playerManager.unmute();
                                }
                            });

                            videojsPlayer.player().bigPlayButton.on("click", function () {
                                verbose("big play button click");
                                playerManager.explicitPlay();
                                //this timeout is due to a limitation in videojs
                                setTimeout(function () {
                                    playerManager.unmute();
                                }, html5PlayerSelf.bigbuttonUnmuteTimeout);
                            });

                            videojsPlayer.player().bigPlayButton.on("touchend", function () {
                                verbose("big play button touchend");
                                playerManager.explicitPlay();
                                //this timeout is due to a limitation in videojs
                                setTimeout(function () {
                                    playerManager.unmute();
                                }, html5PlayerSelf.bigbuttonUnmuteTimeout);
                            });

                            var waterfallStepId = html5PlayerSelf.options.isWaterfall ? html5PlayerSelf.options.waterfallStepId : null;
                            // Handle orientation change on Device to resize the player
                            window.addEventListener("orientationchange", function () {
                                if (playerManager.isReadyToExpandForMobile) {//for VID-1515
                                    if(waterfallStepId && waterfallStepId !== html5PlayerSelf.options.waterfallStepId){
                                        // Ignore the events as these are from previous ad attempts;
                                        return;
                                    }
                                    var shouldNotResizeWhenSideStreamActivated = html5PlayerSelf.options.sideStreamObject && typeof(html5PlayerSelf.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? html5PlayerSelf.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
                                    if (shouldNotResizeWhenSideStreamActivated) {
                                        return;
                                    }

                                    html5PlayerSelf.refreshVideoLookAndFeel(html5PlayerSelf.options, playerManager);
                                }
                            });
                        })();


                        var el_wholeArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
                        var el_videoArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_html5_api_id);


                        cbInjectEventToPlayer(el_wholeArea, el_videoArea);

                        /**
                         * invoke "callbackForAdUnit.cbWhenReady" to continute a flow of video player this is asynchoronous action
                         * and Outstream will wait this callback to start doing something (expanding...)
                         */
                        if (html5PlayerSelf.options.vpaid === false) {//for regular html5 video player
                            videojsPlayer.one("loadedmetadata", function (e) {
                                var obj = e.currentTarget;
                                playerManager.videoObjectId = obj.id;
                                playerManager.isReadyToExpandForMobile = true;

                                debug("loadedmetadata video.js is ready to play");
                                //disable click to play
                                videojsPlayer.tech.removeControlsListeners();

                                //get real video size
                                var realVideoWidth = obj.videoWidth;
                                var realVideoHeight = obj.videoHeight;
                                var aspectRatio = realVideoWidth / realVideoHeight;

                                if (realVideoWidth > 0) {
                                    playerManager.resizeVideo(aspectRatio);

                                    if (typeof html5PlayerSelf.callbackForAdUnit.cbWhenReady === "function") {
                                        html5PlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
                                    }
                                } else {
                                    //if the event doesn't return a videoWidth
                                    playerManager.resizeVideo(0);
                                    html5PlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
                                }
                            });
                        }
                    };

                    //fallback play for latest mobile browsers on iOS and Android both will auto-play by "autoplay" and "muted" attributes in video element. video.js will set the attributes by following codes.
                    if (html5PlayerSelf.options.initialPlayback === "autoWithFallbackPlay") {
                        html5PlayerSelf.options.autoplay = true;
                        html5PlayerSelf.options.muted = true;
                    }

                    //create player object
                    html5PlayerSelf.videojsOrigin(an_html5_video_object, html5PlayerSelf.options, function () {
                        customizeVideoJS(this);//do customize video.js after video.js initialized by calling back this method
                        if (html5PlayerSelf.options.vpaid === false) {
                            //this.src(html5PlayerSelf.options.videoUrl);
                            this.src("http://v.adsrvr.org/tdpartnerid/cxpowqgj/r17axcdp.webm");

                        }

                    });

                    if (html5PlayerSelf.options.vpaid && playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.trigger) {
                        playerManager.adVideoPlayer.trigger("an.doneInitialize");
                    }


                }
            };


        };

        /***/ },
    /* 12 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * JSVPAID Configure module this is used for AdVideoPlayerHtml5 and AdVideoPlayerHtml5Ios
         * @type {*|exports|module.exports}
         */

        var utils = __webpack_require__(9);
        var _logger = __webpack_require__(2);
        var CONST_MESSAGE_VAST_ADERROR = "VAST AdError reported from JS VPAID player";
        var CONST_MESSAGE_VPAID_ADERROR = "VPAID AdError reported from JS VPAID player";
        var error = function (message, category) {
            _logger.error('[' + new Date().toISOString() + '] ' + message, category);
        };
        var warn = function (message) {
            _logger.warn("JS VPAID" + message);
        };
        var info = function (message) {
            _logger.info("JS VPAID" + message);
        };
        var log = function (message) {
            _logger.log("JS VPAID" + message);
        };
        var debug = function (message) {
            _logger.debug("JS VPAID" + message);
        };
        var verbose = function (message) {
            _logger.verbose("JS VPAID" + message);
        };

        var JSVPAIDConfigure = function (playerManager) {

            var dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
            var options = playerManager.options;
            var videojsOrigin = playerManager.videoPlayerObj;
            var jsVpaidUrl = options.videoUrl;
            var callbackForAdUnit = playerManager.callbackForAdUnit;
            var iframeVideoWrapper = playerManager.iframeVideoWrapper;
            var alreadyProcessedError = false;

            // for Overlay player do not show any VPAID visual elements until AdStarted  is sent by creative.
            if (!utils.isIos() && iframeVideoWrapper && options.overlayPlayer && options.initialPlayback === "auto") {
                iframeVideoWrapper.style.display = "none";
            }

            //add plugin to activate vpaid-js component
            options.plugins = {"ads-setup": {}};
            options.vpaidImpressionFired = false;

            if(options.isWaterfall && options.firstAdAttempted){
                if(options.delayExpandUntilVPAIDImpression){
                    options.delayExpandUntilVPAIDInit = false;
                } else if(options.isExpanded) {
                    options.delayExpandUntilVPAIDInit = false;
                }
            }

            //initalize JSVPAID plug-in
            videojsOrigin.plugin('ads-setup', function (opts) {
                debug(opts);
                var vpaidTimeout = 5000;
                if (options.vpaidTimeout !== undefined) {
                    vpaidTimeout = options.vpaidTimeout;
                }
                var loggerCallback = {
                    'error' : error,
                    'warn' : warn,
                    'info' : info,
                    'log' : log,
                    'debug' : debug,
                    'verbose' : verbose
                };
                var vpaidEventCallback = function (eventName) {
                    var event = {
                        'AdImpression': 'video_impression',
                        'AdVideoStart': 'video_start',
                        'AdVideoFirstQuartile': 'video-first-quartile',
                        'AdVideoMidpoint': 'video-mid',
                        'AdVideoThirdQuartile': 'video-third-quartile',
                        'AdVideoComplete': 'video_complete',
                        'AdSkipped': 'video_skip',
                        'AdClickThru': 'ad-click'
                    };
                    if(eventName === 'AdImpression'){
                        options.vpaidImpressionFired = true;
                    }

                    if (event[eventName]) {
                        dispatchEventToAdunit({"name": event[eventName]});
                    }
                    playerManager.notifyVpaidEvent(eventName);
                };
                var disableControlsOnMouseover = utils.isIos() || utils.isAndroid();
                var videojsPlayer = this;

                var vastAd = videojsPlayer.vastClient({
                    url: "",//url doesn't necessary in this vpaid plug-in
                    jsVpaidUrl: jsVpaidUrl,
                    playAdAlways: true,
                    adCancelTimeout: vpaidTimeout,
                    adsEnabled: true,
                    adParameters: options.adParameters,
                    clickUrl: options.clickUrls[0],
                    delayExpandUntilVPAIDInit: options.delayExpandUntilVPAIDInit,
                    terminateUnresponsiveVPAIDCreative: options.terminateUnresponsiveVPAIDCreative,
                    disableControlsOnMouseover: disableControlsOnMouseover,
                    initialAudio: options.initialAudio,
                    loggerCallback: loggerCallback,
                    vpaidEventCallback: vpaidEventCallback,
                    delayExpandUntilVPAIDImpression: options.delayExpandUntilVPAIDImpression,
                    vpaidEnvironmentVars: options.vpaidEnvironmentVars,
                    overlayPlayer: options.overlayPlayer
                });


                videojsPlayer.on('reset', function () {
                    if (videojsPlayer.options().plugins['ads-setup'].adsEnabled) {
                        vastAd.enable();
                    } else {
                        vastAd.disable();
                    }
                });


                videojsPlayer.on('vast.adError', function (evt) {

                    if (alreadyProcessedError === true) {
                        return;
                    } else {
                        alreadyProcessedError = true;
                    }

                    // clean visual element
                    videojsPlayer.loadingSpinner.hide();
                    //on a vast error, end the ad
                    playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VAST_ADERROR, false, 901);

                    var error = evt.error;
                    if (error && error.message) {
                        debug("JS-VPAID Error (vast.adError)" + error.message);
                    }
                });

                //this can be returned from js-vpaid 0.1.24
                videojsPlayer.on('vast.adTimeout', function () {
                    // clean visual element
                    videojsPlayer.loadingSpinner.hide();
                    playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VPAID_ADERROR, true, 901);
                });

                //this can be returned from js-vpaid 0.1.24
                videojsPlayer.on('vpaid.AdError', function (evt) {

                    if (alreadyProcessedError === true) {
                        return;
                    } else {
                        alreadyProcessedError = true;
                    }

                    // clean visual element
                    videojsPlayer.loadingSpinner.hide();
                    //on a vast error, end the ad
                    playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VPAID_ADERROR, false, 901);

                    var error = evt.error;
                    if (error && error.message) {
                        debug("JS-VPAID Error (vpaid.AdError) " + error.message);
                    }
                });

                videojsPlayer.on('vast.adSkip', function () {
                    //on a vast skip, end the ad
                    playerManager.destroy();
                    debug("vast.adSkip");
                });

                videojsPlayer.on('vpaid.AdSkipped', function () {
                    //on a vast skip, end the ad
                    playerManager.destroy();
                    debug("vpaid.AdSkipped");
                });

                videojsPlayer.on('vast.adsCancel', function () {
                    //on a vast ad cancel, end the ad
                    playerManager.destroyWithoutSkip();
                    debug("adsCancel");
                });

                videojsPlayer.on('vpaid.AdStopped', function () {
                    debug("vpaid.AdStopped");
                    videojsPlayer.loadingSpinner.hide();
                    videojsPlayer.controlBar.hide();
                    videojsPlayer.bigPlayButton.hide();
                    if (playerManager.isCompleted) {
                        return;
                    }
                    if (!options.disableCollapse) {
                        playerManager.destroyWithoutSkip();
                    }
                    playerManager.isCompleted = true;
                });

                videojsPlayer.one('vpaid.AdStarted', function () {
                    //For iOS10 force the mute button update
                    if(utils.isIos() && options.enableNativeInline  && parseInt(utils.getIOSVersion())>9){
                        videojsPlayer.muted(true);
                        videojsPlayer.controlBar.muteToggle.update();
                    }
                    // For overlay player show visual elements
                    if (iframeVideoWrapper && options.overlayPlayer) {
                        iframeVideoWrapper.style.display = "block";
                    }
                    // VID-1879 forcefully hiding spinner when creative send back AdStarted to avoid spinning issues due to slow buffering etc.
                    videojsPlayer.loadingSpinner.hide();

                    //minthe : comment out following lines because it looks unnecessary code since we changed iframe's height by resizeVideo and it will notify 'change' to vpaid creative
                    //minthe : and this code might be useful when we had static bottom-bar for JSVPAID, but now we have overlayed style bottom-bar, so this change will work as well
                    /*
                     //TODO change this to beautiful way in order to notify 'change' event into vpaid container which has height as "100%"
                     //some jsvpaid creative detect whole size of outstream, but the creative try to get a value when it has been changing
                     setTimeout(function () {
                     var iframeElement = document.getElementById(options.iframeVideoWrapperId);
                     var tmp = Number(iframeElement.style.height.replace("px", ""));
                     iframeElement.style.height = tmp + 1 + "px";
                     setTimeout(function () {
                     iframeElement.style.height = tmp + "px";
                     }, 500);
                     }, 500);
                     */
                });

                videojsPlayer.one("vpaid.AdImpression", function() {
                    videojsPlayer.controlBar.show();
                    videojsPlayer.bigPlayButton.show();
                });

                if (callbackForAdUnit.cbWhenReady) {//for JS-VPAID

                    /**
                     * final process to send signal to Adunit to let them know ready to go
                     */
                    var callcbWhenReady = function () {
                        debug("callcbWhenReady (Impression, AdStarted are delivered");
                        playerManager.isReadyToExpandForMobile = true;
                        videojsPlayer.tech.removeControlsListeners();
                        var aspectRatioFromVAST = playerManager.options.width / playerManager.options.height;
                        playerManager.resizeVideo(aspectRatioFromVAST, utils.isMobile());
                        if (typeof callbackForAdUnit.cbWhenReady === "function") {
                            callbackForAdUnit.cbWhenReady(playerManager);
                        }
                    };

                    var handleDelayExpand = function () {//VID-1505
                        var doneHandleDelayExpand = false;
                        var currentVolume = videojsPlayer.volume();
                        var adStartedTriggered = false;
                        var adImpressionTriggered = false;
                        var adVideoStartTriggered = false;
                        var isVideoPaused = false;
                        var intervalTimeForPause = 100;

                        var handleEvent = function () {
                            if (adStartedTriggered && adImpressionTriggered && adVideoStartTriggered && doneHandleDelayExpand === false) {
                                doneHandleDelayExpand = true;
                                setTimeout(callcbWhenReady, 500);
                            }
                        };

                        if (utils.isIos()) {//VID-1742
                            videojsPlayer.on("timeupdate", function () {
                                var currentPosition = videojsPlayer.player().currentTime();
                                if (currentPosition > 0 && isVideoPaused === false && playerManager.isAlreadyPlaingForVPAID === false) {
                                    isVideoPaused = true;
                                    adVideoStartTriggered = true;
                                    videojsPlayer.pause();
                                    handleEvent();
                                    debug("pause by timeupdate when delayExpandUntilVPAIDImpression is true");
                                }
                            });
                            var checkTimingToPause = function () {
                                var currentPosition = videojsPlayer.player().currentTime();
                                if (currentPosition > 0 && isVideoPaused === false && playerManager.isAlreadyPlaingForVPAID === false) {
                                    isVideoPaused = true;
                                    adVideoStartTriggered = true;
                                    videojsPlayer.pause();
                                    handleEvent();
                                    debug("pause by timer when delayExpandUntilVPAIDImpression is true");
                                }
                                if (!doneHandleDelayExpand) {
                                    setTimeout(checkTimingToPause,intervalTimeForPause);
                                }
                            };
                            setTimeout(checkTimingToPause,intervalTimeForPause);
                        } else {
                            videojsPlayer.one("vpaid.AdVideoStart", function () {
                                if (playerManager.isAlreadyPlaingForVPAID === false) {
                                    videojsPlayer.pause();//early pause will cause issue not to dispatch timeupdate
                                }
                                videojsPlayer.volume(currentVolume);
                                adVideoStartTriggered = true;
                                handleEvent();
                            });
                        }

                        videojsPlayer.one("vpaid.AdStarted", function () {
                            adStartedTriggered = true;
                            handleEvent();
                        });

                        videojsPlayer.one("vpaid.AdImpression", function () {
                            adImpressionTriggered = true;
                            handleEvent();
                        });

                        videojsPlayer.volume(0);//set mute
                        playerManager.delayEventHandler.ignoreNextQueue();//for VID-1505

                        if (utils.isIos()) {
                            playerManager.adVideoPlayer.trigger('play');//jsvpaid in iOS inline should have special call instead of .play() in order to get "AdStarted" event for JSVPAID after that, framework will have proper video url which is set by JSVPAID creative
                            playerManager.isDoneInitialPlay = true;//mark flag to notify JSVPAID-iOS player resolved initial playback
                        } else {
                            videojsPlayer.play();
                        }
                    };

                    var decideHowToPlayByDelayStartUntilAdImpression = function () {
                        if (options.delayExpandUntilVPAIDImpression) {
                            handleDelayExpand(); //case of delayExpandUntilVPAIDImpression
                        } else {
                            callcbWhenReady();//case of others
                        }
                    };

                    if(options.isWaterfall && options.firstAdAttempted){
                        // For waterfall from second ad onwards trigger ready once the player is ready.
                        videojsPlayer.one("an.doneInitialize", decideHowToPlayByDelayStartUntilAdImpression);

                    } else {
                        if (options.delayExpandUntilVPAIDInit) {
                            //suppress a call of cbWhenReady until player got custom event in order to notify Outstream to start expanding
                            videojsPlayer.one("an.readytogovpaid", decideHowToPlayByDelayStartUntilAdImpression);//readytogovpaid will be triggerd when VPAID returns AdLoaded
                        } else {
                            videojsPlayer.one("an.doneInitialize", decideHowToPlayByDelayStartUntilAdImpression);//doneInitialize will be triggered when ios/html5 player is initialized
                        }
                    }
                }


            });


        };
        module.exports = JSVPAIDConfigure;


        /***/ },
    /* 13 */
    /***/ function(module, exports, __webpack_require__) {

        var APN_InlineVideoPlayerForiOS = __webpack_require__(14);//new inline video player which is rendering a video signal into canvas and generating audio and sync with video
        var utils = __webpack_require__(9);
        var _logger = __webpack_require__(2);
        var debug = function (message) {
            _logger.debug("iOSInlineVideoPlayer: " + message);
        };

        var error = function (message) {
            _logger.error("iOSInlineVideoPlayer: " + message);
        };

        /**
         * This module adopts new inline video player for iOS version 8 and 9 for iphone and ipad, no gurranted to be used in other OS and other version.
         *
         * the player will be genrated by using "new" keyword to support multiple instance,
         * the player will be injected into a div which is inside video.js area in the screen
         * this module generates html5 video as usual as our framework did in AdVideoPlayerHtml5.js,
         * but the video object will be passed to the inline player to be used as a source of video frame capturing
         *
         * @param playerManager
         * @param cbInjectEventToPlayer
         */
        var iOSInlineVideoPlayer = function (playerManager, cbInjectEventToPlayer) {

            var iOSInlinePlayerSelf = this;

            this.options = playerManager.options;//getting required object from adVideoPlayerManager
            this.topChromeHeight = 24;
            this.iOSVideoPlayer = new APN_InlineVideoPlayerForiOS();
            this.videojsOrigin = playerManager.videoPlayerObj;
            this.dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
            this.callbackForAdUnit = playerManager.callbackForAdUnit;
            this.UUID = new Date().getTime() + Math.floor(Math.random() * 10000);
            this.an_video_ad_player_id = "an_video_ad_player_" + iOSInlinePlayerSelf.UUID;
            this.an_video_ad_player_html5_api_id = "an_video_ad_player_" + iOSInlinePlayerSelf.UUID + "_html5_api";
            this.refreshVideoLookAndFeel = utils.refreshVideoLookAndFeel;
            this.shouldConsiderHeightOfDevice = true;
            this.isDoneiOSInitialPlay = false;
            this.isTogglePaused = false;
            this.enabledAudio = false;//flag to enable audio (one time action)
            this.isFullscreen = false;
            this.enableFullscreen = true;//add custom fullscreeen icon
            this.fromFullscreen = false;
            this.isAlreadyDoneVideoComplete = false;
            this.customPlayToggle = {};
            this.customFullscreenBtn = {};
            this.eventSizeChange = {};//event id for size change when addressbar appears
            this.eventOrientationChange = {};//event id for orientation change
            this.floatingAdIndicator = null;
            this.floatingSkipButton = null;
            this.floatingAdSkipText = null;
            this.readyForSkip = false;
            this.videojsPlayer = null;

            //loading module with injecting a dependancy
            var EmulateHtml5Video = __webpack_require__(15)(iOSInlinePlayerSelf,playerManager);
            var Events = __webpack_require__(16)(iOSInlinePlayerSelf,playerManager, cbInjectEventToPlayer);
            var InitializeElements = __webpack_require__(18)(iOSInlinePlayerSelf,playerManager);

            //interfaces
            this.createIframeAndRequiredObject = InitializeElements.createIframeAndRequiredObject;
            this.fnMainProcess = Events.fnMainProcess;
            this.handleFullScreen = EmulateHtml5Video.handleFullScreen;
            this.handleNormalScreen = EmulateHtml5Video.handleNormalScreen;
            this.resizeIosCanvas = EmulateHtml5Video.resizeIosCanvas;
            this.cbWhenVideoComplete = EmulateHtml5Video.cbWhenVideoComplete;

            this.start = function() {
                debug("start");

                //test interface
                if (iOSInlinePlayerSelf.test() === false) {
                    error("initialize error");
                    return;
                }

                var UID = new Date().getTime() + Math.floor(Math.random() * 10000);//define iframe's uniqueu id
                iOSInlinePlayerSelf.options.iframeVideoWrapperId = "iframeVideoWrapper_" + UID;
                iOSInlinePlayerSelf.options.techOrder = ["html5"];//force to use html5 for video.js because flash will be handled by diffrent swf owned by us
                iOSInlinePlayerSelf.createIframeAndRequiredObject(iOSInlinePlayerSelf.fnMainProcess);//invoke method with a parameter defined next execution.
            };

            this.test = function() {
                if (this.createIframeAndRequiredObject && this.fnMainProcess && this.handleFullScreen && this.handleNormalScreen && this.resizeIosCanvas && this.cbWhenVideoComplete) {
                    return true;
                } else {
                    return false;
                }
            };




        };
        module.exports = iOSInlineVideoPlayer;

        /***/ },
    /* 14 */
    /***/ function(module, exports, __webpack_require__) {

        //Inline video player module for iOS by kyungsuk (ksong@appnexus.com)
        /*
         This player code includes following items.

         0. Inline video in iPhone instead of native fullscreen
         1. No AJAX call for audio and video
         2. Using javascript only
         3. Sync with audio
         4. Multiple instance
         5. Adjustable fullscreen instead of native one
         6. Support Safari mobile browser of iOS8, iOS9 (phone / tablet)
         */
        var _logger = __webpack_require__(2);
        var log = function (message) {
            _logger.log("iOSInlineVideoPlayer: " + message);
        };
        var debug = function (message) {
            _logger.debug("iOSInlineVideoPlayer :: iOSInlineCore: " + message);
        };
        var verbose = function (message) {
            _logger.verbose("iOSInlineVideoPlayer :: iOSInlineCore: " + message);
        };



        /**
         * Javascript class for Inline Video Player for iOS (this class should be instiantiated by using new keyword)
         * @constructor
         */
        var APN_InlineVideoPlayerForiOS = function () {

            //major required html5 object
            var canvas;//html5 canvas object to render video signal
            var video;//html5 video object to capture video signal
            var videoSource;//source object to be injected into video object
            var audio;//html5 audio object to sound
            var audioSource;//source object to be injected into audio object
            var mediaUrl;//media url to be used by video
            var canvasContext;//2d context(surface) to render video


            //major flags
            var lastTime;//time to get lasttime
            var animationFrame;//reference of loop
            var framesPerSecond;//define frame rate
            var isAudioStarted;
            var canvasPause;//flag to pause video/audio
            var isAudioMute;//if it's false player start sync with audio and video
            var initialSyncValue;//const variable to define initial sync gap. if gap of time between audio and video exceed this value, player resync video to have same position with audio (audio's always playing without changing position)
            var initialSyncValueAfter;//same with initialSyncValue, but initialSyncValue value will use only one time at the first synchronization
            var videoAspectRatio;//variable to keep video aspect ratio this will have real width & height of video after got metadata from video asset
            var isAudioCreated;//flag to block to generate audio tag over twice
            var isFullscreen;
            var limitSyncValue;
            var cbWhenVideoComplete;
            var isTerminated = false;
            var isRunningForCanvas = false;


            //areas
            var divArea;//div element to render this player
            var targetElement;//div element of Outstream
            var cssTextOf_targetElement;//keep css of targetElement
            var iframeVideoWrapper;//reference for iframe that video.js generates
            var cssTextOf_iframeVideoWrapper;//css text to keep orignal value of iframeVideoWrapper
            var el_wholeArea;//first div in iframe
            var cssTextOf_el_wholeArea;//css text to keep orignal value of el_wholeArea
            var cssTextOf_canvas;//css text to keep orignal value of canvas
            var cbTimeUpdate;

            var pubOptions;

            //const
            var heightOfToolbar = 30;//height of toolbar which will be added to video area. this is required to show whole area of video with controlbar

            /**
             * status object to keep original value
             * @type {{keepWidth: null, keepHeight: null}}
             */
            var status = {
                keepWidth: null, keepHeight: null
            };

            this.setPubOptions = function (options) {
                pubOptions = options;
            };

            /**
             * check if it's mobile
             * @returns {boolean}
             */
            var isWorkableDeviceForInlineVideo = function () {
                var index = navigator.appVersion.indexOf("Mobile");
                return (index > -1);
            };


            /**
             * external interface : render & prepare a video,canvas,audio reference. audio will be set when user click "unmute"
             * @param options
             * @param callback
             */
            this.renderVideo = function (options, callback) {

                log("renderVideo");

                if (!isWorkableDeviceForInlineVideo()) {
                    callback(false);
                    return;
                }

                cbTimeUpdate = options.cbTimeUpdate;
                mediaUrl = options.mediaUrl;
                divArea = options.divArea;
                cbWhenVideoComplete = options.cbWhenVideoComplete;

                //binding reference of elements
                targetElement = options.targetElement;
                iframeVideoWrapper = options.iframeVideoWrapper;
                el_wholeArea = options.el_wholeArea;


                //generate intial object
                verbose("generating initial canvas object");
                canvas = document.createElement("canvas");
                divArea.appendChild(canvas);
                divArea.style.width = "100%";//to fix alignment issue in normall screen if it's vpaid
                divArea.style.height = "100%";


                status.keepWidth = canvas.style.width;
                status.keepHeight = canvas.style.height;


                if (typeof options.videoElement !== "undefined") {
                    video = options.videoElement;
                } else {
                    //create and inject video tag
                    verbose("creating video tag");
                    video = document.createElement("video");
                    videoSource = document.createElement("source");
                    video.style.display = "none";
                    video.autoplay = false;
                    video.preload = "auto";
                    video.controls = true;
                    videoSource.src = mediaUrl;//it will be replace if it's JSVPAID and when VPAID returns adStarted
                    video.appendChild(videoSource);

                    //inject video to divArea
                    divArea.appendChild(video);
                }


                //preparing audio tag but not render it
                verbose("preparing audio tag");
                audio = document.createElement("audio");
                audioSource = document.createElement("source");

                if (pubOptions.preloadInlineAudioForIos && !pubOptions.vpaid) {//vpaid will invoke this at playerHtml5Ios.js
                    this.activateAudio();
                }


                //getting context from canvas
                canvasContext = canvas.getContext('2d');

                lastTime = Date.now();//time to get lasttime
                framesPerSecond = 35;//define frame rate
                isAudioStarted = false;
                canvasPause = false;
                isAudioMute = true;
                initialSyncValue = 0.3;
                initialSyncValueAfter = 0.3;
                videoAspectRatio = 0.1;
                isAudioCreated = false;//flag to verfiy audio is already generated
                isFullscreen = false;
                limitSyncValue = 99999999;//if gap has bigger value than this, it won't be synchroinized

                verbose("renderVideo callback");
                callback(true);


            };

            //new logic for storing css this will store only required value
            var saveCSS = function (targetElement) {
                verbose("saveCSS");
                var result = {};
                var cssStorage = {position: "", width: "", height: "", top: "", left: "", marginRight: "", transform: "", background: ""};//only this attributes will be handled by save/load css method
                for (var el in cssStorage) {
                    result[el] = targetElement.style[el];
                }
                return result;
            };

            //new logic for load CSS this will load only required value
            var loadCSS = function (targetElement, storedCSSObject) {
                verbose("loadCSS");
                for (var el in storedCSSObject) {
                    targetElement.style[el] = storedCSSObject[el];
                }
            };

            var getCalculatedWidthHeight = function (isFullscreen) {
                //this is in a constant loop so I am commenting it out
                //verbose("getCalculatedWidthHeight");
                var aspectRatio = video.videoWidth / video.videoHeight;
                var calculatedWidth = 0;
                var calculatedHeight = 0;


                if (!isFullscreen) {
                    var isSideStreamActivated = pubOptions.sideStream && pubOptions.sideStream.enabled && pubOptions.sideStreamObject && pubOptions.sideStreamObject.isActivated;
                    if (isSideStreamActivated) {

                        //for VID-2144
                        var frameWidth = pubOptions.sideStream.width;
                        var frameHeight = pubOptions.sideStream.height;
                        var width;
                        var height;
                        var topOffset = 0;
                        var bottomOffset = 30; //iOS alwasys need topBar

                        if (!pubOptions.disableTopBar) {
                            topOffset = 24; //default height for topBar
                        }
                        frameHeight = frameHeight - (bottomOffset + topOffset);//consider topbar and controlBar size

                        if (!frameWidth && !frameHeight) {//using default value if sideStream doesn't have width,height
                            frameWidth = pubOptions.width;
                            frameHeight = pubOptions.mediaHeight;
                        }

                        if (frameWidth && frameHeight) {
                            width = frameWidth;
                            height = frameHeight;
                        } else {
                            width = frameWidth ? frameWidth : frameHeight / aspectRatio;
                            height = frameHeight ? frameHeight : frameWidth / aspectRatio;
                        }
                        calculatedWidth = Math.round(Math.min((height) * aspectRatio, width));
                        calculatedHeight = Math.round(Math.min(width / aspectRatio, height));
                    } else {
                        calculatedWidth = Math.round(Math.min((pubOptions.mediaHeight) * aspectRatio, pubOptions.width));
                        calculatedHeight = Math.round(Math.min(pubOptions.width / aspectRatio, pubOptions.mediaHeight));
                    }

                } else {
                    //fullscreen case
                    calculatedWidth = window.innerWidth;
                    calculatedHeight = Math.round(window.innerWidth / aspectRatio);
                }

                //this is in a constant loop so I'm commenting it out
                //verbose("calculated width: " + calculatedWidth + ", calculated height: " + calculatedHeight);
                return {"width": calculatedWidth, "height": calculatedHeight};
            };

            var getStartXY = function (isFullscreen) {
                //this is in a constant loop so I'm commenting it out
                //verbose("getStartXY");

                var startX = 0;
                var startY = 0;

                if (!isFullscreen) {
                    startX = 0;
                    startY = Math.abs(pubOptions.mediaHeight - getCalculatedWidthHeight(isFullscreen).height) / 2;
                }

                return {"x": startX, "y": startY};
            };

            var resizeCanvas = function (isFullscreen) {
                //this is in a constant loop so I'm commenting it out
                //verbose("resizeCanvas");

                var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
                var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;

                if (!isFullscreen) {
                    canvas.width = calculatedWidth;
                    canvas.height = pubOptions.mediaHeight;
                } else {
                    canvas.width = calculatedWidth;
                    canvas.height = calculatedHeight;
                }


            };

            var redrawCanvas = function (isFullscreen) {

                var startX = getStartXY(isFullscreen).x;
                var startY = getStartXY(isFullscreen).y;
                var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
                var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;

                if (!isFullscreen) {
                    canvasContext.drawImage(video, startX, startY, calculatedWidth, calculatedHeight);
                } else {
                    canvasContext.drawImage(video, 0, 0, calculatedWidth, calculatedHeight);
                }
            };


            /**
             * render video and sync with audio, this method forcely advance key-frame by time-based, and render video signal into canvas
             * time gap between audio and video calculates everytime, and if the gap will exceed over specific value, video will have new key-frame of audio's current playing.
             * @param lasttime_
             */
            function renderingLoop(lasttime_) {


                isRunningForCanvas = true;

                var time = Date.now();//set current time
                var elapsed = (time - lasttime_) / 1000;
                var frameCondition = 1 / framesPerSecond;//calculate time of 1 frame consumens
                var gap = 0;
                var isSynched = false;
                var syncValue = initialSyncValue;


                //render 1 key frame of video
                var renderVideoIntoCanvas = function () {




                    //forcely advanced key-frame of video by manual tick
                    video.currentTime = video.currentTime + elapsed;

                    var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
                    var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;
                    var startX = getStartXY(isFullscreen).x;
                    var startY = getStartXY(isFullscreen).y;

                    resizeCanvas(isFullscreen);

                    //time gap between audio and video's key-frame(currentTime)
                    gap = Math.abs(audio.currentTime - video.currentTime);


                    //this will be start after user click un-mute to generate audio tag in the background
                    if (isAudioMute === false) {

                        //resync if exceed over x seconds
                        if (gap >= syncValue && gap <= limitSyncValue) {

                            //synchorinize key-frame of video to match with audio's key-frame
                            video.currentTime = audio.currentTime + elapsed;
                            isSynched = true;
                            syncValue = initialSyncValueAfter;
                        } else {
                            isSynched = false;
                        }
                    }
                    //render video signal to canvas
                    if (!isFullscreen) {
                        canvasContext.drawImage(video, startX, startY, calculatedWidth, calculatedHeight);
                    } else {
                        canvasContext.drawImage(video, 0, 0, calculatedWidth, calculatedHeight);
                    }

                    cbTimeUpdate();


                    lasttime_ = time;
                };

                // render by frameCondition (this will help to reduce cpu/gpu consume) and also this will be effected by frameCondition
                if (elapsed >= frameCondition) {
                    renderVideoIntoCanvas();
                }

                var currentTime = video.currentTime;//allow to have decimals to precisely calculate
                var duration = video.duration;//allow to have decimals to precisely calculate
                //verbose(currentTime + "/" + duration);

                //complete when audio and video both finished
                if (currentTime >= duration) {
                    verbose("close checking by iOSInlinePlayer");
                    if (isAudioMute === false) {//when unmute a logic should check audio completion even if the video completed
                        var currentTimeOfAudio = audio.currentTime;
                        var durationOfAudio = audio.duration;
                        if (currentTimeOfAudio >= durationOfAudio) {
                            verbose("closed with audio by iOSInlinePlayer");
                            cbWhenVideoComplete();
                            isRunningForCanvas = false;//not allowing to re-enter this loop
                            return;
                        }
                    } else {
                        verbose("closed by iOSInlinePlayer");
                        cbWhenVideoComplete();
                        isRunningForCanvas = false;//not allowing to re-enter this loop
                        return;
                    }

                }

                //if canvasPause is false, cavas animation will start until it set to true, pause/resume will work like that
                if (canvasPause === false) {
                    animationFrame = requestAnimationFrame(function () {
                        renderingLoop(lasttime_);
                    });
                } else {
                    isRunningForCanvas = false;
                }

            }

            /**
             * check screen is under portrait mode.
             * @returns {boolean}
             */
            var isPortrait = function () {
                return window.innerHeight > window.innerWidth;//check viewport is portrait state
            };


            /**
             * check exit fullscreen in iPhone
             */
            var onVideoEndsFullScreen = function () {
                this.resumeVideo();
            };
            /**
             * calculate height to remain aspect ratio of video's
             * @returns {{width: number, height: number}}
             */
            var getSizeOfVideoArea = function (isPortrait) {

                //var windowWidth = window.document.body.clientWidth;
                var windowWidth = window.innerWidth;
                var windowHeight = 0;

                windowHeight = window.innerHeight;//height considering iOS's addressbar
                windowHeight = window.innerHeight;


                var height;
                var width;
                var top;
                var left;

                //comment out some video having specfic aspectratio like 4:3 it will be broken in the fullscreen
                if (!isPortrait) {

                    if (!isFullscreen) {
                        //for normal screen

                        //TODO hava a diffrent size matched with aspec ration of video
                        //height = windowHeight - heightOfToolbar;
                        //width = Math.round(height * videoAspectRatio);
                        //top = 0;
                        //left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position

                        //TODO to have a same size of window in landscape mode
                        //width = windowWidth;
                        //height = windowHeight - heightOfToolbar;
                        //top = 0;
                        //left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position


                        //TODO supporting iPAD
                        width = windowWidth;
                        height = pubOptions.height;

                        if (height >= windowHeight) {
                            height = windowHeight - heightOfToolbar;
                            top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
                            left = 0;
                        } else {
                            top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
                            left = 0;
                        }
                    } else {
                        //for fullscreen
                        //TODO supporting iPAD
                        width = windowWidth;
                        height = Math.round(width / videoAspectRatio);

                        if (height >= windowHeight) {
                            height = windowHeight - heightOfToolbar;
                            width = Math.round(height * videoAspectRatio);
                            top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
                            left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position
                        } else {
                            height = height - heightOfToolbar;
                            top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
                            left = 0;
                        }


                    }


                } else {

                    //portrait mode
                    if (!isFullscreen) {
                        //normal screen
                        width = windowWidth;
                        //height = pubOptions.height - heightOfToolbar;
                        height = pubOptions.mediaHeight;
                        top = Math.round((windowHeight / 2)) + 100;//calculate middle position
                        left = 0;
                    } else {
                        //fullscreen
                        width = windowWidth;
                        height = Math.round(windowWidth / videoAspectRatio);
                        top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
                        left = 0;
                    }


                }


                //debug("*** : " + width + "," + height + "," + top + "," + left);


                return {
                    "width": width,
                    "height": height,
                    "top": top,
                    "left": left
                };
            };

            /**
             * make fulll screen background. html5 fullscreen api doesn't work since iOS8 also has some problem inside of iframe, so it needs to be improved
             */
            var makeBackgroundScreen = function () {


                targetElement.style.backgroundColor = "black";
                targetElement.style.width = "100%";
                targetElement.style.height = "100%";
                targetElement.style.position = "fixed";
                //targetElement.style.position = "absolute";
                targetElement.style.top = "0px";
                targetElement.style.left = "0px";
                targetElement.style.zIndex = "999999";
                targetElement.style.background = "rgba(0,0,0,1)";

                targetElement.style.transition = "height 0s ease";

                //make background transparent
                el_wholeArea.style.background = "rgba(0,0,0,1)";
                canvas.style.background = "rgba(0,0,0,1)";
                iframeVideoWrapper.style.background = "rgba(0,0,0,1)";


            };

            /**
             * hide background and rolling back css kept
             */
            var hideBackgroundScreen = function () {
                //targetElement.style.cssText = cssTextOf_targetElement;
                loadCSS(targetElement, cssTextOf_targetElement);

                targetElement.style.height = getSizeOfVideoArea().height + "px";
            };


            /**
             * start video for initial play
             * @param e
             */
            var handleMetadata = function (e) {
                videoAspectRatio = e.target.videoWidth / e.target.videoHeight;
            };


            var resizeFullscreenConsideringRotation = function () {

                var isPortrait_ = isPortrait();
                var sizeObject = getSizeOfVideoArea(isPortrait_);

                var width = sizeObject.width;
                var height = sizeObject.height;
                var top = sizeObject.top;
                var left = sizeObject.left;

                //video in canvas can't have automatic flexible size becuase it's painted as a pixel(x,y) so need to recalculate size of video whenever rotation changed
                iframeVideoWrapper.style.position = "absolute";
                iframeVideoWrapper.style.width = width;
                iframeVideoWrapper.style.height = height;
                iframeVideoWrapper.style.top = top + "px";
                iframeVideoWrapper.style.left = left + "px";

                iframeVideoWrapper.style.marginRight = "";
                iframeVideoWrapper.style.transform = "";

                //change size for div under iframe
                el_wholeArea.style.width = width + "px";
                el_wholeArea.style.height = height + heightOfToolbar + "px";


                //change size for canvase
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";

                //for VID-1903
                el_wholeArea.style.marginLeft = "";
                el_wholeArea.style.marginRight = "";


            };


            var _exitFullscreeenAsCanvas = function () {
                //set full screen flag to avoid to enter resize for fullscreen when rotation change
                isFullscreen = false;

                //to release scroll in fullscreen
                targetElement.ontouchmove = function () {
                    return true;
                };
                canvas.ontouchmove = function () {
                    return true;
                };
                el_wholeArea.ontouchmove = function () {
                    return true;
                };


                hideBackgroundScreen();

                //rolback css attribute to original one
                loadCSS(targetElement, cssTextOf_targetElement);
                loadCSS(iframeVideoWrapper, cssTextOf_iframeVideoWrapper);
                loadCSS(el_wholeArea, cssTextOf_el_wholeArea);
                loadCSS(canvas, cssTextOf_canvas);
            };


            /**
             * external interface : exit out of fullscreen
             */
            this.exitFullscreeenAsCanvas = function () {
                _exitFullscreeenAsCanvas();
            };


            /**
             * external interface : enter full screen (actually draw div layer to have 100% width and height) //TODO need to have
             */
            this.enterFullscreenAsCanvas = function () {

                //to avoid scroll in fullscreen
                targetElement.ontouchmove = function () {
                    return false;
                };
                canvas.ontouchmove = function () {
                    return false;
                };
                el_wholeArea.ontouchmove = function () {
                    return false;
                };


                //store original css attributes
                cssTextOf_targetElement = saveCSS(targetElement);
                cssTextOf_iframeVideoWrapper = saveCSS(iframeVideoWrapper);
                cssTextOf_el_wholeArea = saveCSS(el_wholeArea);
                cssTextOf_canvas = saveCSS(canvas);

                //fix VID-2240
                targetElement.style.marginLeft = "0px";
                targetElement.style.marginRight = "0px";
                targetElement.style.marginTop = "0px";
                targetElement.style.marginBottom = "0px";


                isFullscreen = true;
                makeBackgroundScreen();


                resizeFullscreenConsideringRotation();


            };

            /**
             * external interface to playce intial play
             */
            this.initialPlay = function (enabledAudio) {

                if (!isRunningForCanvas) {
                    canvasPause = false;

                    if (enabledAudio && audio && audio.play) {
                        audio.play();
                    }
                    renderingLoop(Date.now());//start rendering loop to forcely advance key-frame of html5 video object
                }


            };

            /**
             * external interface to resume video
             */
            this.resumeVideo = function () {

                canvasPause = false;
                if (audio && audio.play) {
                    audio.play();
                }

            };

            /**
             * external interface to pause video
             */
            this.pauseVideo = function () {

                canvasPause = true;
                audio.pause();
            };


            this.activateAudio = function () {
                debug("activateAudio : " + video.src);

                //activate audio
                audio.style.display = "none";
                audio.autoplay = false;
                audio.preload = "auto";
                audio.controls = true;
                audioSource.src = video.src;//this should be required for vpaid

                audio.appendChild(audioSource);
                divArea.appendChild(audio);//this should be required for preload audio

                audio.load();
            };

            /**
             * external inrerface to activate audio
             */
            this.hearAudio = function () {//play audio should be started by human activity

                //don't need to re-create audio tag if it's already there.
                if (isAudioCreated) {
                    debug("resume audio");
                    isAudioMute = false;
                    audio.currentTime = video.currentTime;//first sync between audio and video
                    audio.play();
                    return;
                }

                audio.addEventListener("playing", function () {
                    debug("first playing audio");
                    audio.currentTime = video.currentTime + initialSyncValue;
                    isAudioMute = false;
                    isAudioCreated = true;
                });

                if (pubOptions.preloadInlineAudioForIos === false) {//if it's already loaded doesn't need to load again
                    this.activateAudio();
                }
                audio.currentTime = video.currentTime;//first sync between audio and video
                audio.play();

            };

            /**
             * kill the audio instance
             */
            this.stopAudio = function () {
                debug("pausing audio");
                audio.pause();
                isAudioMute = true;
            };

            /**
             * external interface to resize when orientation changed
             */
            this.checkOrientation = function () {

                if (isTerminated && !pubOptions.disableCollapse) {
                    return;
                }

                if (!isFullscreen) {
                    //normal screen
                    resizeCanvas(isFullscreen);
                    redrawCanvas(isFullscreen);


                } else {
                    //fullscreen
                    //_exitFullscreeenAsCanvas();
                    hideBackgroundScreen();
                    makeBackgroundScreen();
                    resizeFullscreenConsideringRotation();
                }
            };


            /**
             * external interface to intialize and initiate rendering
             */
            this.initiate = function () {
                video.addEventListener("canplaythrough", handleMetadata.bind(this));//handle metadata to set aspectratio
                video.addEventListener('webkitendfullscreen', onVideoEndsFullScreen, false);

                //preload
                video.load();
                video.pause();
            };


            /**
             * external interface to return canvas object to define click-to-browseout event
             * @returns {object}
             */
            this.getCanvas = function () {
                return canvas;
            };


            this.destroy = function () {

                if (isFullscreen) {
                    _exitFullscreeenAsCanvas();
                }

                isTerminated = true;


            };

            this.resizeCanvas = resizeCanvas;

            this.redrawCanvas = redrawCanvas;


        };
        module.exports = APN_InlineVideoPlayerForiOS;

        /***/ },
    /* 15 */
    /***/ function(module, exports, __webpack_require__) {

        var utils = __webpack_require__(9);
        var _logger = __webpack_require__(2);
        var debug = function (message) {
            _logger.debug("iOSInlineVideoPlayer :: EmulateHtml5Video: " + message);
        };
        var verbose = function (message) {
            _logger.verbose("iOSInlineVideoPlayer :: EmulateHtml5Video: " + message);
        };


        /**
         * EmulateHtml5Video
         * @param iOSInlinePlayerSelf
         * @param playerManager
         * @returns {{handleFullScreen: "handleFullScreen", handleNormalScreen: "handleNormalScreen", resizeIosCanvas: "resizeIosCanvas", cbWhenVideoComplete: "cbWhenVideoComplete"}}
         */
        module.exports = function (iOSInlinePlayerSelf, playerManager) {
            return {
                "handleFullScreen": function (iframeVideoWrapper) {
                    playerManager.isFullscreen = true;
                    debug("handleFullScreen");
                    var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");
                    iOSInlinePlayerSelf.dispatchEventToAdunit({
                        name: "fullscreenchange",
                        fullscreenStatus: "enter"
                    });
                    iOSInlinePlayerSelf.iOSVideoPlayer.enterFullscreenAsCanvas();
                    iOSInlinePlayerSelf.isFullscreen = true;
                    if (topChrome) {
                        topChrome.style.display = "none";
                    }
                    if (!iOSInlinePlayerSelf.options.disableTopBar) {
                        verbose("Hiding ad text for fullscreen");
                        iOSInlinePlayerSelf.floatingAdIndicator.style.display = "block";
                        if (iOSInlinePlayerSelf.floatingSkipButton) {
                            if (iOSInlinePlayerSelf.readyForSkip) {
                                iOSInlinePlayerSelf.floatingSkipButton.style.display = "block";
                                iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
                            } else {
                                iOSInlinePlayerSelf.floatingSkipButton.style.display = "none";
                                iOSInlinePlayerSelf.floatingAdSkipText.style.display = "block";
                            }
                        }
                    }
                },
                "handleNormalScreen": function (iframeVideoWrapper) {

                    playerManager.isFullscreen = false;
                    debug("handleNormalScreen");
                    var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

                    iOSInlinePlayerSelf.dispatchEventToAdunit({
                        name: "fullscreenchange",
                        fullscreenStatus: "exit"
                    });

                    //iOSInlinePlayerSelf.options.targetElement.style.transition = "height 0s ease";
                    if (topChrome) {
                        topChrome.style.display = "block";
                    }
                    if (!iOSInlinePlayerSelf.options.disableTopBar) {
                        verbose("Showing ad text for fullscreen");
                        iOSInlinePlayerSelf.floatingAdIndicator.style.display = "none";
                        if (iOSInlinePlayerSelf.floatingSkipButton) {
                            iOSInlinePlayerSelf.floatingSkipButton.style.display = "none";
                            iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
                        }
                    }
                    iOSInlinePlayerSelf.iOSVideoPlayer.exitFullscreeenAsCanvas();


                    iOSInlinePlayerSelf.isFullscreen = false;


                    var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStream && playerManager.options.sideStream.enabled && playerManager.options.sideStreamObject && playerManager.options.sideStreamObject.isActivated;
                    if (shouldNotResizeWhenSideStreamActivated === false) {
                        iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);//resizePlayer and change height of targetElement to have same value with video
                    }
                    iOSInlinePlayerSelf.resizeIosCanvas(iOSInlinePlayerSelf.isFullscreen);//resize canvase size and redraw 1 frame of the video which is cuurently playing or paused, this should be performed after video.js UI has changed


                    var videoObject = document.getElementById(playerManager.videoObjectId);
                    if (videoObject && typeof(videoObject) !== "undefined") {
                        videoObject.style.width = iOSInlinePlayerSelf.options.width;
                        videoObject.style.height = iOSInlinePlayerSelf.options.height;
                    }

                    //VID-2143
                    var isSideStreamEnabled = playerManager.options.sideStream && playerManager.options.sideStream.enabled;
                    var isSideStreamStarted = playerManager.options.sideStreamObject && typeof(playerManager.options.sideStreamObject.moveAdUnitBack) === "function";
                    if (isSideStreamEnabled && isSideStreamStarted) {
                        playerManager.options.sideStreamObject.moveAdUnitBack();
                    }

                },
                "resizeIosCanvas": function (isFullscreen_) {
                    /**
                     * resizeIosCanvas : this will resize canvas and redraw last position of the iOS inline video
                     * @param isFullscreen_
                     */
                    iOSInlinePlayerSelf.iOSVideoPlayer.resizeCanvas(isFullscreen_);
                    iOSInlinePlayerSelf.iOSVideoPlayer.redrawCanvas(isFullscreen_);
                },
                "cbWhenVideoComplete": function (iframeVideoWrapper, el_videoArea) {

                    debug("cbWhenVideoComplete");

                    if (iOSInlinePlayerSelf.isAlreadyDoneVideoComplete) {//VID-1510
                        return;
                    }

                    iOSInlinePlayerSelf.isAlreadyDoneVideoComplete = true;
                    if (iOSInlinePlayerSelf.isFullscreen) {
                        iOSInlinePlayerSelf.fromFullscreen = true;
                        iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
                    }

                    // remove control bar items
                    verbose("removing control bar items");
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.currentTimeDisplay.hide();
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.durationDisplay.hide();
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.timeDivider.hide();
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.hide();
                    // VID-1892 The buttons may not be present if iOSInlinePlayerSelf.options(Ex:allowFullscreen) are false.
                    if (iOSInlinePlayerSelf.customPlayToggle) {
                        iOSInlinePlayerSelf.customPlayToggle.style.display = 'none';
                    }
                    if (iOSInlinePlayerSelf.customFullscreenBtn) {
                        iOSInlinePlayerSelf.customFullscreenBtn.style.display = 'none';
                    }

                    verbose("destroying iOSVideoPlayer");
                    iOSInlinePlayerSelf.iOSVideoPlayer.destroy();
                    iOSInlinePlayerSelf.resizeIosCanvas(iOSInlinePlayerSelf.isFullscreen);


                    if (!iOSInlinePlayerSelf.options.disableCollapse) {
                        window.removeEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);
                        window.removeEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
                    }

                    var callbackFunctionAfterVideoComplete = function () {
                        //following all flags should set after "video_complete" tracking triggered. if it's earlier triggered video_complete will be ignored.
                        if (!iOSInlinePlayerSelf.options.disableCollapse) {
                            playerManager.isFullscreen = true;//Outstream will check this flag to select way of termination
                            playerManager.destroyWithoutSkip();//this actual termination logic should be invoked after video_complete triggered. so this callbackFunctionAfterVideoComplete is being passed into eventHandling logic
                        }
                        playerManager.isCompleted = true;
                        if (iOSInlinePlayerSelf.options.vpaid) {
                            utils.fireEvent(el_videoArea, "ended");// Fire ended event on video for VID-1367
                        }
                    };
                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_complete"}, callbackFunctionAfterVideoComplete);//this callback will be invoked after video_complete
                }
            };
        };

        /***/ },
    /* 16 */
    /***/ function(module, exports, __webpack_require__) {



        var utils = __webpack_require__(9);
        var JSVPAIDConfigure = __webpack_require__(12);
        var _logger = __webpack_require__(2);
        var log = function (message) {
            _logger.log("iOSInlineVideoPlayer: " + message);
        };
        var debug = function (message) {
            _logger.debug("iOSInlineVideoPlayer :: Events: " + message);
        };
        var error = function (message) {
            _logger.error("iOSInlineVideoPlayer :: Events: " + message);
        };

        /**
         * Events
         * @param iOSInlinePlayerSelf
         * @param playerManager
         * @param cbInjectEventToPlayer
         * @returns {{fnMainProcess: "fnMainProcess"}}
         */
        module.exports = function (iOSInlinePlayerSelf, playerManager, cbInjectEventToPlayer) {
            return {
                "fnMainProcess": function (iframeVideoWrapper) {

                    /**
                     * seconds step excutes after createIframe
                     * @param iframeVideoWrapper
                     */
                    log("fnMainProcess");

                    //expose video object in iframe
                    var an_video_ad_player = iframeVideoWrapper.contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_id);
                    playerManager.iframeVideoWrapper = iframeVideoWrapper;

                    //activate JSVPAID plug-in this should be actiavated before video.js intialized
                    if (iOSInlinePlayerSelf.options.vpaid) {
                        try {
                            JSVPAIDConfigure(playerManager);
                        } catch (ex) {
                            error(ex);
                        }
                    } else {
                        //Cleanup previous plugin reference.
                        if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.plugins){
                            iOSInlinePlayerSelf.options.plugins = null;
                        }
                    }

                    iOSInlinePlayerSelf.options.nativeControlsForTouch = false;
                    iOSInlinePlayerSelf.options.customControlsOnMobile = false;
                    //create player object from video.js. this is required to have same code with regular one which is not iOS inline video
                    iOSInlinePlayerSelf.videojsPlayer = iOSInlinePlayerSelf.videojsOrigin(an_video_ad_player, iOSInlinePlayerSelf.options, function () {
                    });


                    __webpack_require__(17)(iOSInlinePlayerSelf, playerManager, cbInjectEventToPlayer, iOSInlinePlayerSelf.videojsPlayer, iframeVideoWrapper).run();

                    playerManager.adVideoPlayer = iOSInlinePlayerSelf.videojsPlayer;//inject video.js API reference to outside. this object includes all methods supported by video.js and html objects generated by video.js for example) controlbar, volume controls etc..

                    var el_wholeArea = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_id);//whole video area inside iframe
                    var el_videoArea = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_html5_api_id);//html5 video object inside iframe

                    if (iOSInlinePlayerSelf.options.enableInlineVideoForIos === true) {
                        //el_videoArea.style.visibility = "hidden";//html5 video should be hidden when ios-inline-player activated and it should be set before video.load() because of iOS limitation see this ticket https://jira.corp.appnexus.com/browse/VID-2096
                        el_videoArea.style.width = "0.1px";
                        el_videoArea.style.height = "0.1px";
                    }


                    var tmp = document.createElement("div");
                    tmp.style.position = "absolute";
                    tmp.style.top = "0px";
                    tmp.style.left = "0px";
                    if (!iOSInlinePlayerSelf.options.vpaid) {
                        tmp.className = "vjs-tech";//if some div uses 'vjs-tech' as a CSS className, JSVPAID will regard that must be video object
                    }
                    tmp.style.textAlign = "center";
                    el_wholeArea.insertBefore(tmp, el_videoArea);//inject target div defore video tag






                    //register this resize function to be invked by sideStream
                    iOSInlinePlayerSelf.options.targetElement.addEventListener("IOS_INLINE_RESIZE", function () {
                        iOSInlinePlayerSelf.resizeIosCanvas(false);
                    });

                    iOSInlinePlayerSelf.options.targetElement.addEventListener("IOS_INLINE_REFERESH", function () {
                        iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);
                        iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
                        iOSInlinePlayerSelf.customFullscreenBtn.style.visibility = "hidden";//hide fullscreen because iOS custom fullscreen feature doesn't work over unfriendly iframe - it only expands on the iframe area and that's not what we expect.
                    });

                    //iOSInlinePlayerSelf.options to render ios inline video
                    /**
                     * mediaURl : url of video
                     * divArea : div element to render canvas
                     * width : width of video player
                     * videoElement : video object to be used as source of video capturing
                     * cbWhenVideoComplete : callback when video completes
                     * targetElement : div element of publisher's site
                     * cbClickToBrowse : callback when click the video areas
                     * @type {{mediaUrl: (string|*), divArea: Element, width: *, videoElement: Element, cbWhenVideoComplete: Function, targetElement: (*|string), cbClickToBrowse: (*|adVideoPlayerManager.click|Function|x.event.special.click|{trigger, _default}|SCOPE.reportAnalytics.click)}}
                     */

                    var optionForInlineVideo = {
                        "mediaUrl": iOSInlinePlayerSelf.options.videoUrl,
                        "divArea": tmp,
                        "width": iOSInlinePlayerSelf.options.width,
                        "height": iOSInlinePlayerSelf.options.height,
                        "videoElement": el_videoArea,
                        "cbWhenVideoComplete": function() {iOSInlinePlayerSelf.cbWhenVideoComplete(iframeVideoWrapper,el_videoArea);},
                        "targetElement": iOSInlinePlayerSelf.options.targetElement,
                        "iframeVideoWrapper": iframeVideoWrapper,
                        "el_wholeArea": el_wholeArea,
                        "cbTimeUpdate": function () {
                            iOSInlinePlayerSelf.videojsPlayer.trigger("timeupdate");
                        }
                    };

                    var waterfallStepId = iOSInlinePlayerSelf.options.isWaterfall ? iOSInlinePlayerSelf.options.waterfallStepId : null;

                    iOSInlinePlayerSelf.iOSVideoPlayer.setPubOptions(iOSInlinePlayerSelf.options);

                    /**
                     * render inline video with options callback will invoke with flag(isAcceptable) after it preapred to start
                     */
                    iOSInlinePlayerSelf.iOSVideoPlayer.renderVideo(optionForInlineVideo, function (isAcceptable) {
                        if (!isAcceptable) {
                            debug("only works in iOS");
                            return;
                        } else {

                            iOSInlinePlayerSelf.eventOrientationChange = function () {//event handler whenever change rotation completed

                                if(waterfallStepId && waterfallStepId !== iOSInlinePlayerSelf.options.waterfallStepId){
                                    // Ignore the events as these are from previous ad attempts;
                                    return;
                                }
                                if (playerManager.isReadyToExpandForMobile) {//for VID-1515

                                    var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStreamObject  && typeof(playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
                                    if (shouldNotResizeWhenSideStreamActivated) {
                                        return;
                                    }
                                    iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);
                                    iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
                                }
                            };

                            iOSInlinePlayerSelf.eventSizeChange = function () {//event handler to catch a moment when ios addressbar appears
                                if(waterfallStepId && waterfallStepId !== iOSInlinePlayerSelf.options.waterfallStepId){
                                    // Ignore the events as these are from previous ad attempts;
                                    return;
                                }
                                if (iOSInlinePlayerSelf.isFullscreen) {//resize all when iOS h/w addressbar appears
                                    playerManager.resizeVideo(-1, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);
                                    iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
                                }
                            };

                            window.addEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
                            window.addEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);

                            el_videoArea.onseeked = function () {
                                return false;
                            };
                            if(iOSInlinePlayerSelf.options.initialPlayback === "auto"){
                                iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.show();
                            }else{
                                iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.hide();
                            }
                            iOSInlinePlayerSelf.videojsPlayer.player().off('seeked');//stop seeking because we don't use html5 video tag playing

                            iOSInlinePlayerSelf.iOSVideoPlayer.initiate();//generate required tag and initiate
                        }
                    });


                    iOSInlinePlayerSelf.videojsPlayer.controlBar.fullscreenToggle.dispose();//dispose exisitng fullscreen icon which has lots of issue causing by event bubbleing from video.js in its Component block

                    if (iOSInlinePlayerSelf.options.allowFullscreen === true && iOSInlinePlayerSelf.enableFullscreen) {

                        iOSInlinePlayerSelf.customFullscreenBtn = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
                            'role': 'button',
                            //'innerHTML': 'FullScreen',
                            'innerHTML': '<div class="vjs-control-content"><span class="vjs-control-text">Fullscreen</span></div>'
                        });
                        iOSInlinePlayerSelf.customFullscreenBtn.style.cssText = "text-align:right;float:right;margin-right:0em;font-size:1em;line-height:3em;outline:0;position:relative;padding:0;height:3em";

                        iOSInlinePlayerSelf.customFullscreenBtn.className = "vjs-fullscreen-control vjs-control";

                        iOSInlinePlayerSelf.videojsPlayer.controlBar.addChild('button', {
                            'el': iOSInlinePlayerSelf.customFullscreenBtn
                        });

                        /**
                         * handle fullscreen on inline inveo
                         */
                        iOSInlinePlayerSelf.customFullscreenBtn.addEventListener("touchend", function (e) {

                            if (!iOSInlinePlayerSelf.isFullscreen) {
                                iOSInlinePlayerSelf.handleFullScreen(iframeVideoWrapper);
                            } else {
                                var videoElement = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_html5_api_id);//html5 video object inside iframe
                                var originalVisibilityOfVideo = videoElement.style.visibility;
                                videoElement.style.visibility = "hidden";//for VID-2793, some of jsvpaid creative can have unexpected event from windows during this switching if video deosn't have hidden attribute at this short moment in iOS10 with inline module, but it will be restored immediately
                                setTimeout(function() {
                                    iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
                                    videoElement.style.visibility = originalVisibilityOfVideo;//restore previous visilibity state
                                },0);//block async execution
                            }
                            e.preventDefault();
                        });

                        iOSInlinePlayerSelf.customFullscreenBtn.addEventListener("click", function () {
                            if (!iOSInlinePlayerSelf.isFullscreen) {
                                iOSInlinePlayerSelf.handleFullScreen(iframeVideoWrapper);

                            } else {
                                iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);

                            }

                        });
                    }


                    /**
                     * click to browse, this will get canvas object through getCanvas() interface of ios inline video player and dispatch signal to API
                     */
                    iOSInlinePlayerSelf.iOSVideoPlayer.getCanvas().onclick = function () {
                        iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();//this pause should be called because of internal issue on iOSInlineCore. but this pause doesn't belong pause event.
                        playerManager.click();
                    };

                    //function to switch an playtoggle icon
                    var havePauseStatusIcon = function (isPaused) {
                        if (isPaused) {
                            iOSInlinePlayerSelf.customPlayToggle.innerHTML = '<div><span>&#xe001;</span></div>';//icon to pause video
                        } else {
                            iOSInlinePlayerSelf.customPlayToggle.innerHTML = '<div><span>&#xe002;</span></div>';//icon to play video
                        }
                    };


                    var simulateHtml5VideoPlay = function () {
                        /**
                         * this is for overriding play method in html5 video
                         * it support intial play and resume video by "isPlayingVideo" flag
                         * if it's true it will resume a video, if else it will do initial play a video
                         */
                        //hide play button
                        iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.hide();
                        iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.hide();//hide loading spinner

                        iOSInlinePlayerSelf.videojsPlayer.player().addClass("vjs-has-started");
                        iOSInlinePlayerSelf.videojsPlayer.player().removeClass('vjs-paused');
                        iOSInlinePlayerSelf.videojsPlayer.player().addClass('vjs-playing');

                        //play video when its fist play
                        try {
                            havePauseStatusIcon(false);

                            var enabledAudio = iOSInlinePlayerSelf.enabledAudio;
                            iOSInlinePlayerSelf.iOSVideoPlayer.initialPlay(enabledAudio);//invoke initialPlay in iOSVideoPlayer, this initialPlay will set a required value for initial playing
                            debug("override play method");

                            if (!iOSInlinePlayerSelf.isDoneiOSInitialPlay) {
                                utils.fireEvent(el_videoArea, "play");//for VID-1331
                                iOSInlinePlayerSelf.isDoneiOSInitialPlay = true;
                            } else {
                                utils.fireEvent(el_videoArea, "playing");//for VID-1331
                            }

                            playerManager.isPlayingVideo = true;
                            iOSInlinePlayerSelf.isTogglePaused = false;
                        } catch (ex) {
                            error(ex);
                        }
                    };

                    /**
                     * pause
                     */
                    var simulateHtml5VideoPause = function () {

                        if (iOSInlinePlayerSelf.isTogglePaused) {

                            return;//don't need to do again when it's already paused.
                        }

                        if (playerManager.isCompleted) {
                            return;
                        }

                        //show big play button
                        iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.show();
                        iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.el().style.display = "block";

                        iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
                        debug("override pause method");

                        havePauseStatusIcon(true);
                        iOSInlinePlayerSelf.isTogglePaused = true;

                        utils.fireEvent(el_videoArea, "pause");//for VID-1331,VID-1510

                    };


                    //override play & pause method which is under html5 object to intercept flow in html5
                    var overrideNativeMethodForVideo = function () {
                        var checkAndLoadVideo = function (el) {
                            if (el && el.readyState === 0) {
                                el.load();//this is required for start inline video player
                            }
                        };

                        el_videoArea.play = function () {
                            checkAndLoadVideo(el_videoArea);
                            simulateHtml5VideoPlay();
                        };
                        el_videoArea.pause = function () {
                            simulateHtml5VideoPause();
                        };

                        iOSInlinePlayerSelf.videojsPlayer.one("vpaid.AdStarted", function () {//after vpaid returns "AdStarted" the video object would have a src attribute to be able to load immediately
                            checkAndLoadVideo(el_videoArea);
                        });

                        iOSInlinePlayerSelf.videojsPlayer.one("an.readytogovpaid", function () {//after vpaid returns "AdStarted" the video object would have a src attribute to be able to load immediately
                            iOSInlinePlayerSelf.iOSVideoPlayer.activateAudio();
                            checkAndLoadVideo(el_videoArea);
                        });


                    };


                    if (iOSInlinePlayerSelf.options.vpaid) {
                        overrideNativeMethodForVideo();
                    } else {
                        el_videoArea.play = simulateHtml5VideoPlay;
                        el_videoArea.pause = simulateHtml5VideoPause;
                    }

                    /**
                     * //TODO for ios limiation we can't use html5 standard full screen api, so for several reason related human's behavoir we will need to igonre gesture in the full screen of ios video player
                     */
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.el().ontouchend = function () {
                    };


                    /**
                     * handle pause / resume
                     */
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.playToggle.dispose();//dispose to disconnect video.js event
                    iOSInlinePlayerSelf.customPlayToggle = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
                        'role': 'button',
                        'aria-live': 'polite',
                        'tabindex': '0',
                        'innerHTML': '<div><span>&#xe002;</span></div>',
                        'width': '5em'
                    });
                    iOSInlinePlayerSelf.customPlayToggle.style.cssText = "float:left;font-family:VideoJS;font-size:1.5em;line-height:2;width:3em;height:100%;text-align:center";
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.addChild('button', {
                        'el': iOSInlinePlayerSelf.customPlayToggle
                    });
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.el().insertBefore(iOSInlinePlayerSelf.customPlayToggle, iOSInlinePlayerSelf.videojsPlayer.controlBar.currentTimeDisplay.el());

                    iOSInlinePlayerSelf.customPlayToggle.ontouchend = function (e) {

                        if (iOSInlinePlayerSelf.isTogglePaused === false) {
                            playerManager.explicitPause();
                        } else {
                            playerManager.explicitPlay();
                        }

                        e.preventDefault();
                    };
                    iOSInlinePlayerSelf.customPlayToggle.onclick = function () {

                        if (iOSInlinePlayerSelf.isTogglePaused === false) {
                            playerManager.explicitPause();
                        } else {
                            playerManager.explicitPlay();
                        }
                    };

                    /**
                     * handle unmute to initiaite audio
                     */
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el().ontouchend = function () {


                        if (!iOSInlinePlayerSelf.enabledAudio) {
                            iOSInlinePlayerSelf.iOSVideoPlayer.hearAudio();
                            iOSInlinePlayerSelf.enabledAudio = true;
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "1";
                            playerManager.dispatchEventToAdunit({"name": "video_unmute"});

                            if (iOSInlinePlayerSelf.isTogglePaused === true) {//if paused, not playing audio
                                iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
                            }
                        } else {
                            iOSInlinePlayerSelf.iOSVideoPlayer.stopAudio();
                            iOSInlinePlayerSelf.enabledAudio = false;
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
                            playerManager.dispatchEventToAdunit({"name": "video_mute"});
                        }
                    };
                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el().onclick = function () {


                        if (!iOSInlinePlayerSelf.enabledAudio) {
                            iOSInlinePlayerSelf.iOSVideoPlayer.hearAudio();
                            iOSInlinePlayerSelf.enabledAudio = true;
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "1";

                            if (iOSInlinePlayerSelf.isTogglePaused === true) {//if paused, not playing audio
                                iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
                            }
                        } else {
                            iOSInlinePlayerSelf.iOSVideoPlayer.stopAudio();
                            iOSInlinePlayerSelf.enabledAudio = false;

                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
                        }
                    };

                    //invoke cbWhenReady immediately for jspaid
                    iOSInlinePlayerSelf.videojsPlayer.one("loadedmetadata", function (e) {//one time handlers because iOS core also invoke .load so we have to supress seconds event
                        if (iOSInlinePlayerSelf.options.showPlayToggle === false) {
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.playToggle.hide();
                        }

                        if (iOSInlinePlayerSelf.options.showBigPlayButton === false) {
                            iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.hide();
                        }


                        //set showMute
                        if (iOSInlinePlayerSelf.options.showMute === false) {
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.hide();
                        } else {
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.show();//always show unmute
                            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
                        }


                        if (playerManager.options.vpaid) {
                            return;//VID1707 - vapid creative shouldn't be handled by loadedmetata. it only works with vpaid event
                        }

                        playerManager.isReadyToExpandForMobile = true;

                        playerManager.videoObjectId = e.currentTarget.id;

                        debug("loadedmetadata");
                        debug("video.js is ready to play");

                        //disable click to play
                        iOSInlinePlayerSelf.videojsPlayer.tech.removeControlsListeners();

                        //get real video size
                        var realVideoWidth = e.currentTarget.videoWidth;
                        var realVideoHeight = e.currentTarget.videoHeight;
                        var aspectRatio = realVideoWidth / realVideoHeight;


                        if (realVideoWidth > 0) {
                            playerManager.resizeVideo(aspectRatio, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);

                            if (typeof iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady === "function") {
                                iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
                            }
                        } else {
                            //if the event doesn't return a videoWidth
                            playerManager.resizeVideo(0, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);
                            iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
                        }

                    });


                    cbInjectEventToPlayer(el_wholeArea, el_videoArea);//inject generate html object to next step of video player manager

                    if (iOSInlinePlayerSelf.options.vpaid) {
                        iOSInlinePlayerSelf.videojsPlayer.trigger("an.doneInitialize");
                    }

                },
            };

        };

        /***/ },
    /* 17 */
    /***/ function(module, exports, __webpack_require__) {

        //stop js-hint warning for dot notation
        /*jshint -W069 */

        var _logger = __webpack_require__(2);
        var debug = function (message) {
            _logger.debug("iOSInlineVideoPlayer :: CustomizeVideoArea: " + message);
        };
        var verbose = function (message) {
            _logger.verbose("Video Player: " + message);
        };

        var CONST_MESSAGE_GENERAL_ERROR = "General error reported from HTML5 video player (iOS inline)";


        /**
         * CustomizeVideoArea
         * @param iOSInlinePlayerSelf
         * @param playerManager
         * @param cbInjectEventToPlayer
         * @param videojsPlayer
         * @param iframeVideoWrapper
         * @returns {{run: "run"}}
         */
        module.exports = function(iOSInlinePlayerSelf,playerManager, cbInjectEventToPlayer,videojsPlayer, iframeVideoWrapper) {
            return {
                "run": function () {

                    debug("run");

                    /**
                     * customize video.js UI by by options coming from impbus or publisher's site
                     */

                    if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.vpaid){
                        //For vpaid ads in waterfall hide controls until the impression occurs to avoid flicker during failed attempts.
                        videojsPlayer.controlBar.hide();
                        if(iOSInlinePlayerSelf.options.firstAdAttempted) {
                            videojsPlayer.bigPlayButton.hide();
                        }
                    }

                    if (typeof iOSInlinePlayerSelf.options.customButton.enabled === "boolean" && iOSInlinePlayerSelf.options.customButton.enabled === true) {
                        var customButton = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
                            'innerHTML': '<a href="'+iOSInlinePlayerSelf.options.customButton.url+'" target="_blank"><img style="height:'+iOSInlinePlayerSelf.options.customButton.imgHeight+'px;width:'+iOSInlinePlayerSelf.options.customButton.imgWidth+'px" class="home-button-image" src="'+iOSInlinePlayerSelf.options.customButton.imageSrc+'" alt="'+iOSInlinePlayerSelf.options.customButton.altText+'"></a>',
                            'role': 'button',
                            'aria-live': 'polite',
                            'tabindex': '0'
                        });

                        customButton.style.cssText = "float:right;font-family:VideoJS;font-size:1.5em;line-height:2;width:50px;height:100%;text-align:center";
                        videojsPlayer.controlBar.addChild('button', {
                            'el': customButton
                        });
                        videojsPlayer.controlBar.el().insertBefore(customButton, videojsPlayer.controlBar.fullscreenToggle.el());
                    }

                    //set showProgressBar
                    videojsPlayer.controlBar.progressControl.seekBar.seekHandle.hide();
                    videojsPlayer.controlBar.progressControl.seekBar.el_.style.pointerEvents = 'none';
                    if (typeof iOSInlinePlayerSelf.options.showProgressBar === "boolean") {
                        if (iOSInlinePlayerSelf.options.showProgressBar === false) {
                            verbose("removing progress bar");
                            videojsPlayer.controlBar.currentTimeDisplay.hide();
                            videojsPlayer.controlBar.timeDivider.hide();
                            videojsPlayer.controlBar.durationDisplay.hide();
                        }
                        videojsPlayer.controlBar.progressControl.seekBar.hide();
                    } else {
                        if (iOSInlinePlayerSelf.options.showProgressBar === "text") {
                            verbose("removing progress text");
                            videojsPlayer.controlBar.progressControl.seekBar.hide();
                        } else if (iOSInlinePlayerSelf.options.showProgressBar === "bar") {
                            verbose("removing progress bar");
                            videojsPlayer.controlBar.currentTimeDisplay.hide();
                            videojsPlayer.controlBar.timeDivider.hide();
                            videojsPlayer.controlBar.durationDisplay.hide();
                        }
                    }

                    //set showVolumee
                    if (iOSInlinePlayerSelf.options.showVolume === false) {
                        videojsPlayer.controlBar.volumeControl.dispose();
                    }

                    //options.bottomDividerColor and iOSInlinePlayerSelf.options.bottomDividerWidth is gurantted by ExtendDefaultOpions.js to have a some default value
                    //create custom divider
                    var customDivider = iOSInlinePlayerSelf.videojsOrigin.createEl('div');
                    customDivider.className = "vjs-control-bar-divider";
                    //minthe : comment out beacuse "customDividerColor" is defined but never used
                    /*
                     var customDividerColor = (function () {
                     return "#" + iOSInlinePlayerSelf.options.bottomDividerColor.toLowerCase().replace("0x", "");
                     })(iOSInlinePlayerSelf.options.customDividerColor);
                     */
                    //set css for divider
                    customDivider.style['position'] = "absolute";
                    customDivider.style['left'] = "0";
                    customDivider.style['right'] = "0";
                    //add divder to controlbar
                    videojsPlayer.controlBar.addChild('button', {
                        'el': customDivider
                    });

                    var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

                    var adIndicatorText = iframeVideoWrapper.contentWindow.document.createElement("div");
                    adIndicatorText.id = "ad_indicator_text";

                    adIndicatorText.innerHTML = iOSInlinePlayerSelf.options.adText;
                    adIndicatorText.className = 'top-bar-text';
                    adIndicatorText.role = 'button';

                    adIndicatorText.style['text-align'] = "right";
                    adIndicatorText.style['margin-right'] = "1em";
                    adIndicatorText.style['margin-left'] = "1em";
                    adIndicatorText.style['font-size'] = "1em";
                    adIndicatorText.style['right'] = "0px";
                    adIndicatorText.style['left'] = "";
                    adIndicatorText.style['line-height'] = "24px";
                    adIndicatorText.style['outline'] = "0";
                    adIndicatorText.style['position'] = "absolute";
                    adIndicatorText.style['padding'] = "0";
                    adIndicatorText.style['height'] = "auto";
                    adIndicatorText.style['width'] = "auto";
                    adIndicatorText.style['max-width'] = "35%";
                    adIndicatorText.style['white-space'] = "nowrap";
                    adIndicatorText.style['overflow'] = "hidden";
                    adIndicatorText.style['text-overflow'] = "ellipsis";
                    adIndicatorText.style['pointer-events'] = "none";

                    iOSInlinePlayerSelf.floatingAdIndicator = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
                        'role': 'button',
                        'innerHTML': iOSInlinePlayerSelf.options.adText,
                        'className': "top-bar-text"
                    });

                    iOSInlinePlayerSelf.floatingAdIndicator.style['text-align'] = "right";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['margin-right'] = "1em";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['margin-left'] = "1em";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['font-size'] = "1em";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['right'] = "0px";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['left'] = "";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['line-height'] = "3em";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['outline'] = "0";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['position'] = "absolute";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['padding'] = "0";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['height'] = "3em";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['max-width'] = "35%";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['width'] = "auto";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['text-overflow'] = "ellipsis";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['white-space'] = "nowrap";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['overflow'] = "hidden";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['pointer-events'] = "none";
                    iOSInlinePlayerSelf.floatingAdIndicator.style['display'] = "none";
                    videojsPlayer.addChild('button', {
                        'el': iOSInlinePlayerSelf.floatingAdIndicator
                    });


                    var skipButton;
                    var adSkipText;

                    //set skip button
                    if (iOSInlinePlayerSelf.options.skippable.enabled === true) {

                        var videoThreshold = iOSInlinePlayerSelf.options.skippable.videoThreshold;
                        var skipText = iOSInlinePlayerSelf.options.skippable.skipText;
                        var skipButtonText = iOSInlinePlayerSelf.options.skippable.skipButtonText;

                        skipButton = iframeVideoWrapper.contentWindow.document.createElement("div");
                        skipButton.id = "skip_button";

                        skipButton.innerHTML = skipButtonText;
                        skipButton.className = 'top-bar-text';
                        skipButton.role = 'button';

                        skipButton.style['display'] = "none";
                        skipButton.style['cursor'] = "pointer";
                        skipButton.style['font-weight'] = "bold";
                        skipButton.style['margin-right'] = "1em";
                        skipButton.style['margin-left'] = "1em";
                        skipButton.style['font-size'] = "1em";
                        skipButton.style['right'] = "";
                        skipButton.style['left'] = "0px";
                        skipButton.style['line-height'] = "24px";
                        skipButton.style['outline'] = "0";
                        skipButton.style['position'] = "absolute";
                        skipButton.style['padding'] = "0";
                        skipButton.style['height'] = "5em";
                        skipButton.style['width'] = "auto";
                        skipButton.style['min-width'] = "5em";
                        skipButton.style['text-align'] = "left";

                        //skip button
                        iOSInlinePlayerSelf.floatingSkipButton = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
                            className: 'top-bar-text',
                            'role': 'button',
                            'innerHTML': skipButtonText
                        });

                        iOSInlinePlayerSelf.floatingSkipButton.style['display'] = "none";
                        iOSInlinePlayerSelf.floatingSkipButton.style['cursor'] = "pointer";
                        iOSInlinePlayerSelf.floatingSkipButton.style['font-weight'] = "bold";
                        iOSInlinePlayerSelf.floatingSkipButton.style['margin-right'] = "1em";
                        iOSInlinePlayerSelf.floatingSkipButton.style['margin-left'] = "1em";
                        iOSInlinePlayerSelf.floatingSkipButton.style['font-size'] = "1em";
                        iOSInlinePlayerSelf.floatingSkipButton.style['right'] = "";
                        iOSInlinePlayerSelf.floatingSkipButton.style['left'] = "0px";
                        iOSInlinePlayerSelf.floatingSkipButton.style['line-height'] = "3em";
                        iOSInlinePlayerSelf.floatingSkipButton.style['outline'] = "0";
                        iOSInlinePlayerSelf.floatingSkipButton.style['position'] = "absolute";
                        iOSInlinePlayerSelf.floatingSkipButton.style['padding'] = "0";
                        iOSInlinePlayerSelf.floatingSkipButton.style['height'] = "5em";
                        iOSInlinePlayerSelf.floatingSkipButton.style['min-width'] = "5em";
                        iOSInlinePlayerSelf.floatingSkipButton.style['width'] = "auto";
                        iOSInlinePlayerSelf.floatingSkipButton.style['display'] = "none";
                        iOSInlinePlayerSelf.floatingSkipButton.style['text-align'] = "left";
                        videojsPlayer.addChild('button', {
                            'el': iOSInlinePlayerSelf.floatingSkipButton
                        });

                        var handleSkip = function(e) {
                            window.removeEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);
                            window.removeEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
                            iOSInlinePlayerSelf.iOSVideoPlayer.destroy();
                            playerManager.pause();
                            playerManager.isFullscreen = iOSInlinePlayerSelf.isFullscreen;//to propogate iOS full screen state to VideoManager
                            playerManager.forceToSkip = true;
                            playerManager.destroy();
                            playerManager.isCompleted = true;//added for VID-1035 moved for vid-1171
                            e.stopPropagation();
                            e.preventDefault();
                            // videoObserver.disconnect();
                        };

                        skipButton.addEventListener("touchend", handleSkip);
                        skipButton.addEventListener("click", handleSkip);

                        iOSInlinePlayerSelf.floatingSkipButton.addEventListener("touchend", handleSkip);
                        iOSInlinePlayerSelf.floatingSkipButton.addEventListener("click", handleSkip);

                        adSkipText = iframeVideoWrapper.contentWindow.document.createElement("div");
                        adSkipText.id = "ad_skip_text";

                        adSkipText.innerHTML = skipButtonText;
                        adSkipText.className = 'top-bar-text';
                        adSkipText.role = 'button';

                        adSkipText.style['margin-left'] = "1em";
                        adSkipText.style['margin-right'] = "1em";
                        adSkipText.style['right'] = "";
                        adSkipText.style['left'] = "0px";
                        adSkipText.style['font-size'] = "1em";
                        adSkipText.style['line-height'] = "24px";
                        adSkipText.style['outline'] = "0";
                        adSkipText.style['position'] = "absolute";
                        adSkipText.style['text-align'] = "left";
                        adSkipText.style['padding'] = "0";
                        adSkipText.style['height'] = "3em";
                        adSkipText.style['width'] = "auto";
                        adSkipText.style['pointer-events'] = "none";
                        adSkipText.style['display'] = "none";



                        //skip text
                        iOSInlinePlayerSelf.floatingAdSkipText = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
                            'role': 'button',
                            'className': 'top-bar-text',
                            'innerHTML': ""
                        });

                        iOSInlinePlayerSelf.floatingAdSkipText.style['margin-left'] = "1em";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['margin-right'] = "1em";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['right'] = "";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['left'] = "0px";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['font-size'] = "1em";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['line-height'] = "3em";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['outline'] = "0";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['position'] = "absolute";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['text-align'] = "left";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['padding'] = "0";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['height'] = "3em";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['width'] = "auto";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['pointer-events'] = "none";
                        iOSInlinePlayerSelf.floatingAdSkipText.style['display'] = "none";
                        videojsPlayer.addChild('button', {
                            'el': iOSInlinePlayerSelf.floatingAdSkipText
                        });

                        //switch position by option
                        switch (iOSInlinePlayerSelf.options.skippable.skipLocation) {
                            case "top-right":
                                skipButton.style['right'] = "0px";
                                skipButton.style['left'] = "";
                                skipButton.style['text-align'] = "right";

                                adSkipText.style['right'] = "0px";
                                adSkipText.style['left'] = "";

                                iOSInlinePlayerSelf.floatingSkipButton.style['right'] = "0px";
                                iOSInlinePlayerSelf.floatingSkipButton.style['left'] = "";
                                iOSInlinePlayerSelf.floatingSkipButton.style['text-align'] = "right";

                                iOSInlinePlayerSelf.floatingAdSkipText.style['right'] = "0px";
                                iOSInlinePlayerSelf.floatingAdSkipText.style['left'] = "";
                                break;
                            default :
                                break;
                        }

                        //quartile status to invoke only once
                        var quartile1status = false;
                        var quartile2status = false;
                        var quartile3status = false;

                        //handle tick event from video.js
                        videojsPlayer.on("timeupdate", function () {
                            if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.vpaid && !iOSInlinePlayerSelf.options.vpaidImpressionFired){
                                return;
                            }
                            var currentTime = Math.round(videojsPlayer.player().currentTime());
                            var offsetTime = iOSInlinePlayerSelf.options.skippable.videoOffset;
                            var remainTime = offsetTime - currentTime;
                            var videoDuration = Math.round(videojsPlayer.player().duration());

                            if (videoThreshold <= videoDuration && !iOSInlinePlayerSelf.options.disableTopBar) {
                                if (remainTime > 0) {
                                    iOSInlinePlayerSelf.floatingAdSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
                                    adSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);

                                    adSkipText.style.display = "block";
                                    skipButton.style.display = "none";
                                } else {
                                    iOSInlinePlayerSelf.readyForSkip = true;

                                    if (iOSInlinePlayerSelf.isFullscreen) {
                                        iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
                                        iOSInlinePlayerSelf.floatingSkipButton.style.display = "block";
                                    }

                                    adSkipText.style.display = "none";
                                    skipButton.style.display = "block";
                                }
                            }
                        });
                    }

                    //switch position by option
                    if (iOSInlinePlayerSelf.options.skippable && iOSInlinePlayerSelf.options.skippable.skipLocation) {
                        switch (iOSInlinePlayerSelf.options.skippable.skipLocation) {
                            case "top-right":
                                adIndicatorText.style['right'] = "";
                                adIndicatorText.style['left'] = "0px";

                                iOSInlinePlayerSelf.floatingAdIndicator.style['right'] = "";
                                iOSInlinePlayerSelf.floatingAdIndicator.style['left'] = "0px";
                                break;
                            default :
                                break;
                        }
                    }

                    if (!iOSInlinePlayerSelf.options.disableTopBar && topChrome) {
                        if (iOSInlinePlayerSelf.options.skippable.enabled === true) {
                            topChrome.appendChild(skipButton);
                            topChrome.appendChild(adSkipText);
                        }
                        topChrome.appendChild(adIndicatorText);
                    }


                    //set quartile event
                    videojsPlayer.on("timeupdate", function () {
                        if (iOSInlinePlayerSelf.options.vpaid) {
                            return;
                        }
                        var currentTime = Math.round(videojsPlayer.player().currentTime());
                        var videoDuration = videojsPlayer.player().duration();

                        var quartile1 = videoDuration / 4;
                        var quartile2 = videoDuration / 4 * 2;
                        var quartile3 = videoDuration / 4 * 3;


                        if (!quartile1status && currentTime >= quartile1 && currentTime < quartile2) {
                            iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-first-quartile"});
                            quartile1status = true;
                        }

                        if (!quartile2status && currentTime >= quartile2 && currentTime < quartile3) {
                            iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-mid"});
                            quartile2status = true;
                        }

                        if (!quartile3status && currentTime >= quartile3) {
                            iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-third-quartile"});
                            quartile3status = true;
                        }
                    });

                    var handleBigPlayButton = function() {
                        if (playerManager.isDoneInitialPlay) {
                            playerManager.isPlayingVideo = false;
                        }
                        playerManager.explicitPlay();
                    };

                    //for mobile
                    videojsPlayer.player().bigPlayButton.on("touchend", function (e) {
                        handleBigPlayButton();
                        e.preventDefault();
                    });
                    videojsPlayer.player().bigPlayButton.on("click", function() {
                        handleBigPlayButton();
                    });

                    videojsPlayer.on("error", function () {
                        playerManager.destroyWithoutSkip(true, CONST_MESSAGE_GENERAL_ERROR,null, 900);
                    });


                    //change event handling part here for VID-1820, the issue is caused by that "firstplay" gets invoked earlier than "play" and that interferes with flags which will decide to invoke events
                    //and we were waiting this "firstplay" to fire VAST "start" but it's unnecessary because iOS inline fakes "play" method of video element and modules will invoke "video_start" explicitly.
                    //so it will be okay not to handle firstplay for iOS
                    // videojsPlayer.on("firstplay", function () {
                    //     iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "firstplay"});
                    // });

                    videojsPlayer.on("loadstart", function () {
                        iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "loadstart"});
                    });

                    videojsPlayer.on("pause", function () {
                        //iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_pause"});

                        //show big resume
                        if (!playerManager.isFullscreen) {
                            videojsPlayer.player().bigPlayButton.el().style.display = "block";
                        }


                    });


                },
            };
        };

        /***/ },
    /* 18 */
    /***/ function(module, exports, __webpack_require__) {

        var _logger = __webpack_require__(2);
        var log = function (message) {
            _logger.log("Video Player: " + message);
        };
        var debug = function (message) {
            _logger.debug("Video Player: " + message);
        };

        /**
         * InitializeElements
         * @param iOSInlinePlayerSelf
         * @param playerManager
         * @returns {{acreateIframeAndRequiredObject: acreateIframeAndRequiredObject}}
         */
        module.exports = function (iOSInlinePlayerSelf, playerManager) {


            return {

                createIframeAndRequiredObject: function (cbNextStep) {
                    /**
                     * first step to generate iframe and preapr all requried html objects
                     * @param cbNextStep
                     */

                    log("createIframeAndRequiredObject");

                    var options = iOSInlinePlayerSelf.options;

                    var iframeVideoWrapper = document.createElement("iframe");//generate iframe
                    iframeVideoWrapper.src = "about:blank";
                    options.targetElement.appendChild(iframeVideoWrapper);
                    iframeVideoWrapper.style.width = options.width + "px";
                    iframeVideoWrapper.style.height = options.height + "px";
                    iframeVideoWrapper.id = options.iframeVideoWrapperId;
                    iframeVideoWrapper.setAttribute("allowfullscreen", "true");//allow fullscreen in iframe
                    iframeVideoWrapper.setAttribute("webkitallowfullscreen", "true");
                    iframeVideoWrapper.setAttribute("mozallowfullscreen", "true");

                    //temporary allowing setting of fullscreen video button to be enabled for QA and off for production
                    if (typeof options.enableInlineVideoFullscreenButton !== 'undefined') {
                        iOSInlinePlayerSelf.enableFullscreen = options.enableInlineVideoFullscreenButton;
                    }

                    var IframeDocument = iframeVideoWrapper.contentWindow.document;
                    var IframeWindow = iframeVideoWrapper.contentWindow.window;

                    //create top chrome bar
                    debug("Creating and styling top chrome bar");
                    var topChrome = IframeDocument.createElement("div");
                    topChrome.id = "top_chrome";
                    topChrome.style.height = (function () {
                        if (options.playerSkin && typeof options.playerSkin.dividerHeight === "number") {
                            return iOSInlinePlayerSelf.topChromeHeight - options.playerSkin.dividerHeight + "px";
                        }
                        return iOSInlinePlayerSelf.topChromeHeight - 1 + "px";
                    })();
                    topChrome.style.width = options.width + "px";
                    topChrome.style.marginRight = "auto";
                    topChrome.style.marginLeft = "auto";
                    topChrome.className = "video-js vjs-default-skin";

                    //generate video object
                    debug("Generating and styling video object");
                    var videoEl = IframeDocument.createElement("video");
                    videoEl.id = iOSInlinePlayerSelf.an_video_ad_player_id;
                    videoEl.className = "video-js vjs-default-skin";//set default skin
                    videoEl.style.marginRight = "auto";
                    videoEl.style.marginLeft = "auto";
                    topChrome.style["z-index"] = videoEl.style["z-index"] + 1;

                    if (!options.vpaid) {
                        //generate source object
                        debug("Generating source object");
                        var mp4Source = IframeDocument.createElement("source");
                        mp4Source.type = "video/mp4";
                        mp4Source.src = options.videoUrl;
                        videoEl.appendChild(mp4Source);
                    }

                    //inject required object into iframe
                    debug("Injecting required elements into iframe");
                    if (!options.disableTopBar) {
                        IframeDocument.body.appendChild(topChrome);
                    }
                    IframeDocument.body.appendChild(videoEl);
                    playerManager.customSkinning.render(iOSInlinePlayerSelf,IframeDocument,true);
                    IframeWindow.videojs = iOSInlinePlayerSelf.videojsOrigin;


                    IframeDocument.body.style.margin = "0px";
                    IframeDocument.body.style.overflow = "hidden";

                    if (options.vpaid) {
                        //inject javascript vpaid module to iframe
                        var videojsVpaidScript = IframeDocument.createElement("script");
                        videojsVpaidScript.innerHTML = playerManager.videojs_vpaid;
                        IframeDocument.head.appendChild(videojsVpaidScript);
                    }

                    cbNextStep(iframeVideoWrapper);//pass prepared iframe object


                }

            };
        };

        /***/ },
    /* 19 */
    /***/ function(module, exports) {

        /**
         * flashVideoPlayer
         * @param adVideoPlayerManager
         * @param cbInjectEventToPlayer
         */
        var flashVideoPlayer = function (adVideoPlayerManager, cbInjectEventToPlayer) {


            //getting required object from adVideoPlayerManager
            var options = adVideoPlayerManager.options;
            var targetElement = options.targetElement;
            var vpaidData = adVideoPlayerManager.vpaidData;



            //getting required object from adVideoPlayerManager (module using internal value)
            var log = adVideoPlayerManager.log.bind(adVideoPlayerManager);


            // preapare vpaid data
            if (options.vpaid) {
                vpaidData = {};
                vpaidData.adParameters = options.adParameters ? options.adParameters : null;
                vpaidData.extensions = options.extensions ? options.extensions : null;
            }


            log("WE ARE USING FLASH PLAYER");

            //generate iframe
            /*var iframeVideoWrapper = document.createElement("iframe");
             iframeVideoWrapper.style.width = options.width + "px";
             iframeVideoWrapper.style.height = options.height + "px";
             iframeVideoWrapper.id = "iframeVideoWrapper";

             targetElement.appendChild(iframeVideoWrapper);
             iframeVideoWrapper.contentWindow.document.body.style.margin = "0px";*/



            var uid = new Date().getTime() + Math.floor(Math.random() * 10000);

            var flashObj = document.createElement("object");
            flashObj.type = 'application/x-shockwave-flash';
            flashObj.data = options.flash.swf;
            flashObj.width = (adVideoPlayerManager.isChrome ? "0" : options.width) + "px";
            flashObj.height = (adVideoPlayerManager.isChrome ? "0" : options.height) + "px";
            flashObj.id = 'apn_flash_player_' + uid;

            //flashObj.style.display = 'block';


            //flashObj.style.position = 'absolute';
            flashObj.style.top = '0';
            flashObj.style.left = '0';
            if (options.hasOwnProperty('overlayPlayer')) {
                flashObj.style.width = options.width + "px";
                flashObj.style.height = options.height + "px";

            }
            else {
                flashObj.style.width = (adVideoPlayerManager.isChrome ? "0" : options.width) + "px";
                flashObj.style.height = (adVideoPlayerManager.isChrome ? "0" : options.height) + "px";
            }
            /*var par1 = document.createElement('param');
             par1.name = 'movie';
             par1.value = options.flash.swf;
             flashObj.appendChild(par1);*/
            var par2 = document.createElement('param');
            par2.name = 'flashvars';

            // set options to flashvars
            par2.value = 'video=' + encodeURIComponent(options.videoUrl) +
                '&autoplay=' + options.autoplay +
                '&initialPlayback=' + options.initialPlayback +
                '&canScale=' + options.canScale +
                '&maintainAspectRatio=' + options.maintainAspectRatio +
                '&muted=' + options.muted +
                '&showMute=' + options.showMute +
                '&showVolume=' + options.showVolume +
                '&showProgressBar=' + options.showProgressBar +
                '&allowFullscreen=' + options.allowFullscreen +
                '&playOnMouseover=false' +
                '&audioOnMouseover=false' +
                '&initialAudio=' + options.initialAudio +
                '&adText=' + options.adText +
                '&vpaid=' + options.vpaid + '&external=' + options.communicator;

            par2.value += ('&containerWidth=' + options.width + '&containerHeight=' + options.height);

            if (options.hasOwnProperty('overlayPlayer')) {
                par2.value += '&overlayPlayer=true';
            }

            if (options.hasOwnProperty('fullscreenMode')) {
                par2.value += ('&fullscreenMode=' + options.fullscreenMode);
            }

            if (options.vpaid && options.vpaidDuration) {
                par2.value += ('&vpaidDuration=' + options.vpaidDuration);
            }
            if (options.terminateUnresponsiveVPAIDCreative) {
                par2.value += ('&terminateUnresponsiveVPAIDCreative=' + options.terminateUnresponsiveVPAIDCreative);
            }
            if (options.vpaid && options.vpaidTimeout) {
                par2.value += ('&vpaidTimeout=' + options.vpaidTimeout);
            }
            if (options.cbNotification) {
                par2.value += '&needFeedback=true';
            }
            if (options.disableCollapse) {
                par2.value += ("&disableCollapse=" + options.disableCollapse);
            }
            if (options.topDividerColor) {
                par2.value += ("&dividerColor=" + options.topDividerColor);
            }
            if (options.topDividerWidth) {
                par2.value += ("&dividerWidth=" + options.topDividerWidth);
            }
            if (options.disableTopBar) {
                par2.value += ("&supressTopBar=" + options.disableTopBar);
            }
            if (options.hasOwnProperty('delayExpandUntilVPAIDImpression')) {
                par2.value += ("&delayExpandUntilVPAIDImpression=" + options.delayExpandUntilVPAIDImpression);
            }
            if (options.skippable && options.skippable.enabled === true) {
                par2.value += ('&videoThreshhold=' + options.skippable.videoThreshold +
                '&videoOffset=' + options.skippable.videoOffset +
                '&skipLocation=' + options.skippable.skipLocation +
                '&skipText=' + encodeURIComponent(options.skippable.skipText) +
                '&skipButtonText=' + encodeURIComponent(options.skippable.skipButtonText));
            }

            flashObj.appendChild(par2);
            var par3 = document.createElement('param');
            par3.name = 'allowScriptAccess';
            par3.value = 'always';
            flashObj.appendChild(par3);
            var par4 = document.createElement('param');
            par4.name = 'allowNetworking';
            par4.value = 'all';
            flashObj.appendChild(par4);
            var par5 = document.createElement('param');
            par5.name = 'allowNetworking';
            par5.value = 'all';
            flashObj.appendChild(par5);
            var par6 = document.createElement('param');
            par6.name = 'wmode';
            par6.value = 'opaque';
            flashObj.appendChild(par6);
            if (options.allowFullscreen) {
                var par7 = document.createElement('param');
                par7.name = 'allowFullScreen';
                par7.value = 'true';
                flashObj.appendChild(par7);
            }

            targetElement.appendChild(flashObj);

            adVideoPlayerManager.adVideoPlayer = flashObj;
            window[options.communicator] = adVideoPlayerManager;//re assign lastest object
            cbInjectEventToPlayer(flashObj, null);


        };

        module.exports = flashVideoPlayer;

        /***/ },
    /* 20 */
    /***/ function(module, exports, __webpack_require__) {

        var Utils = __webpack_require__(9);

        var prefixOfLog = "PlayerManager_VideoSizeHandler";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(message, prefixOfLog);
        };
        var warn = function (message) {
            APN_Logger.warn(message, prefixOfLog);
        };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };



        /**
         * resizeVideo
         * @param aspectRatio
         * @param shouldConsiderHeightOfDevice
         * @param playerManager
         */
        var resizeVideo = function(aspectRatio, shouldConsiderHeightOfDevice, playerManager, callback) {
            debug("resizeVideo");
            //handle playerManager's refernece
            var options = playerManager.options;
            var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);
            var decidePlayer = playerManager.decidePlayer.bind(playerManager);
            var iframeVideoWrapper = playerManager.iframeVideoWrapper;
            var adVideoPlayer = playerManager.adVideoPlayer;

            //set internal variables
            var calculatedWidth = options.width;
            var mediaHeight;
            var topOffset = 0;
            var bottomOffset = 0;
            var mediaAspectRatio;
            var aspectRatioOption;
            var wrapperHeight; //it was playerHeight but iframeHeight will be more clear
            var hasStaticHeight = false;
            var fixedSizePlayer = options.fixedSizePlayer;
            var vastWidth = options.video.width; //VAST width came from rendition manager
            var vastHeight = options.video.height; //VAST width came from rendition manager

            var useStaticControlBar = function() {
                return (Utils.isAndroid() || isIosInlineRequired() || options.controlBarPosition === "below");
            };


            //first step - resolve width
            if (options.autoInitialSize) {

                //VID-1788,1789
                if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if side stream is activated, resize will work with div of empty space injected by SideStream module
                    calculatedWidth = options.emptyDiv.offsetWidth;
                } else {
                    calculatedWidth = options.targetElement.offsetWidth;
                    if( calculatedWidth === 0 ){
                        calculatedWidth = options.width;
                        warn("AutoInitialSize could not find parent element width, using tag width");
                    }
                }

            }


            aspectRatioOption = options.aspectRatio || options.playerAspectRatio; // removed support for playerHeight and player_height here [deprecated]

            debug("options.height : " + options.height);
            if (Utils.isEmpty(aspectRatioOption)) {
                if (Utils.isEmpty(options.height)) {
                    aspectRatioOption = "16:9";
                } else {
                    aspectRatioOption = "none";
                }
            }

            debug("aspectRatioOption : " + aspectRatioOption);

            //set media aspect ratio by VAST value
            //TODO: do we ever look at actual selected video metadata?
            if (typeof vastWidth === "undefined" || typeof vastHeight === "undefined" || vastWidth === 0 || vastHeight === 0) {
                mediaAspectRatio = (16 / 9); //aspect ratio for 16:9
            } else {
                mediaAspectRatio = vastWidth / vastHeight;
            }

            if (!options.disableTopBar) {
                topOffset = 24; //default height for topBar
            }

            //TODO: VID-2785 - sidestream and dynamic bottomOffset don't play nice, this is a temp fix
            if (useStaticControlBar()) {
                if (!playerManager.overlayPlayer) {
                    bottomOffset += 30;
                } else {
                    bottomOffset += playerManager.adVideoPlayer.controlBar.el_.offsetHeight;
                    if (playerManager.adVideoPlayer.controlBar.progressControl) {
                        bottomOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
                    }
                }
            }

            debug("initial VAST width : " + vastWidth);
            debug("initial VAST height : " + vastHeight);
            debug("initial topOffset : " + topOffset);
            debug("initial bottomOffset : " + bottomOffset);
            debug("initial mediaAspectRatio : " + mediaAspectRatio);

            //if fixedSizePlayer is true, only use the width and height of the options for the player
            //player will never be bigger than width and height in this case
            if (fixedSizePlayer) {
                wrapperHeight = options.height;
                calculatedWidth = options.width;
                mediaHeight = options.height - topOffset - bottomOffset;
            } else {
                //if not fixed size player (we calculate size)

                //split aspect ratio option
                var ratioArray = aspectRatioOption.split(":");
                //if we have the right format aspect ratio, for example x:y
                //calculatedWidth is either options width or autoInitialSize width
                if (ratioArray.length === 2) {
                    try {
                        //For aspect ratio x:y
                        mediaAspectRatio = (ratioArray[0] / ratioArray[1]);
                    } catch (e) {
                        debug(e);
                    } //if we can't set media aspect ratio, use default value
                }
                //set media height
                mediaHeight = Math.round(calculatedWidth / mediaAspectRatio);
                wrapperHeight = mediaHeight + topOffset + bottomOffset;
            }

            options.height = wrapperHeight;
            options.mediaHeight = mediaHeight;

            if (decidePlayer(options.requiredPlayer) === "html5") {

                if (iframeVideoWrapper && typeof iframeVideoWrapper === "object" && iframeVideoWrapper.style) {

                    //Browser user agent might add an iframe border
                    //This will overwrite it
                    iframeVideoWrapper.style.border = "none";
                    iframeVideoWrapper.style.width = calculatedWidth + "px";
                    iframeVideoWrapper.style.height = wrapperHeight + "px";

                    if(iframeVideoWrapper.contentWindow){
                        var topChrome = iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
                        if (topChrome) {
                            topChrome.style.width = calculatedWidth;

                            //VID 1837 - restore original margin setting due to SideStream changed the margin, but it's important to restore it to original because of options.alignment feature on outstream, that alignement is only meaningful only on Outstream
                            topChrome.style.marginLeft = "auto";
                            topChrome.style.marginRight = "auto";
                        }
                    }

                    playerManager.adVideoPlayer.el_.style.marginLeft = "auto";
                    playerManager.adVideoPlayer.el_.style.marginRight = "auto";


                    debug("final wrapper width for html5 : " + calculatedWidth);
                    debug("final wrapper height for html5 : " + wrapperHeight);

                }

                //resize video
                adVideoPlayer.width(calculatedWidth);

                //VID-1790
                if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if SideStream is activated, targetElement should be changed to work properly at the corder of video
                    options.targetElement.style.width = calculatedWidth + "px";//VID-1808
                } else {
                    options.targetElement.style.width = "";//VID-1808
                }

                debug("resize video.js width to : " + calculatedWidth);


                debug("shouldConsiderHeightOfDevice : " + shouldConsiderHeightOfDevice);
                debug("hasStaticHeight : " + hasStaticHeight);
                debug("mediaHeight + bottomOffset + topOffset : " + (mediaHeight + bottomOffset + topOffset));
                debug("window.innerHeight : " + window.innerHeight);

                //VID-1020 if it's mobile(shouldConsiderHeightOfDevice = true)
                if (shouldConsiderHeightOfDevice && (mediaHeight + bottomOffset + topOffset) > window.innerHeight) {
                    //resize height with considering viewport height

                    var mobileVideoJSHeight = window.innerHeight - topOffset;
                    var mobileOptionsHeight = window.innerHeight;
                    var mobileMedieHeight = window.innerHeight - bottomOffset - topOffset;

                    adVideoPlayer.height(mobileVideoJSHeight);
                    options.height = mobileOptionsHeight;
                    options.mediaHeight = mobileMedieHeight;

                    debug("mobile set video.js height to : " + mobileVideoJSHeight);
                    debug("mobile options.height to : " + mobileOptionsHeight);
                    debug("mobile options.mediaHeight to : " + mobileMedieHeight);


                } else {
                    //resize video as usual
                    var desktopVideoJSHeight = mediaHeight;
                    if (!useStaticControlBar() || isIosInlineRequired()) {//iOS inline has to have bottomOffset
                        desktopVideoJSHeight += bottomOffset;
                    }

                    adVideoPlayer.height(desktopVideoJSHeight);
                    debug("desktop set video.js height to : " + desktopVideoJSHeight);
                }


            } else {
                //flash
                adVideoPlayer.width = calculatedWidth + "px";
                adVideoPlayer.height = wrapperHeight + "px";
                adVideoPlayer.style.width = calculatedWidth + "px";
                adVideoPlayer.style.height = wrapperHeight + "px";

                debug("flash width : " + calculatedWidth);
                debug("flash height : " + wrapperHeight);


            }

            options.targetElement.style.visibility = "visible";
            if (typeof(callback) === "function") {
                callback();
            }

        };

        /**
         * resizeVideoForSideStream
         * @param playerManager
         * @param width
         * @param height
         */
        var resizeVideoForSideStream = function(playerManager, width, height,cb) {


            var shouldConsiderHeightOfDevice = false;

            debug("resizeVideo-sidestream");
            //handle playerManager's refernece
            var options = playerManager.options;
            var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);
            var decidePlayer = playerManager.decidePlayer.bind(playerManager);
            var iframeVideoWrapper = playerManager.iframeVideoWrapper;
            var adVideoPlayer = playerManager.adVideoPlayer;


            //set internal variables
            var calculatedWidth = width;
            var mediaHeight;
            var topOffset = 0;
            var bottomOffset = 0;
            var mediaAspectRatio;
            var aspectRatioOption;
            var wrapperHeight; //it was playerHeight but iframeHeight will be more clear
            var fixedSizePlayer = true;//this is for sideStream and sideStream only has fixedSizePlayer
            var vastWidth = options.video.width; //VAST width came from rendition manager
            var vastHeight = options.video.height; //VAST width came from rendition manager

            var useStaticControlBar = function() {
                return (Utils.isAndroid() || isIosInlineRequired() || options.controlBarPosition === "below");
            };



            aspectRatioOption = options.aspectRatio || options.playerAspectRatio; // removed support for playerHeight and player_height here [deprecated]

            debug("options.height : " + height);
            if (Utils.isEmpty(aspectRatioOption)) {
                if (Utils.isEmpty(height)) {
                    aspectRatioOption = "16:9";
                } else {
                    aspectRatioOption = "none";
                }
            }

            debug("aspectRatioOption : " + aspectRatioOption);

            //set media aspect ratio by VAST value
            //TODO: do we ever look at actual selected video metadata?
            if (typeof vastWidth === "undefined" || typeof vastHeight === "undefined" || vastWidth === 0 || vastHeight === 0) {
                mediaAspectRatio = (16 / 9); //aspect ratio for 16:9
            } else {
                mediaAspectRatio = vastWidth / vastHeight;
            }

            if (!options.disableTopBar) {
                topOffset = 24; //default height for topBar
            }

            //TODO: VID-2785 - sidestream and dynamic bottomOffset don't play nice, this is a temp fix
            if (useStaticControlBar()) {
                if (!playerManager.overlayPlayer) {
                    bottomOffset += 30;
                } else {
                    bottomOffset += playerManager.adVideoPlayer.controlBar.el_.offsetHeight;
                    if (playerManager.adVideoPlayer.controlBar.progressControl) {
                        bottomOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
                    }
                }
            }

            debug("initial VAST width : " + vastWidth);
            debug("initial VAST height : " + vastHeight);
            debug("initial topOffset : " + topOffset);
            debug("initial bottomOffset : " + bottomOffset);
            debug("initial mediaAspectRatio : " + mediaAspectRatio);

            //if fixedSizePlayer is true, only use the width and height of the options for the player
            //player will never be bigger than width and height in this case
            if (fixedSizePlayer) {
                wrapperHeight = height;
                calculatedWidth = width;
                mediaHeight = height - topOffset - bottomOffset;
            } else {
                //if not fixed size player (we calculate size)

                //split aspect ratio option
                var ratioArray = aspectRatioOption.split(":");
                //if we have the right format aspect ratio, for example x:y
                //calculatedWidth is either options width or autoInitialSize width
                if (ratioArray.length === 2) {
                    try {
                        //For aspect ratio x:y
                        mediaAspectRatio = (ratioArray[0] / ratioArray[1]);
                    } catch (e) {
                        debug(e);
                    } //if we can't set media aspect ratio, use default value
                }
                //set media height
                mediaHeight = Math.round(calculatedWidth / mediaAspectRatio);
                wrapperHeight = mediaHeight + topOffset + bottomOffset;
            }

            //for having a size defined by side stream options
            if (height && width) {
                options.mediaHeight = mediaHeight;
            }

            if (decidePlayer(options.requiredPlayer) === "html5") {

                if (iframeVideoWrapper && typeof iframeVideoWrapper === "object" && iframeVideoWrapper.style) {

                    //Browser user agent might add an iframe border
                    //This will overwrite it
                    iframeVideoWrapper.style.border = "none";
                    iframeVideoWrapper.style.width = calculatedWidth + "px";
                    iframeVideoWrapper.style.height = wrapperHeight + "px";

                    if(iframeVideoWrapper.contentWindow){
                        var topChrome = iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
                        if (topChrome) {
                            topChrome.style.width = calculatedWidth;
                            //VID 1837 - remove margin attribute here that it's unnecessary for sidestream and the auto value can make problem to position. but it will be restored when moveback to Oustream by resizeVideo()
                            topChrome.style.marginLeft = "";
                            topChrome.style.marginRight = "";
                        }
                    }

                    playerManager.adVideoPlayer.el_.style.marginLeft = "";
                    playerManager.adVideoPlayer.el_.style.marginRight = "";


                    debug("final wrapper width for html5 : " + calculatedWidth);
                    debug("final wrapper height for html5 : " + wrapperHeight);

                }

                //resize video
                adVideoPlayer.width(calculatedWidth);

                //VID-1790
                if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if SideStream is activated, targetElement should be changed to work properly at the corder of video
                    options.targetElement.style.width = calculatedWidth + "px";//VID-1808
                } else {
                    options.targetElement.style.width = "";//VID-1808
                }

                debug("resize video.js width to : " + calculatedWidth);


                debug("shouldConsiderHeightOfDevice : " + shouldConsiderHeightOfDevice);
                debug("mediaHeight + bottomOffset + topOffset : " + (mediaHeight + bottomOffset + topOffset));
                debug("window.innerHeight : " + window.innerHeight);

                //VID-1020 if it's mobile(shouldConsiderHeightOfDevice = true)
                if (shouldConsiderHeightOfDevice && (mediaHeight + bottomOffset + topOffset) > window.innerHeight) {
                    //resize height with considering viewport height

                    var mobileVideoJSHeight = window.innerHeight - topOffset;
                    var mobileOptionsHeight = window.innerHeight;
                    var mobileMedieHeight = window.innerHeight - bottomOffset - topOffset;

                    adVideoPlayer.height(mobileVideoJSHeight);
                    // options.height = mobileOptionsHeight;
                    // options.mediaHeight = mobileMedieHeight;

                    debug("mobile set video.js height to : " + mobileVideoJSHeight);
                    debug("mobile options.height to : " + mobileOptionsHeight);
                    debug("mobile options.mediaHeight to : " + mobileMedieHeight);


                } else {
                    //resize video as usual
                    var desktopVideoJSHeight = mediaHeight;
                    if (!useStaticControlBar() || isIosInlineRequired()) {//iOS inline has to have bottomOffset
                        desktopVideoJSHeight += bottomOffset;
                    }
                    adVideoPlayer.height(desktopVideoJSHeight);
                    debug("desktop set video.js height to : " + desktopVideoJSHeight);
                }


            } else {
                //flash
                adVideoPlayer.width = calculatedWidth + "px";
                adVideoPlayer.height = wrapperHeight + "px";
                adVideoPlayer.style.width = calculatedWidth + "px";
                adVideoPlayer.style.height = wrapperHeight + "px";



                debug("flash width : " + calculatedWidth);
                debug("flash height : " + wrapperHeight);


            }

            // adVideoPlayer.style.marginLeft = "";
            // adVideoPlayer.style.marginRight = "";

            //options.targetElement.style.visibility = "visible";

            if (typeof(cb) === "function") {
                cb();
            }

        };

        /**
         * setSizeForInitialRender
         * @param _options
         */
        var setSizeForInitialRender = function(_options) {

            debug("setSizeForInitialRender");
            var calculatedWidth = _options.width;

            //if auto initial size is set to true, and offsetWidth of the target element is non-zero,
            //set the width of the contianer (if not, leave width as width in options)
            if (_options.autoInitialSize) {
                calculatedWidth = _options.targetElement.offsetWidth;

                if( calculatedWidth <= 0){
                    calculatedWidth = _options.width;
                    warn("Width of target element was not set or zero, using tag width for player instead");
                }
            }

            debug("setSizeForInitialRender using width: " + calculatedWidth);
            _options.width = calculatedWidth;
        };

        /**
         * getFinalSize including topbar and bottombar
         * @param playerManager
         * @returns {{width: number, height: number}}
         */
        var getFinalSize = function(playerManager) {
            var result = { width: 0, height: 0 };

            //TODO this should return width x height including top and bottom bar
            if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash") {
                result = { width: playerManager.adVideoPlayer.offsetWidth, height: playerManager.adVideoPlayer.offsetHeight };
            } else {
                //html5
                var _tmp = document.getElementById(playerManager.options.iframeVideoWrapperId);
                result = { width: _tmp.offsetWidth, height: _tmp.offsetHeight };
            }
            return result;
        };

        /**
         * resizePlayer
         * @param width
         * @param height
         * @param playerManager
         */
        var resizePlayer = function(width, height, playerManager) {
            debug("resizePlayer");
            //TODO who use this function? at least html5 player doesn't use this method

            if (playerManager.overlayPlayer && playerManager.adVideoPlayer) {
                if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash") {
                    playerManager.adVideoPlayer.width = width + "px";
                    playerManager.adVideoPlayer.height = height + "px";
                    playerManager.adVideoPlayer.style.width = width + "px";
                    playerManager.adVideoPlayer.style.height = height + "px";
                } else {
                    if (playerManager.iframeVideoWrapper && typeof playerManager.iframeVideoWrapper === "object") {
                        //Browser user agent might add an iframe border
                        //This will overwrite it
                        playerManager.iframeVideoWrapper.style.border = "none";
                        playerManager.iframeVideoWrapper.style.width = width + "px";
                        playerManager.iframeVideoWrapper.style.height = height + "px";

                        var topChrome = playerManager && playerManager.iframeVideoWrapper && playerManager.iframeVideoWrapper.contentWindow && playerManager.iframeVideoWrapper.contentWindow.document && playerManager.iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
                        if (topChrome) {
                            topChrome.style.width = width;
                        }
                    }

                    //resize video
                    playerManager.adVideoPlayer.width(width);
                    var topOffset = 0;
                    if (!playerManager.options.disableTopBar) {
                        topOffset = 24;
                    }
                    //TODO: VID-2785 - sidestream and dynamic bottomOffset don't play nice, this is a temp fix
                    if (Utils.isAndroid() || playerManager.isIosInlineRequired() || playerManager.options.controlBarPosition === "below") {
                        if (!playerManager.overlayPlayer) {
                            topOffset += 30;
                        } else {
                            topOffset += playerManager.adVideoPlayer.controlBar.el_.offsetHeight;
                            if (playerManager.adVideoPlayer.controlBar.progressControl) {
                                topOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
                            }
                        }
                    }
                    playerManager.adVideoPlayer.height(height - topOffset);
                }
            }
        };


        module.exports = {
            resizeVideo: resizeVideo,
            setSizeForInitialRender: setSizeForInitialRender,
            getFinalSize: getFinalSize,
            resizePlayer: resizePlayer,
            resizeVideoForSideStream: resizeVideoForSideStream
        };


        /***/ },
    /* 21 */
    /***/ function(module, exports) {

        module.exports = "/* jshint ignore:start */\n\n(function (window, document, vjs, undefined) {(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n//simple representation of the API\n\n            var IVPAIDAdUnit = (function () {\n                function IVPAIDAdUnit() {\n                    _classCallCheck(this, IVPAIDAdUnit);\n                }\n\n                _createClass(IVPAIDAdUnit, [{\n                    key: 'handshakeVersion',\n\n                    //all methods below\n                    //are async methods\n                    value: function handshakeVersion() {\n                        var playerVPAIDVersion = arguments[0] === undefined ? '2.0' : arguments[0];\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n                    }\n                }, {\n                    key: 'initAd',\n\n                    //creativeData is an object to be consistent with VPAIDHTML\n                    value: function initAd(width, height, viewMode, desiredBitrate) {\n                        var creativeData = arguments[4] === undefined ? {AdParameters: ''} : arguments[4];\n                        var environmentVars = arguments[5] === undefined ? {flashVars: ''} : arguments[5];\n                        var callback = arguments[6] === undefined ? undefined : arguments[6];\n                    }\n                }, {\n                    key: 'resizeAd',\n                    value: function resizeAd(width, height, viewMode) {\n                        var callback = arguments[3] === undefined ? undefined : arguments[3];\n                    }\n                }, {\n                    key: 'startAd',\n                    value: function startAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'stopAd',\n                    value: function stopAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'pauseAd',\n                    value: function pauseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'resumeAd',\n                    value: function resumeAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'expandAd',\n                    value: function expandAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'collapseAd',\n                    value: function collapseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'skipAd',\n                    value: function skipAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'getAdLinear',\n\n                    //properties that will be treat as async methods\n            value: function getAdLinear(callback) {}\n                }, {\n                    key: 'getAdWidth',\n            value: function getAdWidth(callback) {}\n                }, {\n                    key: 'getAdHeight',\n            value: function getAdHeight(callback) {}\n                }, {\n                    key: 'getAdExpanded',\n            value: function getAdExpanded(callback) {}\n                }, {\n                    key: 'getAdSkippableState',\n            value: function getAdSkippableState(callback) {}\n                }, {\n                    key: 'getAdRemainingTime',\n            value: function getAdRemainingTime(callback) {}\n                }, {\n                    key: 'getAdDuration',\n            value: function getAdDuration(callback) {}\n                }, {\n                    key: 'setAdVolume',\n                    value: function setAdVolume(soundVolume) {\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n                    }\n                }, {\n                    key: 'getAdVolume',\n            value: function getAdVolume(callback) {}\n                }, {\n                    key: 'getAdCompanions',\n            value: function getAdCompanions(callback) {}\n                }, {\n                    key: 'getAdIcons',\n            value: function getAdIcons(callback) {}\n                }]);\n\n                return IVPAIDAdUnit;\n            })();\n\n            exports.IVPAIDAdUnit = IVPAIDAdUnit;\n\n            Object.defineProperty(IVPAIDAdUnit, 'EVENTS', {\n                writable: false,\n                configurable: false,\n                value: ['AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange', // VPAID 2.0 new event\n                    'AdSizeChange', // VPAID 2.0 new event\n                    'AdLinearChange', 'AdDurationChange', // VPAID 2.0 new event\n                    'AdExpandedChange', 'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility\n                    'AdVolumeChange', 'AdImpression', 'AdVideoStart', 'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile', 'AdVideoComplete', 'AdClickThru', 'AdInteraction', // VPAID 2.0 new event\n                    'AdUserAcceptInvitation', 'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError']\n            });\n\n        }, {}], 2: [function (require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n    var _get = function get(_x15, _x16, _x17) { var _again = true; _function: while (_again) { var object = _x15, property = _x16, receiver = _x17; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x15 = parent; _x16 = property; _x17 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }\n\n            var IVPAIDAdUnit = require('./IVPAIDAdUnit').IVPAIDAdUnit;\n            var ALL_VPAID_METHODS = Object.getOwnPropertyNames(IVPAIDAdUnit.prototype).filter(function (property) {\n                return ['constructor'].indexOf(property) === -1;\n            });\n\n            var VPAIDAdUnit = (function (_IVPAIDAdUnit) {\n                function VPAIDAdUnit(flash) {\n                    _classCallCheck(this, VPAIDAdUnit);\n\n                    _get(Object.getPrototypeOf(VPAIDAdUnit.prototype), 'constructor', this).call(this);\n                    this._destroyed = false;\n                    this._flash = flash;\n                }\n\n                _inherits(VPAIDAdUnit, _IVPAIDAdUnit);\n\n                _createClass(VPAIDAdUnit, [{\n                    key: '_destroy',\n                    value: function _destroy() {\n                        var _this = this;\n\n                        this._destroyed = true;\n                        ALL_VPAID_METHODS.forEach(function (methodName) {\n                            _this._flash.removeCallbackByMethodName(methodName);\n                        });\n                        IVPAIDAdUnit.EVENTS.forEach(function (event) {\n                            _this._flash.offEvent(event);\n                        });\n\n                        this._flash = null;\n                    }\n                }, {\n                    key: 'isDestroyed',\n                    value: function isDestroyed() {\n                        return this._destroyed;\n                    }\n                }, {\n                    key: 'on',\n                    value: function on(eventName, callback) {\n                        this._flash.on(eventName, callback);\n                    }\n                }, {\n                    key: 'off',\n                    value: function off(eventName, callback) {\n                        this._flash.off(eventName, callback);\n                    }\n                }, {\n                    key: 'handshakeVersion',\n\n                    //VPAID interface\n                    value: function handshakeVersion() {\n                        var playerVPAIDVersion = arguments[0] === undefined ? '2.0' : arguments[0];\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n\n                        this._flash.callFlashMethod('handshakeVersion', [playerVPAIDVersion], callback);\n                    }\n                }, {\n                    key: 'initAd',\n                    value: function initAd(width, height, viewMode, desiredBitrate) {\n                        var creativeData = arguments[4] === undefined ? {AdParameters: ''} : arguments[4];\n                        var environmentVars = arguments[5] === undefined ? {flashVars: ''} : arguments[5];\n                        var callback = arguments[6] === undefined ? undefined : arguments[6];\n\n                        //resize element that has the flash object\n                        this._flash.setSize(width, height);\n                        creativeData = creativeData || {AdParameters: ''};\n                        environmentVars = environmentVars || {flashVars: ''};\n\n                        this._flash.callFlashMethod('initAd', [this._flash.getWidth(), this._flash.getHeight(), viewMode, desiredBitrate, creativeData.AdParameters || '', environmentVars.flashVars || ''], callback);\n                    }\n                }, {\n                    key: 'resizeAd',\n                    value: function resizeAd(width, height, viewMode) {\n                        var callback = arguments[3] === undefined ? undefined : arguments[3];\n\n                        //resize element that has the flash object\n                        this._flash.setSize(width, height);\n\n                        //resize ad inside the flash\n                        this._flash.callFlashMethod('resizeAd', [this._flash.getWidth(), this._flash.getHeight(), viewMode], callback);\n                    }\n                }, {\n                    key: 'startAd',\n                    value: function startAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('startAd', [], callback);\n                    }\n                }, {\n                    key: 'stopAd',\n                    value: function stopAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('stopAd', [], callback);\n                    }\n                }, {\n                    key: 'pauseAd',\n                    value: function pauseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('pauseAd', [], callback);\n                    }\n                }, {\n                    key: 'resumeAd',\n                    value: function resumeAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('resumeAd', [], callback);\n                    }\n                }, {\n                    key: 'expandAd',\n                    value: function expandAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('expandAd', [], callback);\n                    }\n                }, {\n                    key: 'collapseAd',\n                    value: function collapseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('collapseAd', [], callback);\n                    }\n                }, {\n                    key: 'skipAd',\n                    value: function skipAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('skipAd', [], callback);\n                    }\n                }, {\n                    key: 'getAdLinear',\n\n                    //properties that will be treat as async methods\n                    value: function getAdLinear(callback) {\n                        this._flash.callFlashMethod('getAdLinear', [], callback);\n                    }\n                }, {\n                    key: 'getAdWidth',\n                    value: function getAdWidth(callback) {\n                        this._flash.callFlashMethod('getAdWidth', [], callback);\n                    }\n                }, {\n                    key: 'getAdHeight',\n                    value: function getAdHeight(callback) {\n                        this._flash.callFlashMethod('getAdHeight', [], callback);\n                    }\n                }, {\n                    key: 'getAdExpanded',\n                    value: function getAdExpanded(callback) {\n                        this._flash.callFlashMethod('getAdExpanded', [], callback);\n                    }\n                }, {\n                    key: 'getAdSkippableState',\n                    value: function getAdSkippableState(callback) {\n                        this._flash.callFlashMethod('getAdSkippableState', [], callback);\n                    }\n                }, {\n                    key: 'getAdRemainingTime',\n                    value: function getAdRemainingTime(callback) {\n                        this._flash.callFlashMethod('getAdRemainingTime', [], callback);\n                    }\n                }, {\n                    key: 'getAdDuration',\n                    value: function getAdDuration(callback) {\n                        this._flash.callFlashMethod('getAdDuration', [], callback);\n                    }\n                }, {\n                    key: 'setAdVolume',\n                    value: function setAdVolume(volume) {\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n\n                        this._flash.callFlashMethod('setAdVolume', [volume], callback);\n                    }\n                }, {\n                    key: 'getAdVolume',\n                    value: function getAdVolume(callback) {\n                        this._flash.callFlashMethod('getAdVolume', [], callback);\n                    }\n                }, {\n                    key: 'getAdCompanions',\n                    value: function getAdCompanions(callback) {\n                        this._flash.callFlashMethod('getAdCompanions', [], callback);\n                    }\n                }, {\n                    key: 'getAdIcons',\n                    value: function getAdIcons(callback) {\n                        this._flash.callFlashMethod('getAdIcons', [], callback);\n                    }\n                }]);\n\n                return VPAIDAdUnit;\n            })(IVPAIDAdUnit);\n\n            exports.VPAIDAdUnit = VPAIDAdUnit;\n\n        }, {\"./IVPAIDAdUnit\": 1}], 3: [function (require, module, exports) {\n            'use strict';\n\n    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n            var JSFlashBridge = require('./jsFlashBridge').JSFlashBridge;\n            var VPAIDAdUnit = require('./VPAIDAdUnit').VPAIDAdUnit;\n\n            var noop = require('./utils').noop;\n            var callbackTimeout = require('./utils').callbackTimeout;\n            var isPositiveInt = require('./utils').isPositiveInt;\n            var createElementWithID = require('./utils').createElementWithID;\n            var uniqueVPAID = require('./utils').unique('vpaid');\n\n            var ERROR = 'error';\n            var FLASH_VERSION = '10.1.0';\n\n            var VPAIDFLASHClient = (function () {\n                function VPAIDFLASHClient(vpaidParentEl, callback) {\n                    var swfConfig = arguments[2] === undefined ? {data: 'VPAIDFlash.swf', width: 800, height: 400} : arguments[2];\n\n                    var _this = this;\n\n                    var params = arguments[3] === undefined ? {wmode: 'transparent', salign: 'tl', align: 'left', allowScriptAccess: 'always', scale: 'noScale', allowFullScreen: 'true', quality: 'high'} : arguments[3];\n                    var vpaidOptions = arguments[4] === undefined ? {debug: false, timeout: 10000} : arguments[4];\n\n                    _classCallCheck(this, VPAIDFLASHClient);\n\n                    if (!VPAIDFLASHClient.hasExternalDependencies()) {\n                        return onError('no swfobject in global scope. check: https://github.com/swfobject/swfobject or https://code.google.com/p/swfobject/');\n                    }\n\n                    this._vpaidParentEl = vpaidParentEl;\n                    this._flashID = uniqueVPAID();\n                    this._destroyed = false;\n                    callback = callback || noop;\n\n                    swfConfig.width = isPositiveInt(swfConfig.width, 800);\n                    swfConfig.height = isPositiveInt(swfConfig.height, 400);\n\n                    createElementWithID(vpaidParentEl, this._flashID);\n\n                    params.movie = swfConfig.data;\n                    params.FlashVars = 'flashid=' + this._flashID + '&handler=' + JSFlashBridge.VPAID_FLASH_HANDLER + '&debug=' + vpaidOptions.debug + '&salign=' + params.salign;\n\n                    if (!VPAIDFLASHClient.isSupported()) {\n                        return onError('user don\\'t support flash or doesn\\'t have the minimum required version of flash ' + FLASH_VERSION);\n                    }\n\n                    this.el = swfobject.createSWF(swfConfig, params, this._flashID);\n\n                    if (!this.el) {\n                        return onError('swfobject failed to create object in element');\n                    }\n\n                    var handler = callbackTimeout(vpaidOptions.timeout, function (err, data) {\n                        $loadPendedAdUnit.call(_this);\n                        callback(err, data);\n                    }, function () {\n                        callback('vpaid flash load timeout ' + vpaidOptions.timeout);\n                    });\n\n                    this._flash = new JSFlashBridge(this.el, swfConfig.data, this._flashID, swfConfig.width, swfConfig.height, handler);\n\n                    function onError(error) {\n                        setTimeout(function () {\n                            callback(new Error(error));\n                        }, 0);\n                        return this;\n                    }\n                }\n\n                _createClass(VPAIDFLASHClient, [{\n                    key: 'destroy',\n                    value: function destroy() {\n                        this._destroyAdUnit();\n\n                        if (this._flash) {\n                            this._flash.destroy();\n                            this._flash = null;\n                        }\n                        this.el = null;\n                        this._destroyed = true;\n                    }\n                }, {\n                    key: 'isDestroyed',\n                    value: function isDestroyed() {\n                        return this._destroyed;\n                    }\n                }, {\n                    key: '_destroyAdUnit',\n                    value: function _destroyAdUnit() {\n                        delete this._loadLater;\n\n                        if (this._adUnitLoad) {\n                            this._adUnitLoad = null;\n                            this._flash.removeCallback(this._adUnitLoad);\n                        }\n\n                        if (this._adUnit) {\n                            this._adUnit._destroy();\n                            this._adUnit = null;\n                        }\n                    }\n                }, {\n                    key: 'loadAdUnit',\n                    value: function loadAdUnit(adURL, callback) {\n                        var _this2 = this;\n\n                        $throwIfDestroyed.call(this);\n\n                        if (this._adUnit) {\n                            this._destroyAdUnit();\n                        }\n\n                        if (this._flash.isReady()) {\n                            this._adUnitLoad = function (err, message) {\n                                if (!err) {\n                                    _this2._adUnit = new VPAIDAdUnit(_this2._flash);\n                                }\n                                _this2._adUnitLoad = null;\n                                callback(err, _this2._adUnit);\n                            };\n\n                            this._flash.callFlashMethod('loadAdUnit', [adURL], this._adUnitLoad);\n                        } else {\n                            this._loadLater = {url: adURL, callback: callback};\n                        }\n                    }\n                }, {\n                    key: 'unloadAdUnit',\n                    value: function unloadAdUnit() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        $throwIfDestroyed.call(this);\n\n                        this._destroyAdUnit();\n                        this._flash.callFlashMethod('unloadAdUnit', [], callback);\n                    }\n                }, {\n                    key: 'getFlashID',\n                    value: function getFlashID() {\n                        $throwIfDestroyed.call(this);\n                        return this._flash.getFlashID();\n                    }\n                }, {\n                    key: 'getFlashURL',\n                    value: function getFlashURL() {\n                        $throwIfDestroyed.call(this);\n                        return this._flash.getFlashURL();\n                    }\n                }]);\n\n                return VPAIDFLASHClient;\n            })();\n\n            setStaticProperty('isSupported', function () {\n                return VPAIDFLASHClient.hasExternalDependencies() && swfobject.hasFlashPlayerVersion(FLASH_VERSION);\n            });\n\n            setStaticProperty('hasExternalDependencies', function () {\n                return !!window.swfobject;\n            });\n\n            function $throwIfDestroyed() {\n                if (this._destroyed) {\n                    throw new error('VPAIDFlashToJS is destroyed!');\n                }\n            }\n\n            function $loadPendedAdUnit() {\n                if (this._loadLater) {\n                    this.loadAdUnit(this._loadLater.url, this._loadLater.callback);\n                    delete this._loadLater;\n                }\n            }\n\n            function setStaticProperty(propertyName, value) {\n                Object.defineProperty(VPAIDFLASHClient, propertyName, {\n                    writable: false,\n                    configurable: false,\n                    value: value\n                });\n            }\n\n            window.VPAIDFLASHClient = VPAIDFLASHClient;\n            module.exports = VPAIDFLASHClient;\n\n        }, {\"./VPAIDAdUnit\": 2, \"./jsFlashBridge\": 4, \"./utils\": 7}], 4: [function (require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n            var unique = require('./utils').unique;\n            var isPositiveInt = require('./utils').isPositiveInt;\n            var stringEndsWith = require('./utils').stringEndsWith;\n            var SingleValueRegistry = require('./registry').SingleValueRegistry;\n            var MultipleValuesRegistry = require('./registry').MultipleValuesRegistry;\n            var registry = require('./jsFlashBridgeRegistry');\n            var VPAID_FLASH_HANDLER = 'vpaid_video_flash_handler';\n            var ERROR = 'AdError';\n\n            var JSFlashBridge = (function () {\n                function JSFlashBridge(el, flashURL, flashID, width, height, loadHandShake) {\n                    _classCallCheck(this, JSFlashBridge);\n\n                    this._el = el;\n                    this._flashID = flashID;\n                    this._flashURL = flashURL;\n                    this._width = width;\n                    this._height = height;\n                    this._handlers = new MultipleValuesRegistry();\n                    this._callbacks = new SingleValueRegistry();\n                    this._uniqueMethodIdentifier = unique(this._flashID);\n                    this._ready = false;\n                    this._handShakeHandler = loadHandShake;\n\n                    registry.addInstance(this._flashID, this);\n                }\n\n                _createClass(JSFlashBridge, [{\n                    key: 'on',\n                    value: function on(eventName, callback) {\n                        this._handlers.add(eventName, callback);\n                    }\n                }, {\n                    key: 'off',\n                    value: function off(eventName, callback) {\n                        return this._handlers.remove(eventName, callback);\n                    }\n                }, {\n                    key: 'offEvent',\n                    value: function offEvent(eventName) {\n                        return this._handlers.removeByKey(eventName);\n                    }\n                }, {\n                    key: 'offAll',\n                    value: function offAll() {\n                        return this._handlers.removeAll();\n                    }\n                }, {\n                    key: 'callFlashMethod',\n                    value: function callFlashMethod(methodName) {\n                        var args = arguments[1] === undefined ? [] : arguments[1];\n                        var callback = arguments[2] === undefined ? undefined : arguments[2];\n\n                        var callbackID = '';\n                        // if no callback, some methods the return is void so they don't need callback\n                        if (callback) {\n                            callbackID = this._uniqueMethodIdentifier() + '_' + methodName;\n                            this._callbacks.add(callbackID, callback);\n                        }\n\n                        try {\n                            //methods are created by ExternalInterface.addCallback in as3 code, if for some reason it failed\n                            //this code will throw an error\n                            this._el[methodName]([callbackID].concat(args));\n                        } catch (e) {\n                            if (callback) {\n                                $asyncCallback.call(this, callbackID, e);\n                            } else {\n\n                                //if there isn't any callback to return error use error event handler\n                                this._trigger(ERROR, e);\n                            }\n                        }\n                    }\n                }, {\n                    key: 'removeCallback',\n                    value: function removeCallback(callback) {\n                        return this._callbacks.removeByValue(callback);\n                    }\n                }, {\n                    key: 'removeCallbackByMethodName',\n                    value: function removeCallbackByMethodName(suffix) {\n                        var _this = this;\n\n                        this._callbacks.filterKeys(function (key) {\n                            return stringEndsWith(key, suffix);\n                        }).forEach(function (key) {\n                            _this._callbacks.remove(key);\n                        });\n                    }\n                }, {\n                    key: 'removeAllCallbacks',\n                    value: function removeAllCallbacks() {\n                        return this._callbacks.removeAll();\n                    }\n                }, {\n                    key: '_trigger',\n                    value: function _trigger(eventName, event) {\n                        var _this2 = this;\n\n                        this._handlers.get(eventName).forEach(function (callback) {\n                            //clickThru has to be sync, if not will be block by the popupblocker\n                            if (eventName === 'AdClickThru') {\n                                callback(event);\n                            } else {\n                                setTimeout(function () {\n                                    if (_this2._handlers.get(eventName).length > 0) {\n                                        callback(event);\n                                    }\n                                }, 0);\n                            }\n                        });\n                    }\n                }, {\n                    key: '_callCallback',\n                    value: function _callCallback(methodName, callbackID, err, result) {\n\n                        var callback = this._callbacks.get(callbackID);\n\n                        //not all methods callback's are mandatory\n                        //but if there exist an error, fire the error event\n                        if (!callback) {\n                            if (err && callbackID === '') {\n                                this.trigger(ERROR, err);\n                            }\n                            return;\n                        }\n\n                        $asyncCallback.call(this, callbackID, err, result);\n                    }\n                }, {\n                    key: '_handShake',\n                    value: function _handShake(err, data) {\n                        this._ready = true;\n                        if (this._handShakeHandler) {\n                            this._handShakeHandler(err, data);\n                            delete this._handShakeHandler;\n                        }\n                    }\n                }, {\n                    key: 'getSize',\n\n                    //methods like properties specific to this implementation of VPAID\n                    value: function getSize() {\n                        return {width: this._width, height: this._height};\n                    }\n                }, {\n                    key: 'setSize',\n                    value: function setSize(newWidth, newHeight) {\n                        this._width = isPositiveInt(newWidth, this._width);\n                        this._height = isPositiveInt(newHeight, this._height);\n                        this._el.setAttribute('width', this._width);\n                        this._el.setAttribute('height', this._height);\n                    }\n                }, {\n                    key: 'getWidth',\n                    value: function getWidth() {\n                        return this._width;\n                    }\n                }, {\n                    key: 'setWidth',\n                    value: function setWidth(newWidth) {\n                        this.setSize(newWidth, this._height);\n                    }\n                }, {\n                    key: 'getHeight',\n                    value: function getHeight() {\n                        return this._height;\n                    }\n                }, {\n                    key: 'setHeight',\n                    value: function setHeight(newHeight) {\n                        this.setSize(this._width, newHeight);\n                    }\n                }, {\n                    key: 'getFlashID',\n                    value: function getFlashID() {\n                        return this._flashID;\n                    }\n                }, {\n                    key: 'getFlashURL',\n                    value: function getFlashURL() {\n                        return this._flashURL;\n                    }\n                }, {\n                    key: 'isReady',\n                    value: function isReady() {\n                        return this._ready;\n                    }\n                }, {\n                    key: 'destroy',\n                    value: function destroy() {\n                        this.offAll();\n                        this.removeAllCallbacks();\n                        registry.removeInstanceByID(this._flashID);\n                        if (this._el.parentElement) {\n                            this._el.parentElement.removeChild(this._el);\n                        }\n                    }\n                }]);\n\n                return JSFlashBridge;\n            })();\n\n            exports.JSFlashBridge = JSFlashBridge;\n\n            function $asyncCallback(callbackID, err, result) {\n                var _this3 = this;\n\n                setTimeout(function () {\n                    var callback = _this3._callbacks.get(callbackID);\n                    if (callback) {\n                        _this3._callbacks.remove(callbackID);\n                        callback(err, result);\n                    }\n                }, 0);\n            }\n\n            Object.defineProperty(JSFlashBridge, 'VPAID_FLASH_HANDLER', {\n                writable: false,\n                configurable: false,\n                value: VPAID_FLASH_HANDLER\n            });\n\n            /**\n             * External interface handler\n             *\n             * @param {string} flashID identifier of the flash who call this\n             * @param {string} typeID what type of message is, can be 'event' or 'callback'\n             * @param {string} typeName if the typeID is a event the typeName will be the eventName, if is a callback the typeID is the methodName that is related this callback\n             * @param {string} callbackID only applies when the typeID is 'callback', identifier of the callback to call\n             * @param {object} error error object\n             * @param {object} data\n             */\n            window[VPAID_FLASH_HANDLER] = function (flashID, typeID, typeName, callbackID, error, data) {\n                var instance = registry.getInstanceByID(flashID);\n                if (!instance) return;\n                if (typeName === 'handShake') {\n                    instance._handShake(error, data);\n                } else {\n                    if (typeID !== 'event') {\n                        instance._callCallback(typeName, callbackID, error, data);\n                    } else {\n                        instance._trigger(typeName, data);\n                    }\n                }\n            };\n\n        }, {\"./jsFlashBridgeRegistry\": 5, \"./registry\": 6, \"./utils\": 7}], 5: [function (require, module, exports) {\n            'use strict';\n\n            var SingleValueRegistry = require('./registry').SingleValueRegistry;\n            var instances = new SingleValueRegistry();\n\n            var JSFlashBridgeRegistry = {};\n            Object.defineProperty(JSFlashBridgeRegistry, 'addInstance', {\n                writable: false,\n                configurable: false,\n                value: function value(id, instance) {\n                    instances.add(id, instance);\n                }\n            });\n\n            Object.defineProperty(JSFlashBridgeRegistry, 'getInstanceByID', {\n                writable: false,\n                configurable: false,\n                value: function value(id) {\n                    return instances.get(id);\n                }\n            });\n\n            Object.defineProperty(JSFlashBridgeRegistry, 'removeInstanceByID', {\n                writable: false,\n                configurable: false,\n                value: function value(id) {\n                    return instances.remove(id);\n                }\n            });\n\n            module.exports = JSFlashBridgeRegistry;\n\n        }, {\"./registry\": 6}], 6: [function (require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n            var MultipleValuesRegistry = (function () {\n                function MultipleValuesRegistry() {\n                    _classCallCheck(this, MultipleValuesRegistry);\n\n                    this._registries = {};\n                }\n\n                _createClass(MultipleValuesRegistry, [{\n                    key: 'add',\n                    value: function add(id, value) {\n                        if (!this._registries[id]) {\n                            this._registries[id] = [];\n                        }\n                        if (this._registries[id].indexOf(value) === -1) {\n                            this._registries[id].push(value);\n                        }\n                    }\n                }, {\n                    key: 'get',\n                    value: function get(id) {\n                        return this._registries[id] || [];\n                    }\n                }, {\n                    key: 'filterKeys',\n                    value: function filterKeys(handler) {\n                        return Object.keys(this._registries).filter(handler);\n                    }\n                }, {\n                    key: 'findByValue',\n                    value: function findByValue(value) {\n                        var _this = this;\n\n                        var keys = Object.keys(this._registries).filter(function (key) {\n                            return _this._registries[key].indexOf(value) !== -1;\n                        });\n\n                        return keys;\n                    }\n                }, {\n                    key: 'remove',\n                    value: function remove(key, value) {\n                        if (!this._registries[key]) {\n                            return;\n                        }\n\n                        var index = this._registries[key].indexOf(value);\n\n                        if (index < 0) {\n                            return;\n                        }\n                        return this._registries[key].splice(index, 1);\n                    }\n                }, {\n                    key: 'removeByKey',\n                    value: function removeByKey(id) {\n                        var old = this._registries[id];\n                        delete this._registries[id];\n                        return old;\n                    }\n                }, {\n                    key: 'removeByValue',\n                    value: function removeByValue(value) {\n                        var _this2 = this;\n\n                        var keys = this.findByValue(value);\n                        return keys.map(function (key) {\n                            return _this2.remove(key, value);\n                        });\n                    }\n                }, {\n                    key: 'removeAll',\n                    value: function removeAll() {\n                        var old = this._registries;\n                        this._registries = {};\n                        return old;\n                    }\n                }, {\n                    key: 'size',\n                    value: function size() {\n                        return Object.keys(this._registries).length;\n                    }\n                }]);\n\n                return MultipleValuesRegistry;\n            })();\n\n            exports.MultipleValuesRegistry = MultipleValuesRegistry;\n\n            var SingleValueRegistry = (function () {\n                function SingleValueRegistry() {\n                    _classCallCheck(this, SingleValueRegistry);\n\n                    this._registries = {};\n                }\n\n                _createClass(SingleValueRegistry, [{\n                    key: 'add',\n                    value: function add(id, value) {\n                        this._registries[id] = value;\n                    }\n                }, {\n                    key: 'get',\n                    value: function get(id) {\n                        return this._registries[id];\n                    }\n                }, {\n                    key: 'filterKeys',\n                    value: function filterKeys(handler) {\n                        return Object.keys(this._registries).filter(handler);\n                    }\n                }, {\n                    key: 'findByValue',\n                    value: function findByValue(value) {\n                        var _this3 = this;\n\n                        var keys = Object.keys(this._registries).filter(function (key) {\n                            return _this3._registries[key] === value;\n                        });\n\n                        return keys;\n                    }\n                }, {\n                    key: 'remove',\n                    value: function remove(id) {\n                        var old = this._registries[id];\n                        delete this._registries[id];\n                        return old;\n                    }\n                }, {\n                    key: 'removeByValue',\n                    value: function removeByValue(value) {\n                        var _this4 = this;\n\n                        var keys = this.findByValue(value);\n                        return keys.map(function (key) {\n                            return _this4.remove(key);\n                        });\n                    }\n                }, {\n                    key: 'removeAll',\n                    value: function removeAll() {\n                        var old = this._registries;\n                        this._registries = {};\n                        return old;\n                    }\n                }, {\n                    key: 'size',\n                    value: function size() {\n                        return Object.keys(this._registries).length;\n                    }\n                }]);\n\n                return SingleValueRegistry;\n            })();\n\n            exports.SingleValueRegistry = SingleValueRegistry;\n\n        }, {}], 7: [function (require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n            exports.unique = unique;\n            exports.noop = noop;\n            exports.callbackTimeout = callbackTimeout;\n            exports.createElementWithID = createElementWithID;\n            exports.isPositiveInt = isPositiveInt;\n            exports.stringEndsWith = stringEndsWith;\n\n            function unique(prefix) {\n                var count = -1;\n                return function (f) {\n                    return prefix + '_' + ++count;\n                };\n            }\n\n    function noop() {}\n\n            function callbackTimeout(timer, onSuccess, onTimeout) {\n\n                var timeout = setTimeout(function () {\n\n                    onSuccess = noop;\n                    onTimeout();\n                }, timer);\n\n                return function () {\n                    clearTimeout(timeout);\n                    onSuccess.apply(this, arguments);\n                };\n            }\n\n            function createElementWithID(parent, id) {\n                var nEl = document.createElement('div');\n                nEl.id = id;\n                parent.innerHTML = '';\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            function isPositiveInt(newVal, oldVal) {\n                return !isNaN(parseFloat(newVal)) && isFinite(newVal) && newVal > 0 ? newVal : oldVal;\n            }\n\n            var endsWith = (function () {\n                if (String.prototype.endsWith) return String.prototype.endsWith;\n                return function endsWith(searchString, position) {\n                    var subjectString = this.toString();\n                    if (position === undefined || position > subjectString.length) {\n                        position = subjectString.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = subjectString.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                };\n            })();\n\n            function stringEndsWith(string, search) {\n                return endsWith.call(string, search);\n            }\n\n},{}]},{},[3])\n\n\n//# sourceMappingURL=VPAIDFLASHClient.js.map\n    ;\n    /*jshint unused:false */\n    \"use strict\";\n\n    var NODE_TYPE_ELEMENT = 1;\n\n    function noop(){ }\n\n    function isNull(o) {\n        return o === null;\n    }\n\n    function isDefined(o) {\n        return o !== undefined;\n    }\n\n    function isUndefined(o) {\n        return o === undefined;\n    }\n\n    function isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    function isFunction(str) {\n        return typeof str === 'function';\n    }\n\n    function isNumber(num) {\n        return typeof num === 'number';\n    }\n\n    function isWindow(obj) {\n        return isObject(obj) && obj.window === obj;\n    }\n\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === '[object Array]';\n    }\n\n    function isArrayLike(obj) {\n        if (obj === null || isWindow(obj) || isFunction(obj) || isUndefined(obj)) {\n            return false;\n        }\n\n        var length = obj.length;\n\n        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {\n            return true;\n        }\n\n        return isString(obj) || isArray(obj) || length === 0 ||\n            typeof length === 'number' && length > 0 && (length - 1) in obj;\n    }\n\n    function isString(str) {\n        return typeof str === 'string';\n    }\n\n    function isEmptyString(str) {\n        return isString(str) && str.length === 0;\n    }\n\n    function isNotEmptyString(str) {\n        return isString(str) && str.length !== 0;\n    }\n\n    function arrayLikeObjToArray(args) {\n        return Array.prototype.slice.call(args);\n    }\n\n    function forEach(obj, iterator, context) {\n        var key, length;\n        if (obj) {\n            if (isFunction(obj)) {\n                for (key in obj) {\n                    // Need to check if hasOwnProperty exists,\n                    // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function\n                    if (key !== 'prototype' && key !== 'length' && key !== 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            } else if (isArray(obj)) {\n                var isPrimitive = typeof obj !== 'object';\n                for (key = 0, length = obj.length; key < length; key++) {\n                    if (isPrimitive || key in obj) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            } else if (obj.forEach && obj.forEach !== forEach) {\n                obj.forEach(iterator, context, obj);\n            } else {\n                for (key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n\n    var SNAKE_CASE_REGEXP = /[A-Z]/g;\n    function snake_case(name, separator) {\n        separator = separator || '_';\n        return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {\n            return (pos ? separator : '') + letter.toLowerCase();\n        });\n    }\n\n    function isValidEmail(email) {\n        if (!isString(email)) {\n            return false;\n        }\n        var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)+$/i;\n        return EMAIL_REGEXP.test(email.trim());\n    }\n\n    function extend(obj) {\n        var arg, i, k;\n        for (i = 1; i < arguments.length; i++) {\n            arg = arguments[i];\n            for (k in arg) {\n                if (arg.hasOwnProperty(k)) {\n                    if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {\n                        obj[k] = extend({}, obj[k], arg[k]);\n                    } else {\n                        obj[k] = arg[k];\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n\n    function capitalize(s) {\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    }\n\n    function decapitalize(s) {\n        return s.charAt(0).toLowerCase() + s.slice(1);\n    }\n\n    /**\n     * This method works the same way array.prototype.map works but if the transformer returns undefine, then\n     * it won't be added to the transformed Array.\n     */\n    function transformArray(array, transformer) {\n        var transformedArray = [];\n\n        array.forEach(function (item, index) {\n            var transformedItem = transformer(item, index);\n            if (isDefined(transformedItem)) {\n                transformedArray.push(transformedItem);\n            }\n        });\n\n        return transformedArray;\n    }\n\n    function toFixedDigits(num, digits) {\n        var formattedNum = num + '';\n        digits = isNumber(digits) ? digits : 0;\n        num = isNumber(num) ? num : parseInt(num, 10);\n        if (isNumber(num) && !isNaN(num)) {\n            formattedNum = num + '';\n            while (formattedNum.length < digits) {\n                formattedNum = '0' + formattedNum;\n            }\n            return formattedNum;\n        }\n        return NaN + '';\n    }\n\n    function debounce(callback, wait) {\n        var timeoutId;\n\n        return function () {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            timeoutId = setTimeout(function () {\n                callback.apply(this, arguments);\n                timeoutId = undefined;\n            }, wait);\n        };\n    }\n\n// a function designed to blow up the stack in a naive way\n// but it is ok for videoJs children components\n    function treeSearch(root, getChildren, found) {\n        var children = getChildren(root);\n        for (var i = 0; i < children.length; i++) {\n            if (found(children[i])) {\n                return children[i];\n            }\n            else {\n                var el = treeSearch(children[i], getChildren, found);\n                if (el) {\n                    return el;\n                }\n            }\n        }\n    }\n\n    function echoFn(val) {\n        return function () {\n            return val;\n        };\n    }\n\n//Note: Supported formats come from http://www.w3.org/TR/NOTE-datetime\n// and the iso8601 regex comes from http://www.pelagodesign.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/\n    function isISO8601(value) {\n        if (isNumber(value)) {\n            value = value + '';  //we make sure that we are working with strings\n        }\n\n        if (!isString(value)) {\n            return false;\n        }\n\n        /*jslint maxlen: 500 */\n        var iso8086Regex = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24\\:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n        return iso8086Regex.test(value.trim());\n    }\n\n    /**\n     * Checks if the Browser is IE9 and below\n     * @returns {boolean}\n     */\n    function isOldIE() {\n        var version = getInternetExplorerVersion(navigator);\n        if (version === -1) {\n            return false;\n        }\n\n        return version < 10;\n    }\n\n    /**\n     * Returns the version of Internet Explorer or a -1 (indicating the use of another browser).\n     * Source: https://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx\n     * @returns {number} the version of Internet Explorer or a -1 (indicating the use of another browser).\n     */\n    function getInternetExplorerVersion(navigator) {\n        var rv = -1;\n\n        if (navigator.appName == 'Microsoft Internet Explorer') {\n            var ua = navigator.userAgent;\n            var re = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\n            var res = re.exec(ua);\n            if (res !== null) {\n                rv = parseFloat(res[1]);\n            }\n        }\n\n        return rv;\n    }\n\n    /*** Mobile Utility functions ***/\n    var _UA = navigator.userAgent;\n    function isIDevice() {\n        return /iP(hone|ad)/.test(_UA);\n    }\n\n    function isMobile() {\n        return /iP(hone|ad|od)|Android|Windows Phone/.test(_UA);\n    }\n\n    function isIPhone() {\n        return /iP(hone|od)/.test(_UA);\n    }\n\n    function isAndroid() {\n        return /Android/.test(_UA);\n    }\n\n    ;\n    (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n            'use strict';\n\n            var METHODS = [\n                'handshakeVersion',\n                'initAd',\n                'startAd',\n                'stopAd',\n                'skipAd', // VPAID 2.0 new method\n                'resizeAd',\n                'pauseAd',\n                'resumeAd',\n                'expandAd',\n                'collapseAd',\n                'subscribe',\n                'unsubscribe'\n            ];\n\n            var EVENTS = [\n                'AdLoaded',\n                'AdStarted',\n                'AdStopped',\n                'AdSkipped',\n                'AdSkippableStateChange', // VPAID 2.0 new event\n                'AdSizeChange', // VPAID 2.0 new event\n                'AdLinearChange',\n                'AdDurationChange', // VPAID 2.0 new event\n                'AdExpandedChange',\n                'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility\n                'AdVolumeChange',\n                'AdImpression',\n                'AdVideoStart',\n                'AdVideoFirstQuartile',\n                'AdVideoMidpoint',\n                'AdVideoThirdQuartile',\n                'AdVideoComplete',\n                'AdClickThru',\n                'AdInteraction', // VPAID 2.0 new event\n                'AdUserAcceptInvitation',\n                'AdUserMinimize',\n                'AdUserClose',\n                'AdPaused',\n                'AdPlaying',\n                'AdLog',\n                'AdError'\n            ];\n\n            var GETTERS = [\n                'getAdLinear',\n                'getAdWidth', // VPAID 2.0 new getter\n                'getAdHeight', // VPAID 2.0 new getter\n                'getAdExpanded',\n                'getAdSkippableState', // VPAID 2.0 new getter\n                'getAdRemainingTime',\n                'getAdDuration', // VPAID 2.0 new getter\n                'getAdVolume',\n                'getAdCompanions', // VPAID 2.0 new getter\n                'getAdIcons' // VPAID 2.0 new getter\n            ];\n\n            var SETTERS = [\n                'setAdVolume'\n            ];\n\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n\n            /**\n             * IVPAIDAdUnit\n             *\n             * @class\n             *\n             * @param {object} creative\n             * @param {HTMLElement} el\n             * @param {HTMLVideoElement} video\n             */\n        function IVPAIDAdUnit(creative, el, video) {}\n\n\n            /**\n             * handshakeVersion\n             *\n             * @param {string} VPAIDVersion\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.handshakeVersion = function (VPAIDVersion, callback) {};\n\n            /**\n             * initAd\n             *\n             * @param {number} width\n             * @param {number} height\n             * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'\n             * @param {number} desiredBitrate indicates the desired bitrate in kbps\n             * @param {object} [creativeData] used for additional initialization data\n             * @param {object} [environmentVars] used for passing implementation-specific of js version\n             * @param {NodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.initAd = function(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {};\n\n            /**\n             * startAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.startAd = function(callback) {};\n\n            /**\n             * stopAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.stopAd = function(callback) {};\n\n            /**\n             * skipAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.skipAd = function(callback) {};\n\n            /**\n             * resizeAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.resizeAd = function(width, height, viewMode, callback) {};\n\n            /**\n             * pauseAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.pauseAd = function(callback) {};\n\n            /**\n             * resumeAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.resumeAd = function(callback) {};\n\n            /**\n             * expandAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.expandAd = function(callback) {};\n\n            /**\n             * collapseAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.collapseAd = function(callback) {};\n\n            /**\n             * subscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             * @param {object} context\n             */\n        IVPAIDAdUnit.prototype.subscribe = function(event, handler, context) {};\n\n            /**\n             * startAd\n             *\n             * @param {string} event\n             * @param {function} handler\n             */\n        IVPAIDAdUnit.prototype.unsubscribe = function(event, handler) {};\n\n\n\n            /**\n             * getAdLinear\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdLinear = function(callback) {};\n\n            /**\n             * getAdWidth\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdWidth = function(callback) {};\n\n            /**\n             * getAdHeight\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdHeight = function(callback) {};\n\n            /**\n             * getAdExpanded\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdExpanded = function(callback) {};\n\n            /**\n             * getAdSkippableState\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdSkippableState = function(callback) {};\n\n            /**\n             * getAdRemainingTime\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdRemainingTime = function(callback) {};\n\n            /**\n             * getAdDuration\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdDuration = function(callback) {};\n\n            /**\n             * getAdVolume\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdVolume = function(callback) {};\n\n            /**\n             * getAdCompanions\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdCompanions = function(callback) {};\n\n            /**\n             * getAdIcons\n             *\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.getAdIcons = function(callback) {};\n\n            /**\n             * setAdVolume\n             *\n             * @param {number} volume\n             * @param {nodeStyleCallback} callback\n             */\n        IVPAIDAdUnit.prototype.setAdVolume = function(volume, callback) {};\n\n            addStaticToInterface(IVPAIDAdUnit, 'METHODS', METHODS);\n            addStaticToInterface(IVPAIDAdUnit, 'GETTERS', GETTERS);\n            addStaticToInterface(IVPAIDAdUnit, 'SETTERS', SETTERS);\n            addStaticToInterface(IVPAIDAdUnit, 'EVENTS', EVENTS);\n\n\n            var VPAID1_METHODS = METHODS.filter(function (method) {\n                return ['skipAd'].indexOf(method) === -1;\n            });\n\n            addStaticToInterface(IVPAIDAdUnit, 'checkVPAIDInterface', function checkVPAIDInterface(creative) {\n                var result = VPAID1_METHODS.every(function (key) {\n                    return typeof creative[key] === 'function';\n                });\n                return result;\n            });\n\n            module.exports = IVPAIDAdUnit;\n\n            function addStaticToInterface(Interface, name, value) {\n                Object.defineProperty(Interface, name, {\n                    writable: false,\n                    configurable: false,\n                    value: value\n                });\n            }\n\n\n        }, {}], 2: [function (require, module, exports) {\n            'use strict';\n\n            var IVPAIDAdUnit = require('./IVPAIDAdUnit');\n            var Subscriber = require('./subscriber');\n            var checkVPAIDInterface = IVPAIDAdUnit.checkVPAIDInterface;\n            var utils = require('./utils');\n            var METHODS = IVPAIDAdUnit.METHODS;\n            var ERROR = 'AdError';\n            var AD_CLICK = 'AdClickThru';\n            var FILTERED_EVENTS = IVPAIDAdUnit.EVENTS.filter(function (event) {\n                return event != AD_CLICK;\n            });\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n\n            /**\n             * VPAIDAdUnit\n             * @class\n             *\n             * @param VPAIDCreative\n             * @param {HTMLElement} [el] this will be used in initAd environmentVars.slot if defined\n             * @param {HTMLVideoElement} [video] this will be used in initAd environmentVars.videoSlot if defined\n             */\n            function VPAIDAdUnit(VPAIDCreative, el, video, iframe) {\n                this._isValid = checkVPAIDInterface(VPAIDCreative);\n                if (this._isValid) {\n                    this._creative = VPAIDCreative;\n                    this._el = el;\n                    this._videoEl = video;\n                    this._iframe = iframe;\n                    this._subscribers = new Subscriber();\n                    $addEventsSubscribers.call(this);\n                }\n            }\n\n            VPAIDAdUnit.prototype = Object.create(IVPAIDAdUnit.prototype);\n\n            /**\n             * isValidVPAIDAd will return if the VPAIDCreative passed in constructor is valid or not\n             *\n             * @return {boolean}\n             */\n            VPAIDAdUnit.prototype.isValidVPAIDAd = function isValidVPAIDAd() {\n                return this._isValid;\n            };\n\n            IVPAIDAdUnit.METHODS.forEach(function (method) {\n                //NOTE: this methods arguments order are implemented differently from the spec\n                var ignores = [\n                    'subscribe',\n                    'unsubscribe',\n                    'initAd'\n                ];\n\n                if (ignores.indexOf(method) !== -1) return;\n\n                VPAIDAdUnit.prototype[method] = function () {\n                    var ariaty = IVPAIDAdUnit.prototype[method].length;\n                    // TODO avoid leaking arguments\n                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                    var args = Array.prototype.slice.call(arguments);\n                    var callback = (ariaty === args.length) ? args.pop() : undefined;\n\n                    setTimeout(function () {\n                        var result, error = null;\n                        try {\n                            result = this._creative[method].apply(this._creative, args);\n                        } catch (e) {\n                            error = e;\n                        }\n\n                        callOrTriggerEvent(callback, this._subscribers, error, result);\n                    }.bind(this), 0);\n                };\n            });\n\n\n            /**\n             * initAd concreate implementation\n             *\n             * @param {number} width\n             * @param {number} height\n             * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'\n             * @param {number} desiredBitrate indicates the desired bitrate in kbps\n             * @param {object} [creativeData] used for additional initialization data\n             * @param {object} [environmentVars] used for passing implementation-specific of js version, if el & video was used in constructor slot & videoSlot will be added to the object\n             * @param {NodeStyleCallback} callback\n             */\n            VPAIDAdUnit.prototype.initAd = function initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {\n                creativeData = creativeData || {};\n                environmentVars = utils.extend({\n                    slot: this._el,\n                    videoSlot: this._videoEl\n                }, environmentVars || {});\n\n                setTimeout(function () {\n                    var error;\n                    try {\n                        this._creative.initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars);\n                    } catch (e) {\n                        error = e;\n                    }\n\n                    callOrTriggerEvent(callback, this._subscribers, error);\n                }.bind(this), 0);\n            };\n\n            /**\n             * subscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             * @param {object} context\n             */\n            VPAIDAdUnit.prototype.subscribe = function subscribe(event, handler, context) {\n                this._subscribers.subscribe(handler, event, context);\n            };\n\n\n            /**\n             * unsubscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             */\n            VPAIDAdUnit.prototype.unsubscribe = function unsubscribe(event, handler) {\n                this._subscribers.unsubscribe(handler, event);\n            };\n\n//alias\n            VPAIDAdUnit.prototype.on = VPAIDAdUnit.prototype.subscribe;\n            VPAIDAdUnit.prototype.off = VPAIDAdUnit.prototype.unsubscribe;\n\n            IVPAIDAdUnit.GETTERS.forEach(function (getter) {\n                VPAIDAdUnit.prototype[getter] = function (callback) {\n                    setTimeout(function () {\n\n                        var result, error = null;\n                        try {\n                            result = this._creative[getter]();\n                        } catch (e) {\n                            error = e;\n                        }\n\n                        callOrTriggerEvent(callback, this._subscribers, error, result);\n                    }.bind(this), 0);\n                };\n            });\n\n            /**\n             * setAdVolume\n             *\n             * @param volume\n             * @param {nodeStyleCallback} callback\n             */\n            VPAIDAdUnit.prototype.setAdVolume = function setAdVolume(volume, callback) {\n                setTimeout(function () {\n\n                    var self = this;\n                    var result, error = null;\n                    try {\n                        this._creative.setAdVolume(volume);\n                    } catch (e) {\n                        error = e;\n                    }\n                    // Wait for creative volume to be set\n                    setTimeout(function () {\n                        result = self._creative.getAdVolume();\n                        if (!error) {\n                            error = utils.validate(result === volume, 'failed to apply volume: ' + volume);\n                        }\n                        callOrTriggerEvent(callback, self._subscribers, error, result);\n                    },200)\n                }.bind(this), 0);\n            };\n\n            VPAIDAdUnit.prototype._destroy = function destroy() {\n                this.stopAd();\n                this._subscribers.unsubscribeAll();\n            };\n\n            function $addEventsSubscribers() {\n                // some ads implement\n                // so they only handle one subscriber\n                // to handle this we create our one\n                FILTERED_EVENTS.forEach(function (event) {\n                    this._creative.subscribe($trigger.bind(this, event), event);\n                }.bind(this));\n\n                // map the click event to be an object instead of depending of the order of the arguments\n                // and to be consistent with the flash\n                this._creative.subscribe($clickThruHook.bind(this), AD_CLICK);\n\n                // because we are adding the element inside the iframe\n                // the user is not able to click in the video\n                if (this._videoEl) {\n                    var documentElement = this._iframe.contentDocument.documentElement;\n                    var videoEl = this._videoEl;\n                    documentElement.addEventListener('click', function (e) {\n                        if (e.target === documentElement) {\n                            videoEl.click();\n                        }\n                    });\n                }\n            }\n\n            function $clickThruHook(url, id, playerHandles) {\n                this._subscribers.triggerSync(AD_CLICK, {url: url, id: id, playerHandles: playerHandles});\n            }\n\n            function $trigger(event) {\n                // TODO avoid leaking arguments\n                // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                this._subscribers.trigger(event, Array.prototype.slice.call(arguments, 1));\n            }\n\n            function callOrTriggerEvent(callback, subscribers, error, result) {\n                if (callback) {\n                    callback(error, result);\n                } else if (error) {\n                    subscribers.trigger(ERROR, error);\n                }\n            }\n\n            module.exports = VPAIDAdUnit;\n\n\n        }, {\"./IVPAIDAdUnit\": 1, \"./subscriber\": 4, \"./utils\": 5}], 3: [function (require, module, exports) {\n            'use strict';\n\n\n            var utils = require('./utils');\n            var unique = utils.unique('vpaidIframe');\n            var VPAIDAdUnit = require('./VPAIDAdUnit');\n            //var defaultTemplate = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n</head>\\n<body>\\n    <script type=\\\"text/javascript\\\" src=\\\"{{iframeURL_JS}}\\\"></script>\\n    <script>\\n        parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', window.location.origin);\\n    </script>\\n    <div class=\\\"ad-element\\\">\\n    </div>\\n</body>\\n</html>\\n\";\n            var defaultTemplate = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n</head>\\n<body style=\\\"margin:0px;overflow:hidden;\\\">\\n    <script type=\\\"text/javascript\\\" src=\\\"{{iframeURL_JS}}\\\"></script>\\n    <script>\\n        //parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', window.location.origin);\\n        //minthe : this should have proper logic for dynamic iframe generates on runtime.\\n        console.log(\\\"send postmessage\\\");\\n        parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', \\\"*\\\");\\n    </script>\\n    <div class=\\\"ad-element\\\">\\n    </div>\\n</body>\\n</html>\\n\";\n\n            var AD_STOPPED = 'AdStopped';\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n            /**\n             * VPAIDHTML5Client\n             * @class\n             *\n             * @param {HTMLElement} el that will contain the iframe to load adUnit and a el to add to adUnit slot\n             * @param {HTMLVideoElement} video default video element to be used by adUnit\n             * @param {object} [templateConfig] template: html template to be used instead of the default, extraOptions: to be used when rendering the template\n             * @param {object} [vpaidOptions] timeout: when loading adUnit\n             */\n            function VPAIDHTML5Client(el, video, templateConfig, vpaidOptions) {\n                templateConfig = templateConfig || {};\n\n                this._id = unique();\n                this._destroyed = false;\n\n                this._frameContainer = utils.createElementInEl(el, 'div');\n                this._videoEl = video;\n                this._vpaidOptions = vpaidOptions || {timeout: 10000};\n\n                this._templateConfig = {\n                    template: templateConfig.template || defaultTemplate,\n                    extraOptions: templateConfig.extraOptions || {}\n                };\n\n            }\n\n            /**\n             * destroy\n             *\n             */\n            VPAIDHTML5Client.prototype.destroy = function destroy() {\n                if (this._destroyed) {\n                    return;\n                }\n                this._destroyed = true;\n                $unloadPreviousAdUnit.call(this);\n            };\n\n            /**\n             * isDestroyed\n             *\n             * @return {boolean}\n             */\n            VPAIDHTML5Client.prototype.isDestroyed = function isDestroyed() {\n                return this._destroyed;\n            };\n\n            /**\n             * loadAdUnit\n             *\n             * @param {string} adURL url of the js of the adUnit\n             * @param {nodeStyleCallback} callback\n             */\n            VPAIDHTML5Client.prototype.loadAdUnit = function loadAdUnit(adURL, callback) {\n                $throwIfDestroyed.call(this);\n                $unloadPreviousAdUnit.call(this);\n\n                var frame = utils.createIframeWithContent(\n                    this._frameContainer,\n                    this._templateConfig.template,\n                    utils.extend({\n                        iframeURL_JS: adURL,\n                        iframeID: this.getID()\n                    }, this._templateConfig.extraOptions)\n                );\n                this._frame = frame;\n\n                this._onLoad = utils.callbackTimeout(\n                    this._vpaidOptions.timeout,\n                    onLoad.bind(this),\n                    onTimeout.bind(this)\n                );\n\n                window.addEventListener('message', this._onLoad);\n\n                function onLoad(e) {\n\n                    console.log(\"got postMessage from container\");\n\n                    //minthe : this should have proper logic for dynamic iframe generates on runtime.\n                    //don't clear timeout\n                    //if (e.origin !== window.location.origin) return;\n                    var result = JSON.parse(e.data);\n\n                    //don't clear timeout\n                    if (result.id !== this.getID()) return;\n\n                    var adUnit, error, createAd;\n                    if (!this._frame.contentWindow) {\n\n                        error = 'the iframe is not anymore in the DOM tree';\n\n                    } else {\n                        createAd = this._frame.contentWindow.getVPAIDAd;\n                        error = utils.validate(typeof createAd === 'function', 'the ad didn\\'t return a function to create an ad');\n                    }\n\n                    if (!error) {\n                        var adEl = this._frame.contentWindow.document.querySelector('.ad-element');\n                        adUnit = new VPAIDAdUnit(createAd(), adEl, this._videoEl, this._frame);\n                        adUnit.subscribe(AD_STOPPED, $adDestroyed.bind(this));\n                        error = utils.validate(adUnit.isValidVPAIDAd(), 'the add is not fully complaint with VPAID specification');\n                    }\n\n                    this._adUnit = adUnit;\n                    $destroyLoadListener.call(this);\n                    callback(error, error ? null : adUnit);\n\n                    //clear timeout\n                    return true;\n                }\n\n                function onTimeout() {\n                    callback('timeout', null);\n                }\n            };\n\n            /**\n             * unloadAdUnit\n             *\n             */\n            VPAIDHTML5Client.prototype.unloadAdUnit = function unloadAdUnit() {\n                $unloadPreviousAdUnit.call(this);\n            };\n\n            /**\n             * getID will return the unique id\n             *\n             * @return {string}\n             */\n            VPAIDHTML5Client.prototype.getID = function () {\n                return this._id;\n            };\n\n\n            /**\n             * $removeEl\n             *\n             * @param {string} key\n             */\n            function $removeEl(key) {\n                var el = this[key];\n                if (el) {\n                    el.remove();\n                    delete this[key];\n                }\n            }\n\n            function $adDestroyed() {\n                $removeAdElements.call(this);\n                delete this._adUnit;\n            }\n\n            function $unloadPreviousAdUnit() {\n                $removeAdElements.call(this);\n                $destroyAdUnit.call(this);\n            }\n\n            function $removeAdElements() {\n                $removeEl.call(this, '_frame');\n                $destroyLoadListener.call(this);\n            }\n\n            /**\n             * $destroyLoadListener\n             *\n             */\n            function $destroyLoadListener() {\n                if (this._onLoad) {\n                    window.removeEventListener('message', this._onLoad);\n                    utils.clearCallbackTimeout(this._onLoad);\n                    delete this._onLoad;\n                }\n            }\n\n\n            function $destroyAdUnit() {\n                if (this._adUnit) {\n                    this._adUnit.stopAd();\n                    delete this._adUnit;\n                }\n            }\n\n            /**\n             * $throwIfDestroyed\n             *\n             */\n            function $throwIfDestroyed() {\n                if (this._destroyed) {\n                    throw new Error('VPAIDHTML5Client already destroyed!');\n                }\n            }\n\n            module.exports = VPAIDHTML5Client;\n            window.VPAIDHTML5Client = VPAIDHTML5Client;\n\n\n        }, {\"./VPAIDAdUnit\": 2, \"./utils\": 5}], 4: [function (require, module, exports) {\n            'use strict';\n\n            function Subscriber() {\n                this._subscribers = {};\n            }\n\n            Subscriber.prototype.subscribe = function subscribe(handler, eventName, context) {\n                this.get(eventName).push({handler: handler, context: context});\n            };\n\n            Subscriber.prototype.unsubscribe = function unsubscribe(handler, eventName) {\n                this._subscribers[eventName] = this.get(eventName).filter(function (subscriber) {\n                    return handler === subscriber.handler;\n                });\n            };\n\n            Subscriber.prototype.unsubscribeAll = function unsubscribeAll() {\n                this._subscribers = {};\n            };\n\n            Subscriber.prototype.trigger = function (eventName, data) {\n                var that = this;\n                that.get(eventName).forEach(function (subscriber) {\n                    setTimeout(function () {\n                        if (that.get(eventName)) {\n                            subscriber.handler.call(subscriber.context, data);\n                        }\n                    }, 0);\n                });\n            };\n\n            Subscriber.prototype.triggerSync = function (eventName, data) {\n                this.get(eventName).forEach(function (subscriber) {\n                    subscriber.handler.call(subscriber.context, data);\n                });\n            };\n\n            Subscriber.prototype.get = function get(eventName) {\n                if (!this._subscribers[eventName]) {\n                    this._subscribers[eventName] = [];\n                }\n                return this._subscribers[eventName];\n            };\n\n            module.exports = Subscriber;\n\n\n        }, {}], 5: [function (require, module, exports) {\n            'use strict';\n\n            /**\n             * noop a empty function\n             */\n        function noop() {}\n\n            /**\n             * validate if is not validate will return an Error with the message\n             *\n             * @param {boolean} isValid\n             * @param {string} message\n             */\n            function validate(isValid, message) {\n                return isValid ? null : new Error(message);\n            }\n\n            var timeouts = {};\n            /**\n             * clearCallbackTimeout\n             *\n             * @param {function} func handler to remove\n             */\n            function clearCallbackTimeout(func) {\n                var timeout = timeouts[func];\n                if (timeout) {\n                    clearTimeout(timeout);\n                    delete timeouts[func];\n                }\n            }\n\n            /**\n             * callbackTimeout if the onSuccess is not called and returns true in the timelimit then onTimeout will be called\n             *\n             * @param {number} timer\n             * @param {function} onSuccess\n             * @param {function} onTimeout\n             */\n            function callbackTimeout(timer, onSuccess, onTimeout) {\n                var callback, timeout;\n\n                timeout = setTimeout(function () {\n                    onSuccess = noop;\n                    if(!timeouts[callback]){\n                        // Timeout has already been resolved.\n                        return;\n                    }\n                    delete timeout[callback];\n                    onTimeout();\n                }, timer);\n\n                callback = function () {\n                    // TODO avoid leaking arguments\n                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                    if (onSuccess.apply(this, arguments)) {\n                        clearCallbackTimeout(callback);\n                    }\n                };\n\n                timeouts[callback] = timeout;\n\n                return callback;\n            }\n\n\n            /**\n             * createElementInEl\n             *\n             * @param {HTMLElement} parent\n             * @param {string} tagName\n             * @param {string} id\n             */\n            function createElementInEl(parent, tagName, id) {\n                var nEl = document.createElement(tagName);\n                if (id) nEl.id = id;\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            /**\n             * createIframeWithContent\n             *\n             * @param {HTMLElement} parent\n             * @param {string} template simple template using {{var}}\n             * @param {object} data\n             */\n            function createIframeWithContent(parent, template, data) {\n                var iframe = createIframe(parent);\n                if (!setIframeContent(iframe, simpleTemplate(template, data))) return;\n                return iframe;\n            }\n\n            /**\n             * createIframe\n             *\n             * @param {HTMLElement} parent\n             * @param {string} url\n             */\n            function createIframe(parent, url) {\n                var nEl = document.createElement('iframe');\n                nEl.src = url || 'about:blank';\n                nEl.width = '100%';\n                nEl.height = '100%';\n                nEl.style.position = 'absolute';\n                nEl.style.left = '0';\n                nEl.style.top = '0';\n                nEl.style.border = '0';\n                parent.innerHTML = '';\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            /**\n             * simpleTemplate\n             *\n             * @param {string} template\n             * @param {object} data\n             */\n            function simpleTemplate(template, data) {\n                Object.keys(data).forEach(function (key) {\n                    var value = (typeof value === 'object') ? JSON.stringify(data[key]) : data[key];\n                    template = template.replace(new RegExp('{{' + key + '}}', 'g'), value);\n                });\n                return template;\n            }\n\n            /**\n             * setIframeContent\n             *\n             * @param {HTMLIframeElement} iframeEl\n             * @param content\n             */\n            function setIframeContent(iframeEl, content) {\n                var iframeDoc = iframeEl.contentWindow && iframeEl.contentWindow.document;\n                if (!iframeDoc) return false;\n\n                iframeDoc.write(content);\n\n                return true;\n            }\n\n\n            /**\n             * extend object with keys from another object\n             *\n             * @param {object} toExtend\n             * @param {object} fromSource\n             */\n            function extend(toExtend, fromSource) {\n                Object.keys(fromSource).forEach(function (key) {\n                    toExtend[key] = fromSource[key];\n                });\n                return toExtend;\n            }\n\n\n            /**\n             * unique will create a unique string everytime is called, sequentially and prefixed\n             *\n             * @param {string} prefix\n             */\n            function unique(prefix) {\n                var count = -1;\n                return function () {\n                    return prefix + '_' + (++count);\n                };\n            }\n\n            module.exports = {\n                noop: noop,\n                validate: validate,\n                clearCallbackTimeout: clearCallbackTimeout,\n                callbackTimeout: callbackTimeout,\n                createElementInEl: createElementInEl,\n                createIframeWithContent: createIframeWithContent,\n                createIframe: createIframe,\n                simpleTemplate: simpleTemplate,\n                setIframeContent: setIframeContent,\n                extend: extend,\n                unique: unique\n            };\n\n\n    },{}]},{},[3])\n\n\n//# sourceMappingURL=VPAIDHTML5Client.js.map\n    ;\n//Small subset of async\n    var async = {};\n\n    async.setImmediate = function (fn) {\n        setTimeout(fn, 0);\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () { };\n        if (!isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {\n                    };\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    async.when = function (condition, callback) {\n        if (!isFunction(callback)) {\n            throw new Error(\"async.when error: missing callback argument\");\n        }\n\n        var isAllowed = isFunction(condition) ? condition : function () {\n            return !!condition;\n        };\n\n        return function () {\n            var args = arrayLikeObjToArray(arguments);\n            var next = args.pop();\n\n            if (isAllowed.apply(null, args)) {\n                return callback.apply(this, arguments);\n            }\n\n            args.unshift(null);\n            return next.apply(null, args);\n        };\n    };\n\n\n\n    ;\n    \"use strict\";\n\n    var dom = {};\n\n    dom.isVisible = function isVisible(el) {\n        var style = window.getComputedStyle(el);\n        return style.visibility !== 'hidden';\n    };\n\n    dom.isHidden = function isHidden(el) {\n        var style = window.getComputedStyle(el);\n        return style.display === 'none';\n    };\n\n    dom.isShown = function isShown(el) {\n        return !dom.isHidden(el);\n    };\n\n    dom.hide = function hide(el) {\n        el.__prev_style_display_ = el.style.display;\n        el.style.display = 'none';\n    };\n\n    dom.show = function show(el) {\n        if (dom.isHidden(el)) {\n            el.style.display = el.__prev_style_display_;\n        }\n        el.__prev_style_display_ = undefined;\n    };\n\n    dom.hasClass = function hasClass(el, cssClass) {\n        var classes, i, len;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.contains(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            cssClass = (cssClass || '');\n\n            for (i = 0, len = classes.length; i < len; i += 1) {\n                if (classes[i] === cssClass) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    dom.addClass = function (el, cssClass) {\n        var classes;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.add(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            if (isString(cssClass) && isNotEmptyString(cssClass.replace(/\\s+/, ''))) {\n                classes.push(cssClass);\n                el.setAttribute('class', classes.join(' '));\n            }\n        }\n    };\n\n    dom.removeClass = function (el, cssClass) {\n        var classes;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.remove(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            var newClasses = [];\n            var i, len;\n            if (isString(cssClass) && isNotEmptyString(cssClass.replace(/\\s+/, ''))) {\n\n                for (i = 0, len = classes.length; i < len; i += 1) {\n                    if (cssClass !== classes[i]) {\n                        newClasses.push(classes[i]);\n                    }\n                }\n                el.setAttribute('class', newClasses.join(' '));\n            }\n        }\n    };\n\n    dom.addEventListener = function addEventListener(el, type, handler) {\n        if (isArray(el)) {\n            forEach(el, function (e) {\n                dom.addEventListener(e, type, handler);\n            });\n            return;\n        }\n\n        if (isArray(type)) {\n            forEach(type, function (t) {\n                dom.addEventListener(el, t, handler);\n            });\n            return;\n        }\n\n        if (el.addEventListener) {\n            el.addEventListener(type, handler, false);\n        } else if (el.attachEvent) {\n            // WARNING!!! this is a very naive implementation !\n            // the event object that should be passed to the handler\n            // would not be there for IE8\n            // we should use \"window.event\" and then \"event.srcElement\"\n            // instead of \"event.target\"\n            el.attachEvent(\"on\" + type, handler);\n        }\n    };\n\n    dom.removeEventListener = function removeEventListener(el, type, handler) {\n        if (isArray(el)) {\n            forEach(el, function (e) {\n                dom.removeEventListener(e, type, handler);\n            });\n            return;\n        }\n\n        if (isArray(type)) {\n            forEach(type, function (t) {\n                dom.removeEventListener(el, t, handler);\n            });\n            return;\n        }\n\n        if (el.removeEventListener) {\n            el.removeEventListener(type, handler, false);\n        } else if (el.detachEvent) {\n            el.detachEvent(\"on\" + type, handler);\n        } else {\n            el[\"on\" + type] = null;\n        }\n    };\n\n    dom.dispatchEvent = function dispatchEvent(el, event) {\n        if (el.dispatchEvent) {\n            el.dispatchEvent(event);\n        } else {\n            el.fireEvent(\"on\" + event.eventType, event);\n        }\n    };\n\n    dom.isDescendant = function isDescendant(parent, child) {\n        var node = child.parentNode;\n        while (node !== null) {\n            if (node === parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    };\n\n    dom.getTextContent = function getTextContent(el) {\n        return el.textContent || el.text;\n    };\n\n    dom.prependChild = function prependChild(parent, child) {\n        if (child.parentNode) {\n            child.parentNode.removeChild(child);\n        }\n        return parent.insertBefore(child, parent.firstChild);\n    };\n\n    dom.remove = function removeNode(node) {\n        if (node && node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    };\n\n    dom.isDomElement = function isDomElement(o) {\n        return o instanceof Element;\n    };\n\n    dom.click = function (el, handler) {\n        dom.addEventListener(el, 'click', handler);\n    };\n\n    dom.once = function (el, type, handler) {\n        function handlerWrap() {\n            handler.apply(null, arguments);\n            dom.removeEventListener(el, type, handlerWrap);\n        }\n\n        dom.addEventListener(el, type, handlerWrap);\n    };\n\n//Note: there is no getBoundingClientRect on iPad so we need a fallback\n    dom.getDimension = function getDimension(element) {\n        var rect;\n        var parentNode = element.parentNode;\n        if (parentNode) {\n           return {\n               width: parentNode.clientWidth,\n               height: parentNode.clientHeight\n           }\n        }\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    };\n\n    \"use strict\";\n\n    var logger = {};\n\n    ;\n    \"use strict\";\n\n    //minthe2 profile\n    var profile = {};\n\n    profile.timeout = 0;\n    profile.initAdTimestamp = 0;\n    profile.adLoadedTimestamp = 0;\n\n    profile.startAdTimestamp = 0;\n    profile.adStartedTimestamp = 0;\n\n    profile.adImpressionTimestamp = 0;\n\n    profile.getState = function() {\n        if (profile.adImpressionTimestamp) {\n            return 'adImpression';\n        }\n        if(profile.startAdTimestamp) {\n            return 'startAd';\n        }\n        if(profile.initAdTimestamp){\n            return 'initAd';\n        }\n        return 'pluginInit';\n    };\n\n    profile.getRemainingTime = function(type){\n        var offset = 0;\n        var currTime = new Date().getTime();\n        switch(type) {\n            case 'initAd':\n                offset = currTime - profile.initAdTimestamp;\n                break;\n            case 'AdLoaded':\n                offset =  profile.getInitTime() ;\n                break;\n            case 'startAd':\n                offset =  profile.getInitTime();\n                break;\n            case 'AdStarted':\n                offset =  profile.getInitTime() + profile.getStartTime();\n                break;\n            case 'AdImpression':\n                offset =  profile.getTotalTime();\n                break;\n            default:\n                break;\n        }\n        var remainingTime = profile.timeout - offset ;\n        return remainingTime;\n    };\n\n    profile.getInitTime = function() {\n        var interval = profile.adLoadedTimestamp - profile.initAdTimestamp;\n        return interval;\n    };\n\n    profile.getStartTime = function() {\n        var interval = profile.adStartedTimestamp - profile.startAdTimestamp;\n        return interval;\n    };\n\n    profile.getAdImpressionTime = function() {\n        var interval = profile.adImpressionTimestamp - profile.startAdTimestamp;\n        return interval;\n    };\n\n    profile.getTotalTime = function(){\n\n        var interval = profile.getInitTime();\n\n        if (profile.adStartedTimestamp > profile.adImpressionTimestamp) {\n            interval = interval + profile.getStartTime();\n        } else {\n            interval = interval + profile.getAdImpressionTime();\n        }\n\n        // if (profile.adImpressionTimestamp) {\n        //     interval = interval + profile.getAdImpressionTime();\n        // }\n        return interval;\n    };\n\n    ;\n    \"use strict\";\n\n    //minthe2 timer\n    var timer = {};\n\n    timer.killUnresponsiveCreative = false;\n    timer.responseWaitingTime = 1000;\n    timer.killTimeout = null;\n    timer.adCancelTimeout = 5000;\n    timer.adLoadTimeout = null;\n    timer.adStartTimeout = null;\n    // timer.adImpressionTimeout = null;\n    timer.adStartedResponseTime = 0;\n    timer.adImpressionResponseTime = 0;\n\n\n    timer.startKillTimeout = function (adUnit) {\n        if(timer.killUnresponsiveCreative){\n            // if already timeout is set . cleanup\n            if(timer.killTimeout) {\n                timer.stopKillTimeout();\n            }\n            timer.killTimeout = setTimeout(function (){\n                if (timer.killTimeout) {\n                    logger.log('killUnresponsiveCreative Timeout reached ');\n                    adUnit.stopAd();\n                }\n            },timer.responseWaitingTime);\n        }\n    };\n\n    timer.stopKillTimeout = function () {\n        if(!timer.killTimeout) {\n            return;\n        }\n        timer.clearTimeout(timer.killTimeout);\n        timer.killTimeout = null;\n    };\n\n    timer.handleAdTimeout = function(cb,state) {\n        logger.error('VPAID AD TIMED OUT :: AFTER ' + state + ' ,timeout value : ' + timer.adCancelTimeout);\n        if(cb){\n            cb(new VASTError('timeout while waiting for the video to start playing', 402));\n        }\n    };\n\n    timer.clearTimeout = function(timeout) {\n        if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n        }\n    };\n\n    timer.startInitAdTimeout =  function(cb) {\n        profile.timeout = timer.adCancelTimeout;\n        profile.initAdTimestamp = new Date().getTime();\n        timer.adLoadTimeout = setTimeout(function(){\n            timer.handleAdTimeout(cb, \"initAd\");\n        }, timer.adCancelTimeout);\n    };\n\n    timer.stopInitAdTimeout =  function() {\n        profile.adLoadedTimestamp = new Date().getTime();\n        timer.adStartedResponseTime = timer.adCancelTimeout - profile.getInitTime();\n        timer.clearTimeout(timer.adLoadTimeout);\n\n    };\n\n    timer.startStartAdTimeout =  function(cb) {\n        profile.startAdTimestamp = new Date().getTime();\n        var timeoutFunction;\n\n        timeoutFunction = function(){\n            if (profile.adStartedTimestamp > 0) {\n                timer.handleAdTimeout(cb,\"AdStarted\");\n            } else {\n                timer.handleAdTimeout(cb,\"startAd\");\n            }\n        }\n\n        timer.adStartTimeout = setTimeout(timeoutFunction, timer.adStartedResponseTime);\n    };\n\n    timer.stopStartAdTimeout =  function() {\n        timer.clearTimeout(timer.adStartTimeout);\n        logger.debug(\"stopStartAdTimeout\");\n    };\n\n    // timer.startAdImpressionTimeout =  function(cb) {\n    //     profile.adImpressionTimestamp = new Date().getTime();\n    //     timer.adImpressionTimeout = setTimeout(function(){\n    //         timer.handleAdTimeout(cb,\"AdStarted\");\n    //     }, timer.adImpressionResponseTime);\n    // };\n\n    // timer.stopAdImpressionTimeout =  function() {\n    //     profile.adImpressionTimestamp = new Date().getTime();\n    //     timer.clearTimeout(timer.adImpressionTimeout);\n    // };\n\n    timer.stopAdTimeouts =  function() {\n        logger.debug(\"stopAdTimeouts\");\n        timer.clearTimeout(timer.adLoadTimeout);\n        timer.clearTimeout(timer.adStartTimeout);\n        // timer.clearTimeout(timer.adImpressionTimeout);\n    };\n\n    ;\n    \"use strict\";\n\n    function HttpRequestError(message) {\n        this.message = 'HttpRequest Error: ' + (message || '');\n    }\n    HttpRequestError.prototype = new Error();\n    HttpRequestError.prototype.name = \"HttpRequest Error\";\n\n    function HttpRequest(createXhr) {\n        if (!isFunction(createXhr)) {\n            throw new HttpRequestError('Missing XMLHttpRequest factory method');\n        }\n\n        this.createXhr = createXhr;\n    }\n\n    HttpRequest.prototype.run = function (method, url, callback, options) {\n        sanityCheck(url, callback, options);\n        var timeout, timeoutId;\n        var xhr = this.createXhr();\n        options = options || {};\n        timeout = isNumber(options.timeout) ? options.timeout : 0;\n\n        xhr.open(method, urlParts(url).href, true);\n\n        if (options.headers) {\n            setHeaders(xhr, options.headers);\n        }\n\n        if (options.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        xhr.onload = function () {\n            var statusText, response, status;\n\n            /**\n             * The only way to do a secure request on IE8 and IE9 is with the XDomainRequest object. Unfortunately, microsoft is\n             * so nice that decided that the status property and the 'getAllResponseHeaders' method where not needed so we have to\n             * fake them. If the request gets done with an XDomainRequest instance, we will assume that there are no headers and\n             * the status will always be 200. If you don't like it, DO NOT USE ANCIENT BROWSERS!!!\n             *\n             * For mor info go to: https://msdn.microsoft.com/en-us/library/cc288060(v=vs.85).aspx\n             */\n            if (!xhr.getAllResponseHeaders) {\n                xhr.getAllResponseHeaders = function () {\n                    return null;\n                };\n            }\n\n            if (!xhr.status) {\n                xhr.status = 200;\n            }\n\n            if (isDefined(timeoutId)) {\n                clearTimeout(timeoutId);\n                timeoutId = undefined;\n            }\n\n            statusText = xhr.statusText || '';\n\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\n            response = ('response' in xhr) ? xhr.response : xhr.responseText;\n\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            status = xhr.status === 1223 ? 204 : xhr.status;\n\n            callback(\n                status,\n                response,\n                xhr.getAllResponseHeaders(),\n                statusText);\n        };\n\n        xhr.onerror = requestError;\n        xhr.onabort = requestError;\n\n        xhr.send();\n\n        if (timeout > 0) {\n            timeoutId = setTimeout(function () {\n                xhr && xhr.abort();\n            }, timeout);\n        }\n\n        function sanityCheck(url, callback, options) {\n            if (!isString(url) || isEmptyString(url)) {\n                throw new HttpRequestError(\"Invalid url '\" + url + \"'\");\n            }\n\n            if (!isFunction(callback)) {\n                throw new HttpRequestError(\"Invalid handler '\" + callback + \"' for the http request\");\n            }\n\n            if (isDefined(options) && !isObject(options)) {\n                throw new HttpRequestError(\"Invalid options map '\" + options + \"'\");\n            }\n        }\n\n        function setHeaders(xhr, headers) {\n            forEach(headers, function (value, key) {\n                if (isDefined(value)) {\n                    xhr.setRequestHeader(key, value);\n                }\n            });\n        }\n\n        function requestError() {\n            callback(-1, null, null, '');\n        }\n    };\n\n    HttpRequest.prototype.get = function (url, callback, options) {\n        this.run('GET', url, processResponse, options);\n\n        function processResponse(status, response, headersString, statusText) {\n            if (isSuccess(status)) {\n                callback(null, response, status, headersString, statusText);\n            } else {\n                callback(new HttpRequestError(statusText), response, status, headersString, statusText);\n            }\n        }\n\n        function isSuccess(status) {\n            return 200 <= status && status < 300;\n        }\n    };\n\n    function createXhr() {\n        var xhr = new XMLHttpRequest();\n        if (!(\"withCredentials\" in xhr)) {\n            // XDomainRequest for IE.\n            xhr = new XDomainRequest();\n        }\n        return xhr;\n    }\n\n    var http = new HttpRequest(createXhr);\n\n    ;\n    var playerUtils = {};\n\n    /**\n     * Returns an object that captures the portions of player state relevant to\n     * video playback. The result of this function can be passed to\n     * restorePlayerSnapshot with a player to return the player to the state it\n     * was in when this function was invoked.\n     * @param {object} player The videojs player object\n     */\n    playerUtils.getPlayerSnapshot = function getPlayerSnapshot(player) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var snapshot = {\n            ended: player.ended(),\n            src: player.currentSrc(),\n            currentTime: player.currentTime(),\n            type: player.currentType(),\n            playing: !player.paused(),\n            suppressedTracks: getSuppressedTracks(player)\n        };\n\n        if (tech) {\n            snapshot.nativePoster = tech.poster;\n            snapshot.style = tech.getAttribute('style');\n        }\n\n        return snapshot;\n\n        /**** Local Functions ****/\n        function getSuppressedTracks(player) {\n            var tracks = player.remoteTextTracks ? player.remoteTextTracks() : [];\n\n            if (tracks && isArray(tracks.tracks_)) {\n                tracks = tracks.tracks_;\n            }\n\n            if (!isArray(tracks)) {\n                tracks = [];\n            }\n\n            var suppressedTracks = [];\n            tracks.forEach(function (track) {\n                suppressedTracks.push({\n                    track: track,\n                    mode: track.mode\n                });\n                track.mode = 'disabled';\n            });\n\n            return suppressedTracks;\n        }\n    };\n\n    /**\n     * Attempts to modify the specified player so that its state is equivalent to\n     * the state of the snapshot.\n     * @param {object} snapshot - the player state to apply\n     */\n    playerUtils.restorePlayerSnapshot = function restorePlayerSnapshot(player, snapshot) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var attempts = 20; // the number of remaining attempts to restore the snapshot\n\n        if (snapshot.nativePoster) {\n            tech.poster = snapshot.nativePoster;\n        }\n\n        if ('style' in snapshot) {\n            // overwrite all css style properties to restore state precisely\n            tech.setAttribute('style', snapshot.style || '');\n        }\n\n        if (hasSrcChanged(player, snapshot)) {\n            // on ios7, fiddling with textTracks too early will cause safari to crash\n            player.one('contentloadedmetadata', restoreTracks);\n\n            player.one('canplay', tryToResume);\n            ensureCanplayEvtGetsFired();\n\n            // if the src changed for ad playback, reset it\n            player.src({src: snapshot.src, type: snapshot.type});\n\n            // safari requires a call to `load` to pick up a changed source\n            player.load();\n\n        } else {\n            restoreTracks();\n\n            if (snapshot.playing) {\n                player.play();\n            }\n        }\n\n        /*** Local Functions ***/\n\n        /**\n         * Sometimes firefox does not trigger the 'canplay' evt.\n         * This code ensure that it always gets triggered triggered.\n         */\n        function ensureCanplayEvtGetsFired() {\n            var timeoutId = setTimeout(function () {\n                player.trigger('canplay');\n            }, 1000);\n\n            player.one('canplay', function () {\n                clearTimeout(timeoutId);\n            });\n        }\n\n        /**\n         * Determine whether the player needs to be restored to its state\n         * before ad playback began. With a custom ad display or burned-in\n         * ads, the content player state hasn't been modified and so no\n         * restoration is required\n         */\n        function hasSrcChanged(player, snapshot) {\n            if (player.src()) {\n                return player.src() !== snapshot.src;\n            }\n            // the player was configured through source element children\n            return player.currentSrc() !== snapshot.src;\n        }\n\n        function restoreTracks() {\n            var suppressedTracks = snapshot.suppressedTracks;\n            suppressedTracks.forEach(function (trackSnapshot) {\n                trackSnapshot.track.mode = trackSnapshot.mode;\n            });\n        }\n\n        /**\n         * Determine if the video element has loaded enough of the snapshot source\n         * to be ready to apply the rest of the state\n         */\n        function tryToResume() {\n            if (playerUtils.isReadyToResume(tech)) {\n                // if some period of the video is seekable, resume playback\n                return resume();\n            }\n\n            // delay a bit and then check again unless we're out of attempts\n            if (attempts--) {\n                setTimeout(tryToResume, 50);\n            } else {\n                (function () {\n                    try {\n                        resume();\n                    } catch (e) {\n                        videojs.log.warn('Failed to resume the content after an advertisement', e);\n                    }\n                })();\n            }\n\n\n            /*** Local functions ***/\n            function resume() {\n                player.currentTime(snapshot.currentTime);\n\n                if (snapshot.playing) {\n                    player.play();\n                }\n            }\n\n        }\n    };\n\n    playerUtils.isReadyToResume = function (tech) {\n        if (tech.readyState > 1) {\n            // some browsers and media aren't \"seekable\".\n            // readyState greater than 1 allows for seeking without exceptions\n            return true;\n        }\n\n        if (tech.seekable === undefined) {\n            // if the tech doesn't expose the seekable time ranges, try to\n            // resume playback immediately\n            return true;\n        }\n\n        if (tech.seekable.length > 0) {\n            // if some period of the video is seekable, resume playback\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * This function prepares the player to display ads.\n     * Adding convenience events like the 'vast.firsPlay' that gets fired when the video is first played\n     * and ads the blackPoster to the player to prevent content from being displayed before the preroll ad.\n     *\n     * @param player\n     */\n    playerUtils.prepareForAds = function (player, isOverlayPlayer) {\n\n        var blackPoster = player.addChild('blackPoster');\n        var _firstPlay = true;\n        var volumeSnapshot;\n\n        // VID-1955 Causes Interference with Waterfall playback\n        if(!isOverlayPlayer){\n            monkeyPatchPlayerApi();\n        }\n\n        player.on('play', tryToTriggerFirstPlay);\n        player.on('vast.reset', resetFirstPlay);//Every time we change the sources we reset the first play.\n        player.on('vast.firstPlay', restoreContentVolume);\n        player.on('error', hideBlackPoster);//If there is an error in the player we remove the blackposter to show the err msg\n        player.on('vast.adStart', hideBlackPoster);\n        player.on('vast.adsCancel', hideBlackPoster);\n        player.on('vast.adError', hideBlackPoster);\n        player.on('vast.adStart', addStyles);\n        player.on('vast.adEnd', removeStyles);\n        player.on('vast.adsCancel', removeStyles);\n\n        /*** Local Functions ***/\n\n        /**\n         What this function does is ugly and horrible and I should think twice before calling myself a good developer. With that said,\n         it is the best solution I could find to mute the video until the 'play' event happens (on mobile devices) and the plugin can decide whether\n         to play the ad or not.\n\n         We also need this monkeypatch to be able to pause and resume an ad using the player's API\n\n         If you have a better solution please do tell me.\n         */\n        function monkeyPatchPlayerApi() {\n\n            /**\n             * Monkey patch needed to handle firstPlay and resume of playing ad.\n             *\n             * @param prepareForAds necessary flag to prevent infinite loop when you are restoring a VAST ad.\n             * @returns {player}\n             */\n            var origPlay = player.play;\n            player.play = function (callOrigPlay) {\n\n\n\n\n                if (isFirstPlay()) {\n                    firstPlay.call(this);\n                } else {\n                    resume.call(this, callOrigPlay);\n                }\n\n                return this;\n\n                /*** local functions ***/\n                function firstPlay() {\n\n\n                    if (!isIPhone()) {\n                        volumeSnapshot = saveVolumeSnapshot();\n                        player.muted(true);\n                    }\n                    // Do not call play on the video element instead just trigger startAd and the creative will call play as it is suppose to.\n                    // VID-2515 Force the enabling of the spinner. As we do not call actual play the wait state to trigger spinner never gets activated until its too late.\n                    player.addClass('vjs-waiting');\n                    player.trigger('firstplay');\n                    player.trigger('play');\n                }\n\n                function resume(callOrigPlay) {\n                    if (isAdPlaying() && !callOrigPlay) {\n                        player.vast.adUnit.resumeAd();\n                    } else {\n                        origPlay.apply(this, arguments);\n                    }\n                }\n            };\n\n\n            /**\n             * Needed monkey patch to handle pause of playing ad.\n             *\n             * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.\n             * @returns {player}\n             */\n            var origPause = player.pause;\n            player.pause = function (callOrigPause) {\n                if (isAdPlaying() && !callOrigPause) {\n                    player.vast.adUnit.pauseAd();\n                } else {\n                    origPause.apply(this, arguments);\n                }\n                return this;\n            };\n\n\n            /**\n             * Needed monkey patch to handle paused state of the player when ads are playing.\n             *\n             * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.\n             * @returns {player}\n             */\n            var origPaused = player.paused;\n            player.paused = function (callOrigPaused) {\n                if (isAdPlaying() && !callOrigPaused) {\n                    return player.vast.adUnit.isPaused();\n                }\n                return origPaused.apply(this, arguments);\n            };\n        }\n\n        function isAdPlaying() {\n            return player.vast && player.vast.adUnit;\n        }\n\n        function tryToTriggerFirstPlay() {\n\n            if (isFirstPlay()) {\n                _firstPlay = false;\n                player.trigger('vast.firstPlay');\n            }\n        }\n\n        function resetFirstPlay() {\n            _firstPlay = true;\n            blackPoster.show();\n            restoreContentVolume();\n        }\n\n        function isFirstPlay() {\n            return _firstPlay;\n        }\n\n        function saveVolumeSnapshot() {\n            return {\n                muted: player.muted(),\n                volume: player.volume()\n            };\n        }\n\n        function restoreContentVolume() {\n            if (volumeSnapshot) {\n                player.currentTime(0);\n                restoreVolumeSnapshot(volumeSnapshot);\n                volumeSnapshot = null;\n            }\n        }\n\n        function restoreVolumeSnapshot(snapshot) {\n            if (isObject(snapshot)) {\n                player.volume(snapshot.volume);\n                player.muted(snapshot.muted);\n            }\n        }\n\n        function hideBlackPoster() {\n            if (!dom.hasClass(blackPoster.el(), 'vjs-hidden')) {\n                blackPoster.hide();\n            }\n        }\n\n        function addStyles() {\n            dom.addClass(player.el(), 'vjs-ad-playing');\n        }\n\n        function removeStyles() {\n            dom.removeClass(player.el(), 'vjs-ad-playing');\n        }\n    };\n\n    /**\n     * Remove the poster attribute from the video element tech, if present. When\n     * reusing a video element for multiple videos, the poster image will briefly\n     * reappear while the new source loads. Removing the attribute ahead of time\n     * prevents the poster from showing up between videos.\n     * @param {object} player The videojs player object\n     */\n    playerUtils.removeNativePoster = function (player) {\n        var tech = player.el().querySelector('.vjs-tech');\n        if (tech) {\n            tech.removeAttribute('poster');\n        }\n    };\n\n    /**\n     * Helper function to listen to many events until one of them gets fired, then we\n     * execute the handler and unsubscribe all the event listeners;\n     *\n     * @param player specific player from where to listen for the events\n     * @param events array of events\n     * @param handler function to execute once one of the events fires\n     */\n    playerUtils.once = function once(player, events, handler) {\n        function listener() {\n            handler.apply(null, arguments);\n\n            events.forEach(function (event) {\n                player.off(event, listener);\n            });\n        }\n\n        events.forEach(function (event) {\n            player.on(event, listener);\n        });\n    };\n\n    ;\n    'use strict';\n\n    /**\n     * documentMode is an IE-only property\n     * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n     */\n    var msie = document.documentMode;\n\n    /**\n     *\n     * IMPORTANT NOTE: This function comes from angularJs and was originally called urlResolve\n     *                 you can take a look at the original code here https://github.com/angular/angular.js/blob/master/src/ng/urlUtils.js\n     *\n     * Implementation Notes for non-IE browsers\n     * ----------------------------------------\n     * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,\n     * results both in the normalizing and parsing of the URL.  Normalizing means that a relative\n     * URL will be resolved into an absolute URL in the context of the application document.\n     * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related\n     * properties are all populated to reflect the normalized URL.  This approach has wide\n     * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See\n     * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *\n     * Implementation Notes for IE\n     * ---------------------------\n     * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other\n     * browsers.  However, the parsed components will not be set if the URL assigned did not specify\n     * them.  (e.g. if you assign a.href = \"foo\", then a.protocol, a.host, etc. will be empty.)  We\n     * work around that by performing the parsing in a 2nd step by taking a previously normalized\n     * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the\n     * properties such as protocol, hostname, port, etc.\n     *\n     * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one\n     * uses the inner HTML approach to assign the URL as part of an HTML snippet -\n     * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.\n     * Unfortunately, setting img[src] to something like \"javascript:foo\" on IE throws an exception.\n     * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that\n     * method and IE < 8 is unsupported.\n     *\n     * References:\n     *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement\n     *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *   http://url.spec.whatwg.org/#urlutils\n     *   https://github.com/angular/angular.js/pull/2902\n     *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/\n     *\n     * @kind function\n     * @param {string} url The URL to be parsed.\n     * @description Normalizes and parses a URL.\n     * @returns {object} Returns the normalized URL as a dictionary.\n     *\n     *   | member name   | Description    |\n     *   |---------------|----------------|\n     *   | href          | A normalized version of the provided URL if it was not an absolute URL |\n     *   | protocol      | The protocol including the trailing colon                              |\n     *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |\n     *   | search        | The search params, minus the question mark                             |\n     *   | hash          | The hash string, minus the hash symbol\n     *   | hostname      | The hostname\n     *   | port          | The port, without \":\"\n     *   | pathname      | The pathname, beginning with \"/\"\n     *\n     */\n\n    var urlParsingNode = document.createElement(\"a\");\n\n    function urlParts(url) {\n        var href = url;\n\n        if (msie) {\n            // Normalize before parse.  Refer Implementation Notes on why this is\n            // done in two steps on IE.\n            urlParsingNode.setAttribute(\"href\", href);\n            href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n            href: urlParsingNode.href,\n            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n            host: urlParsingNode.host,\n            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n            hostname: urlParsingNode.hostname,\n            port: isNotEmptyString(urlParsingNode.port) ? urlParsingNode.port : 80,\n            pathname: (urlParsingNode.pathname.charAt(0) === '/')\n                ? urlParsingNode.pathname\n                : '/' + urlParsingNode.pathname\n        };\n    }\n\n\n    /**\n     * This function accepts a query string (search part of a url) and returns a dictionary with\n     * the different key value pairs\n     * @param {string} qs queryString\n     */\n    function queryStringToObj(qs, cond) {\n        var pairs, qsObj;\n\n        cond = isFunction(cond) ? cond : function () {\n            return true;\n        };\n\n        qs = qs.trim().replace(/^\\?/, '');\n        pairs = qs.split('&');\n        qsObj = {};\n\n        forEach(pairs, function (pair) {\n            var keyValue, key, value;\n            if (pair !== '') {\n                keyValue = pair.split('=');\n                key = keyValue[0];\n                value = keyValue[1];\n                if (cond(key, value)) {\n                    qsObj[key] = value;\n                }\n            }\n        });\n\n        return qsObj;\n    }\n\n    /**\n     * This function accepts an object and serializes it into a query string without the leading '?'\n     * @param obj\n     * @returns {string}\n     */\n    function objToQueryString(obj) {\n        var pairs = [];\n        forEach(obj, function (value, key) {\n            pairs.push(key + '=' + value);\n        });\n        return pairs.join('&');\n    }\n\n\n    ;\n    var xml = {};\n\n    xml.strToXMLDoc = function strToXMLDoc(stringContainingXMLSource) {\n        //IE 8\n        if (typeof window.DOMParser === 'undefined') {\n            var xmlDocument = new ActiveXObject('Microsoft.XMLDOM');\n            xmlDocument.async = false;\n            xmlDocument.loadXML(stringContainingXMLSource);\n            return xmlDocument;\n        }\n\n        return parseString(stringContainingXMLSource);\n\n        function parseString(stringContainingXMLSource) {\n            var parser = new DOMParser();\n            var parsedDocument;\n\n            //Note: This try catch is to deal with the fact that on IE parser.parseFromString does throw an error but the rest of the browsers don't.\n            try {\n                parsedDocument = parser.parseFromString(stringContainingXMLSource, \"application/xml\");\n\n                if (isParseError(parsedDocument) || isEmptyString(stringContainingXMLSource)) {\n                    throw new Error();\n                }\n            } catch (e) {\n                throw new Error(\"xml.strToXMLDOC: Error parsing the string: '\" + stringContainingXMLSource + \"'\");\n            }\n\n            return parsedDocument;\n        }\n\n        function isParseError(parsedDocument) {\n            try { // parser and parsererrorNS could be cached on startup for efficiency\n                var parser = new DOMParser(),\n                    errorneousParse = parser.parseFromString('INVALID', 'text/xml'),\n                    parsererrorNS = errorneousParse.getElementsByTagName(\"parsererror\")[0].namespaceURI;\n\n                if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {\n                    // In PhantomJS the parseerror element doesn't seem to have a special namespace, so we are just guessing here :(\n                    return parsedDocument.getElementsByTagName(\"parsererror\").length > 0;\n                }\n\n                return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;\n            } catch (e) {\n                //Note on IE parseString throws an error by itself and it will never reach this code. Because it will have failed before\n            }\n        }\n    };\n\n    xml.parseText = function parseText(sValue) {\n        if (/^\\s*$/.test(sValue)) { return null; }\n        if (/^(?:true|false)$/i.test(sValue)) { return sValue.toLowerCase() === \"true\"; }\n        if (isFinite(sValue)) { return parseFloat(sValue); }\n        if (isISO8601(sValue)) { return new Date(sValue); }\n        return sValue.trim();\n    };\n\n    xml.JXONTree = function JXONTree(oXMLParent) {\n        var parseText = xml.parseText;\n\n        //The document object is an especial object that it may miss some functions or attrs depending on the browser.\n        //To prevent this problem with create the JXONTree using the root childNode which is a fully fleshed node on all supported\n        //browsers.\n        if (oXMLParent.documentElement) {\n            return new xml.JXONTree(oXMLParent.documentElement);\n        }\n\n        if (oXMLParent.hasChildNodes()) {\n            var sCollectedTxt = \"\";\n            for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n                oNode = oXMLParent.childNodes.item(nItem);\n                /*jshint bitwise: false*/\n                if ((oNode.nodeType - 1 | 1) === 3) { sCollectedTxt += oNode.nodeType === 3 ? oNode.nodeValue.trim() : oNode.nodeValue; }\n                else if (oNode.nodeType === 1 && !oNode.prefix) {\n                    sProp = decapitalize(oNode.nodeName);\n                    vContent = new xml.JXONTree(oNode);\n                    if (this.hasOwnProperty(sProp)) {\n                        if (this[sProp].constructor !== Array) { this[sProp] = [this[sProp]]; }\n                        this[sProp].push(vContent);\n                    } else { this[sProp] = vContent; }\n                    }\n                }\n            if (sCollectedTxt) { this.keyValue = parseText(sCollectedTxt); }\n        }\n\n        //IE8 Stupid fix\n        var hasAttr = typeof oXMLParent.hasAttributes === 'undefined' ? oXMLParent.attributes.length > 0 : oXMLParent.hasAttributes();\n        if (hasAttr) {\n            var oAttrib;\n            for (var nAttrib = 0; nAttrib < oXMLParent.attributes.length; nAttrib++) {\n                oAttrib = oXMLParent.attributes.item(nAttrib);\n                this[\"@\" + decapitalize(oAttrib.name)] = parseText(oAttrib.value.trim());\n            }\n        }\n    };\n\n    xml.JXONTree.prototype.attr = function (attr) {\n        return this['@' + decapitalize(attr)];\n    };\n\n    xml.toJXONTree = function toJXONTree(xmlString) {\n        var xmlDoc = xml.strToXMLDoc(xmlString);\n        return new xml.JXONTree(xmlDoc);\n    };\n\n    /**\n     * Helper function to extract the keyvalue of a JXONTree obj\n     *\n     * @param xmlObj {JXONTree}\n     * return the key value or undefined;\n     */\n    xml.keyValue = function getKeyValue(xmlObj) {\n        if (xmlObj) {\n            return xmlObj.keyValue;\n        }\n        return undefined;\n    };\n\n    xml.attr = function getAttrValue(xmlObj, attr) {\n        if (xmlObj) {\n            return xmlObj['@' + decapitalize(attr)];\n        }\n        return undefined;\n    };\n\n    xml.encode = function encodeXML(str) {\n        return str.replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    };\n\n    xml.decode = function decodeXML(str) {\n        return str.replace(/&apos;/g, \"'\")\n            .replace(/&quot;/g, '\"')\n            .replace(/&gt;/g, '>')\n            .replace(/&lt;/g, '<')\n            .replace(/&amp;/g, '&');\n    };\n    ;\n\n    //minthe : initalize vastClient\n    vjs.plugin('vastClient', function VASTPlugin(options) {\n\n        var snapshot;\n        var player = this;\n        var vast = new VASTClient();\n        var adsCanceled = false;\n        var defaultOpts = {\n            // maximum amount of time in ms to wait to receive `adsready` from the ad\n            // implementation after play has been requested. Ad implementations are\n            // expected to load any dynamic libraries and make any requests to determine\n            // ad policies for a video during this time.\n            timeout: 500,\n\n            //TODO:finish this IOS FIX\n            //Whenever you play an add on IOS, the native player kicks in and we loose control of it. On very heavy pages the 'play' event\n            // May occur after the video content has already started. This is wrong if you want to play a preroll ad that needs to happen before the user\n            // starts watching the content. To prevent this usec\n            iosPrerollCancelTimeout: 2000,\n\n            // maximun amount of time for the ad to actually start playing. If this timeout gets\n            // triggered the ads will be cancelled\n            adCancelTimeout: 5000,\n\n            // Boolean flag that configures the player to play a new ad before the user sees the video again\n            // the current video\n            playAdAlways: false,\n\n            // Flag to enable or disable the ads by default.\n            adsEnabled: true,\n\n            // Boolean flag to enable or disable the resize with window.resize or orientationchange\n            autoResize: true,\n\n            // Path to the VPAID flash ad's loader\n            vpaidFlashLoaderPath: '/VPAIDFlash.swf',\n\n            //Boolean flag to enable/disable Controls on mouse over/out.\n            disableControlsOnMouseover: false,\n\n            initialAudio : 'off',\n\n            overlayPlayer : false\n        };\n\n        var settings = extend({}, defaultOpts, options || {});\n\n        if (isUndefined(settings.adTagUrl) && isDefined(settings.url)) {\n            settings.adTagUrl = settings.url;\n        }\n\n        if (isString(settings.adTagUrl)) {\n            settings.adTagUrl = echoFn(settings.adTagUrl);\n        }\n\n        if (isDefined(settings.adTagXML) && !isFunction(settings.adTagXML)) {\n            return trackAdError(new VASTError('on VideoJS VAST plugin, the passed adTagXML option does not contain a function'));\n        }\n\n        if (!isDefined(settings.adTagUrl) && !isFunction(settings.adTagXML)) {\n            return trackAdError(new VASTError('on VideoJS VAST plugin, missing adTagUrl on options object'));\n        }\n        playerUtils.prepareForAds(player, settings.overlayPlayer);\n        if (settings.playAdAlways) {\n            // No matter what happens we play a new ad before the user sees the video again.\n            player.on('vast.contentEnd', function () {\n                setTimeout(function () {\n                    player.trigger('vast.reset');\n                }, 0);\n            });\n        }\n\n        player.on('vast.firstPlay', tryToPlayPrerollAd);\n\n        player.on('vast.reset', function () {\n            //If we are reseting the plugin, we don't want to restore the content\n            snapshot = null;\n            cancelAds();\n        });\n\n        player.vast = {\n            isEnabled: function () {\n                return settings.adsEnabled;\n            },\n\n            enable: function () {\n                settings.adsEnabled = true;\n            },\n\n            disable: function () {\n                settings.adsEnabled = false;\n            }\n        };\n\n        if(settings.loggerCallback){\n            logger = settings.loggerCallback;\n        } else{\n            logger = console;\n        }\n        if (settings.terminateUnresponsiveVPAIDCreative) {\n            timer.killUnresponsiveCreative = true;\n        }\n        if (settings.adCancelTimeout) {\n            timer.adCancelTimeout = settings.adCancelTimeout;\n        }\n\n        var vastResponse = getAnVastXml();\n        var adIntegrator = isVPAID(vastResponse) ? new VPAIDIntegrator(player, settings) : new VASTIntegrator(player);\n\n        if (settings.delayExpandUntilVPAIDInit) {\n            checkAd();//minthe : invoke init method of vpaid creative here in order to check valid ad, at the end of this checkAd process it will dispatch custom event which is called \"an.readytogovpaid\"\n        }\n\n        return player.vast;\n\n\n\n        /**** Local functions ****/\n        function tryToPlayPrerollAd() {\n            //We remove the poster to prevent flickering whenever the content starts playing\n            playerUtils.removeNativePoster(player);\n\n            playerUtils.once(player, ['vast.adsCancel', 'vast.adEnd'], function () {\n                removeAdUnit();\n                restoreVideoContent();\n            });\n\n            async.waterfall([\n                checkAdsEnabled,\n                preparePlayerForAd,\n                playPrerollAd\n            ], function (error, response) {\n                if (error) {\n                    trackAdError(error, response);\n                } else {\n                    player.trigger('vast.adEnd');\n                }\n            });\n\n            /*** Local functions ***/\n\n            function removeAdUnit() {\n                if (player.vast && player.vast.adUnit) {\n                    player.vast.adUnit = null; //We remove the adUnit\n                }\n            }\n\n            function restoreVideoContent() {\n                setupContentEvents();\n                if (snapshot) {\n                    playerUtils.restorePlayerSnapshot(player, snapshot);\n                    snapshot = null;\n                }\n            }\n\n            function setupContentEvents() {\n                playerUtils.once(player, ['playing', 'vast.reset', 'vast.firstPlay'], function (evt) {\n                    if (evt.type !== 'playing') {\n                        return;\n                    }\n\n                    player.trigger('vast.contentStart');\n\n                    playerUtils.once(player, ['ended', 'vast.reset', 'vast.firstPlay'], function (evt) {\n                        if (evt.type === 'ended') {\n                            player.trigger('vast.contentEnd');\n                        }\n                    });\n                });\n            }\n\n            function checkAdsEnabled(next) {\n                if (settings.adsEnabled) {\n                    return next(null);\n                }\n                next(new VASTError('Ads are not enabled'));\n            }\n\n            function preparePlayerForAd(next) {\n                if (canPlayPrerollAd()) {\n                    snapshot = playerUtils.getPlayerSnapshot(player);\n                    addSpinnerIcon();\n                    next(null);\n                } else {\n                    next(new VASTError('video content has been playing before preroll ad'));\n                }\n            }\n\n            function canPlayPrerollAd() {\n                return !isIPhone() || player.currentTime() <= settings.iosPrerollCancelTimeout;\n            }\n\n            function addSpinnerIcon() {\n                dom.addClass(player.el(), 'vjs-vast-ad-loading');\n                playerUtils.once(player, ['vast.adStart', 'vast.adsCancel'], removeSpinnerIcon);\n            }\n\n            function removeSpinnerIcon() {\n                //IMPORTANT NOTE: We remove the spinnerIcon asynchronously to give time to the browser to start the video.\n                // If we remove it synchronously we see a flash of the content video before the ad starts playing.\n                setTimeout(function () {\n                    dom.removeClass(player.el(), 'vjs-vast-ad-loading');\n                }, 100);\n            }\n\n        }\n\n        function cancelAds() {\n            player.trigger('vast.adsCancel');\n            adsCanceled = true;\n        }\n\n        function playPrerollAd(callback) {\n            async.waterfall([\n                //getVastResponse,//minthe : comment out, we're not using mail online's vast parser and loader\n                playAd\n            ], callback);\n        }\n\n        function getVastResponse(callback) {\n            vast.getVASTResponse(settings.adTagUrl ? settings.adTagUrl() : settings.adTagXML, callback);\n        }\n\n        function getAnVastXml() {//minthe : override vast response to use jsVpaidUrl coming from videoplayer framework\n            var vastResponse = new VASTResponse();\n            vastResponse._linearAdded = true;\n            vastResponse.ads = [{\n                \"id\": 1234567,\n                \"inLine\": {\n                    \"adTitle\": \"\",\n                    \"adSystem\": \"\",\n                    \"impressions\": [],\n                    \"creatives\": [{\n                        \"sequence\": 1,\n                        \"linear\": {\n                            \"duration\": 13000,\n                            \"mediaFiles\": [{\n                                \"src\": settings.jsVpaidUrl,\n                                \"type\": \"application/javascript\",\n                                \"apiFramework\": \"VPAID\"\n                            }],\n                            \"skipoffset\": null,\n                        }\n                    }, {\"sequence\": 1}],\n                    \"description\": \"Vpaid Linear Video Ad\",\n                    \"surveys\": []\n                }\n            }];\n            vastResponse.errorURLMacros = [];\n            vastResponse.impressions = [];\n            vastResponse.customClicks = [];\n            vastResponse.mediaFiles = [{\n                \"src\": settings.jsVpaidUrl,\n                \"type\": \"application/javascript\",\n                \"apiFramework\": \"VPAID\"\n            }];\n            vastResponse.clickThrough = settings.clickUrl;\n            vastResponse.adTitle = \"\";\n            vastResponse.adParameters = settings.adParameters;\n\n            return vastResponse;\n        }\n\n        function playAd(vastResponse, callback) {\n\n            //minthe : override vast response to use jsVpaidUrl coming from videoplayer framework\n            vastResponse = getAnVastXml();\n\n            //TODO: Find a better way to stop the play. The 'playPrerollWaterfall' ends in an inconsistent situation\n            //If the state is not 'preroll?' it means the ads were canceled therefore, we break the waterfall\n            if (adsCanceled) {\n                return;\n            }\n\n            var adFinished = false;\n\n            //comment out for VID-1359\n            //if (isIDevice()) {\n                //preventManualProgress();\n            //}\n            callback = callback || trackAdError;\n            player.vast.adUnit = adIntegrator.playAd(vastResponse, callback);\n\n            //comment out for VID-1359\n            //function preventManualProgress() {\n            //    //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that the user forwarded/rewound the ad\n            //    var PROGRESS_THRESHOLD = 3;\n            //    var previousTime = 0;\n            //    var tech = player.el().querySelector('.vjs-tech');\n            //    var skipad_attempts = 0;\n            //\n            //    player.on('timeupdate', adTimeupdateHandler);\n            //    playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adError'], stopPreventManualProgress);\n            //\n            //    /*** Local functions ***/\n            //    function adTimeupdateHandler() {\n            //        var currentTime = player.currentTime();\n            //        var progressDelta = Math.abs(currentTime - previousTime);\n            //\n            //        if (progressDelta > PROGRESS_THRESHOLD) {\n            //            skipad_attempts += 1;\n            //            if (skipad_attempts >= 2) {\n            //                player.pause();\n            //            }\n            //            player.currentTime(previousTime);\n            //        } else {\n            //            previousTime = currentTime;\n            //        }\n            //    }\n            //\n            //    function stopPreventManualProgress() {\n            //        player.off('timeupdate', adTimeupdateHandler);\n            //    }\n            //}\n        }\n\n        //minthe : checkAd to check vpaid ad is ready to go\n        function checkAd(vastResponse, callback) {\n            vastResponse = getAnVastXml();\n            callback = callback || trackAdError;\n            player.vast.adUnit = adIntegrator.playAd(vastResponse, callback, true);\n        }\n\n        function trackAdError(error, vastResponse) {\n            if(!error) return;\n            player.trigger({type: 'vast.adError', error: error});\n            cancelAds();\n            if (console && console.log) {\n                console.log('AD ERROR:', error.message, error, vastResponse);\n            }\n        }\n\n        function isVPAID(vastResponse) {\n            var i, len;\n            var mediaFiles = vastResponse.mediaFiles;\n            for (i = 0, len = mediaFiles.length; i < len; i++) {\n                if (vastUtil.isVPAID(mediaFiles[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    });\n\n    ;\n    vjs.AdsLabel = vjs.Component.extend({\n        /** @constructor */\n        init: function (player, options) {\n            vjs.Component.call(this, player, options);\n\n            var that = this;\n\n            // We asynchronously reposition the ads label element\n            setTimeout(function () {\n                var currentTimeComp = player.controlBar && ( player.controlBar.getChild(\"timerControls\") || player.controlBar.getChild(\"currentTimeDisplay\") );\n                if (currentTimeComp) {\n                    player.controlBar.el().insertBefore(that.el(), currentTimeComp.el());\n                }\n                dom.removeClass(that.el(), 'vjs-label-hidden');\n            }, 0);\n        }\n    });\n\n    vjs.AdsLabel.prototype.createEl = function () {\n        return vjs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-ads-label vjs-control vjs-label-hidden',\n            innerHTML: 'Advertisement'\n        });\n    };\n    ;\n    /**\n     * The component that shows a black screen until the ads plugin has decided if it can or it can not play the ad.\n     *\n     * Note: In case you wonder why instead of this black poster we don't just show the spinner loader.\n     *       IOS devices do not work well with animations and the browser chrashes from time to time That is why we chose to\n     *       have a secondary black poster.\n     *\n     *       It also makes it much more easier for the users of the plugin since it does not change the default behaviour of the\n     *       spinner and the player works the same way with and without the plugin.\n     *\n     * @param {vjs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    vjs.BlackPoster = vjs.Component.extend({\n        /** @constructor */\n        init: function (player, options) {\n            vjs.Component.call(this, player, options);\n\n            var posterImg = player.getChild('posterImage');\n\n            //We need to do it asynchronously to be sure that the black poster el is on the dom.\n            setTimeout(function () {\n                if (posterImg) {\n                    player.el().insertBefore(this.el(), posterImg.el());\n                }\n            }.bind(this), 0);\n        }\n    });\n\n    /**\n     * Create the black poster div element\n     * @return {Element}\n     */\n    vjs.BlackPoster.prototype.createEl = function () {\n        return vjs.createEl('div', {\n            className: 'vjs-black-poster'\n        });\n    };\n    ;\n    function VPAIDAdUnitWrapper(vpaidAdUnit, opts) {\n        if (!(this instanceof VPAIDAdUnitWrapper)) {\n            return new VPAIDAdUnitWrapper(vpaidAdUnit, opts);\n        }\n        sanityCheck(vpaidAdUnit, opts);\n\n        this.options = extend({}, opts);\n\n        this._adUnit = vpaidAdUnit;\n        this._adStopped = false;\n        this._adStarted = false;\n\n        /*** Local Functions ***/\n        function sanityCheck(adUnit, opts) {\n            if (!adUnit || !VPAIDAdUnitWrapper.checkVPAIDInterface(adUnit)) {\n                throw new VASTError('on VPAIDAdUnitWrapper, the passed VPAID adUnit does not fully implement the VPAID interface');\n            }\n\n            if (!isObject(opts)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper, expected options hash  but got '\" + opts + \"'\");\n            }\n\n            if (!(\"adCancelTimeout\" in opts) || !isNumber(opts.adCancelTimeout)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper, expected adCancelTimeout in options\");\n            }\n        }\n    }\n\n    VPAIDAdUnitWrapper.checkVPAIDInterface = function checkVPAIDInterface(VPAIDAdUnit) {\n        //NOTE: skipAd is not part of the method list because it only appears in VPAID 2.0 and we support VPAID 1.0\n        var VPAIDInterfaceMethods = [\n            'handshakeVersion', 'initAd', 'startAd', 'stopAd', 'resizeAd', 'pauseAd', 'expandAd', 'collapseAd'\n        ];\n\n        for (var i = 0, len = VPAIDInterfaceMethods.length; i < len; i++) {\n            if (!VPAIDAdUnit || !isFunction(VPAIDAdUnit[VPAIDInterfaceMethods[i]])) {\n                return false;\n            }\n        }\n\n\n        return canSubscribeToEvents(VPAIDAdUnit) && canUnsubscribeFromEvents(VPAIDAdUnit);\n\n        /*** Local Functions ***/\n\n        function canSubscribeToEvents(adUnit) {\n            return isFunction(adUnit.subscribe) || isFunction(adUnit.addEventListener) || isFunction(adUnit.on);\n        }\n\n        function canUnsubscribeFromEvents(adUnit) {\n            return isFunction(adUnit.unsubscribe) || isFunction(adUnit.removeEventListener) || isFunction(adUnit.off);\n\n        }\n    };\n\n    VPAIDAdUnitWrapper.prototype.adUnitAsyncCall = function () {\n        var args = arrayLikeObjToArray(arguments);\n        var method = args.shift();\n        var cb = args.pop();\n        var timeoutId;\n\n        sanityCheck(method, cb, this._adUnit);\n        args.push(wrapCallback());\n\n        this._adUnit[method].apply(this._adUnit, args);\n        timeoutId = setTimeout(function () {\n            timeoutId = null;\n            cb(new VASTError(\"on VPAIDAdUnitWrapper, timeout while waiting for a response on call '\" + method + \"'\"));\n            cb = noop;\n        }, this.options.adCancelTimeout);\n\n        /*** Local functions ***/\n        function sanityCheck(method, cb, adUnit) {\n            if (!isString(method) || !isFunction(adUnit[method])) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.adUnitAsyncCall, invalid method name\");\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.adUnitAsyncCall, missing callback\");\n            }\n        }\n\n        function wrapCallback() {\n            return function () {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                cb.apply(this, arguments);\n            };\n        }\n    };\n\n    VPAIDAdUnitWrapper.prototype.on = function (evtName, handler) {\n        var addEventListener = this._adUnit.addEventListener || this._adUnit.subscribe || this._adUnit.on;\n        addEventListener.call(this._adUnit, evtName, handler);\n    };\n\n    VPAIDAdUnitWrapper.prototype.off = function (evtName, handler) {\n        var removeEventListener = this._adUnit.removeEventListener || this._adUnit.unsubscribe || this._adUnit.off;\n        removeEventListener.call(this._adUnit, evtName, handler);\n    };\n\n    //minthe : waitForEvent\n    VPAIDAdUnitWrapper.prototype.waitForEvent = function (evtName, cb, context) {\n        var timeoutId;\n        sanityCheck(evtName, cb);\n        context = context || null;\n\n        this.on(evtName, responseListener);\n\n        timeoutId = setTimeout(function () {\n            cb(new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, timeout while waiting for event '\" + evtName + \"'\"));\n            timeoutId = null;\n            cb = noop;\n        }, this.options.adCancelTimeout);\n\n        /*** Local functions ***/\n        function sanityCheck(evtName, cb) {\n            if (!isString(evtName)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, missing evt name\");\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, missing callback\");\n            }\n        }\n\n        function responseListener() {\n            var args = arrayLikeObjToArray(arguments);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n\n            args.unshift(null);\n            cb.apply(context, args);\n        }\n    };\n\n// VPAID METHODS\n    VPAIDAdUnitWrapper.prototype.handshakeVersion = function (version, cb) {\n        this.adUnitAsyncCall('handshakeVersion', version, cb);\n    };\n\n    /* jshint maxparams:6 */\n    VPAIDAdUnitWrapper.prototype.initAd = function (width, height, viewMode, desiredBitrate, adUnitData, environmentVars, cb) {\n        //minthe : AdLoaded\n        logger.info('Calling VPAID initAd, time remaining =' + profile.getRemainingTime('initAd'));\n        this.waitForEvent('AdLoaded', cb);\n\n        //minthe VID-1580\n        this._adUnit.initAd(width, height, viewMode, desiredBitrate, adUnitData, environmentVars);\n\n    };\n\n    VPAIDAdUnitWrapper.prototype.resizeAd = function (width, height, viewMode, cb) {\n        // NOTE: AdSizeChange event is only supported on VPAID 2.0 so for the moment we are not going to use it\n        // and will assume that everything is fine after the async call\n        this.adUnitAsyncCall('resizeAd', width, height, viewMode, cb);\n    };\n\n    VPAIDAdUnitWrapper.prototype.startAd = function (cb) {\n        logger.info('Calling VPAID startAd, time remaining =' + profile.getRemainingTime('startAd'));\n        this.waitForEvent('AdStarted', cb);\n        this._adUnit.startAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.stopAd = function (cb) {\n        logger.info(' Calling VPAID stopAd');\n        this.waitForEvent('AdStopped', cb);\n        this._adUnit.stopAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.pauseAd = function (cb) {\n        if(this._adStopped || !this._adStarted)return;\n        logger.log(' Calling VPAID pauseAd');\n        this._adUnit.pauseAd();\n        timer.startKillTimeout(this._adUnit);\n    };\n\n    VPAIDAdUnitWrapper.prototype.resumeAd = function (cb) {\n        if(this._adStopped || !this._adStarted)return;\n        logger.log(' Calling VPAID resumeAd');\n        this.waitForEvent('AdPlaying', cb);\n        this._adUnit.resumeAd();\n        timer.startKillTimeout(this._adUnit);\n    };\n\n    VPAIDAdUnitWrapper.prototype.expandAd = function (cb) {\n        if(this._adStopped)return;\n        this.waitForEvent('AdExpandedChange', cb);\n        this._adUnit.expandAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.collapseAd = function (cb) {\n        if(this._adStopped)return;\n        this.waitForEvent('AdExpandedChange', cb);\n        this._adUnit.collapseAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.skipAd = function (cb) {\n        if(this._adStopped)return;\n        logger.log('Calling VPAID skipAd');\n        this.waitForEvent('AdSkipped', cb);\n        this._adUnit.skipAd();\n    };\n\n//VPAID property getters\n    [\n        'adLinear',\n        'adWidth',\n        'adHeight',\n        'adExpanded',\n        'adSkippableState',\n        'adRemainingTime',\n        'adDuration',\n        'adVolume',\n        'adCompanions',\n        'adIcons'\n    ].forEach(function (property) {\n            var getterName = 'get' + capitalize(property);\n\n            VPAIDAdUnitWrapper.prototype[getterName] = function (cb) {\n                this.adUnitAsyncCall(getterName, cb);\n            };\n        });\n\n//VPAID property setters\n    VPAIDAdUnitWrapper.prototype.setAdVolume = function (volume, cb) {\n        if(this._adStopped)return;\n        logger.debug('Calling VPAID setAdVolume :: volume :' + volume);\n        this.adUnitAsyncCall('setAdVolume', volume, cb);\n    };\n\n    ;\n    function VPAIDFlashTech(mediaFile, settings) {\n        if (!(this instanceof VPAIDFlashTech)) {\n            return new VPAIDFlashTech(mediaFile);\n        }\n        sanityCheck(mediaFile);\n        this.name = 'vpaid-flash';\n        this.mediaFile = mediaFile;\n        this.containerEl = null;\n        this.vpaidFlashClient = null;\n        this.settings = settings;\n\n        /*** local functions ***/\n        function sanityCheck(mediaFile) {\n            if (!mediaFile || !isString(mediaFile.src)) {\n                throw new VASTError('on VPAIDFlashTech, invalid MediaFile');\n            }\n        }\n    }\n\n    VPAIDFlashTech.supports = function (type) {\n        return type === 'application/x-shockwave-flash' && VPAIDFLASHClient.isSupported();\n    };\n\n    VPAIDFlashTech.prototype.loadAdUnit = function loadFlashCreative(containerEl, objectEl, callback) {\n        var that = this;\n        var flashClientOpts = this.settings && this.settings.vpaidFlashLoaderPath ? {data: this.settings.vpaidFlashLoaderPath} : undefined;\n        sanityCheck(containerEl, callback);\n\n        this.containerEl = containerEl;\n        this.vpaidFlashClient = new VPAIDFLASHClient(containerEl, function (error) {\n            if (error) {\n                return callback(error);\n            }\n\n            that.vpaidFlashClient.loadAdUnit(that.mediaFile.src, callback);\n        }, flashClientOpts);\n\n        /*** Local Functions ***/\n        function sanityCheck(container, cb) {\n\n            if (!dom.isDomElement(container)) {\n                throw new VASTError('on VPAIDFlashTech.loadAdUnit, invalid dom container element');\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError('on VPAIDFlashTech.loadAdUnit, missing valid callback');\n            }\n        }\n    };\n\n    VPAIDFlashTech.prototype.unloadAdUnit = function () {\n        if (this.vpaidFlashClient) {\n            try {\n                this.vpaidFlashClient.destroy();\n            } catch (e) {\n                if (console && isFunction(console.log)) {\n                    console.log('VAST ERROR: trying to unload the VPAID adunit');\n                }\n            }\n            this.vpaidFlashClient = null;\n        }\n\n        if (this.containerEl) {\n            dom.remove(this.containerEl);\n            this.containerEl = null;\n        }\n    };\n\n    ;\n    function VPAIDHTML5Tech(mediaFile) {\n\n        if (!(this instanceof VPAIDHTML5Tech)) {\n            return new VPAIDHTML5Tech(mediaFile);\n        }\n\n        sanityCheck(mediaFile);\n\n        this.name = 'vpaid-html5';\n        this.containerEl = null;\n        this.videoEl = null;\n        this.vpaidHTMLClient = null;\n\n        this.mediaFile = mediaFile;\n\n        function sanityCheck(mediaFile) {\n            if (!mediaFile || !isString(mediaFile.src)) {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_MEDIA_FILE);\n            }\n        }\n    }\n\n    VPAIDHTML5Tech.supports = function (type) {\n        return !isOldIE() && type === 'application/javascript';\n    };\n\n    VPAIDHTML5Tech.prototype.loadAdUnit = function loadAdUnit(containerEl, videoEl, callback) {\n        sanityCheck(containerEl, videoEl, callback);\n\n        this.containerEl = containerEl;\n        this.videoEl = videoEl;\n        this.vpaidHTMLClient = new VPAIDHTML5Client(containerEl, videoEl, {});\n        this.vpaidHTMLClient.loadAdUnit(this.mediaFile.src, callback);\n\n\n\n        function sanityCheck(container, video, cb) {\n            if (!dom.isDomElement(container)) {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);\n            }\n\n            if (!dom.isDomElement(video) || video.tagName.toLowerCase() !== 'video') {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(VPAIDHTML5Tech.MISSING_CALLBACK);\n            }\n        }\n    };\n\n    VPAIDHTML5Tech.prototype.unloadAdUnit = function unloadAdUnit() {\n        if (this.vpaidHTMLClient) {\n            try {\n                this.vpaidHTMLClient.destroy();\n            } catch (e) {\n                if (console && isFunction(console.log)) {\n                    console.log('VAST ERROR: trying to unload the VPAID adunit');\n                }\n            }\n\n            this.vpaidHTMLClient = null;\n        }\n\n        if (this.containerEl) {\n            dom.remove(this.containerEl);\n            this.containerEl = null;\n        }\n    };\n\n    var PREFIX = 'on VPAIDHTML5Tech';\n    VPAIDHTML5Tech.INVALID_MEDIA_FILE = PREFIX + ', invalid MediaFile';\n    VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL = PREFIX + ', invalid container HtmlElement';\n    VPAIDHTML5Tech.INVALID_DOM_VIDEO_EL = PREFIX + ', invalid HTMLVideoElement';\n    VPAIDHTML5Tech.MISSING_CALLBACK = PREFIX + ', missing valid callback';\n\n\n    ;\n    function VPAIDIntegrator(player, settings) {\n        if (!(this instanceof VPAIDIntegrator)) {\n            return new VPAIDIntegrator(player);\n        }\n\n        this.VIEW_MODE = {\n            NORMAL: 'normal',\n            FULLSCREEN: \"fullscreen\",\n            THUMBNAIL: \"thumbnail\"\n        };\n        this.player = player;\n        this.containerEl = createVPAIDContainerEl(player);\n        this.options = {\n            adCancelTimeout: 5000,\n            VPAID_VERSION: '2.0'\n        };\n        this.settings = settings;\n        this.volume = 1;\n        this.initVolume = 1;\n        if(this.settings.initialAudio === 'off'){\n            logger.log(\"Initial audio off\");\n            this.initVolume = 0;\n        }\n        this.initAdUnitCalled = false;\n        this.initialisedAdUnit = null;\n        this.initAdTimeout = false;\n        /*** Local functions ***/\n\n        function createVPAIDContainerEl() {\n            var containerEl = document.createElement('div');\n            dom.addClass(containerEl, 'VPAID-container');\n            player.el().insertBefore(containerEl, player.controlBar.el());\n            return containerEl;\n\n        }\n        this.EVENTS = [\n            'AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange',\n            'AdSizeChange', 'AdLinearChange', 'AdDurationChange', 'AdExpandedChange',\n            'AdRemainingTimeChange', 'AdVolumeChange', 'AdImpression', 'AdVideoStart',\n            'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile',\n            'AdVideoComplete', 'AdClickThru', 'AdInteraction', 'AdUserAcceptInvitation',\n            'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError'\n        ];\n    }\n\n//List of supported VPAID technologies\n    VPAIDIntegrator.techs = [\n        VPAIDFlashTech,\n        VPAIDHTML5Tech\n    ];\n\n    //minthe : protoype.playAd\n    VPAIDIntegrator.prototype.playAd = function playVPaidAd(vastResponse, callback, isTestPlay) {\n        //flag to sperate logic for checking vpaid ad is valid\n        isTestPlay = (isTestPlay && isTestPlay !== undefined ? isTestPlay : false);\n\n        var that = this;\n        var tech;\n        var player = this.player;\n\n        callback = callback || noop;\n        if (!(vastResponse instanceof VASTResponse)) {\n            return callback(new VASTError('on VASTIntegrator.playAd, missing required VASTResponse'));\n        }\n\n        tech = this._findSupportedTech(vastResponse, this.settings);\n        dom.addClass(player.el(), 'vjs-vpaid-ad');\n\n        player.on('vast.adsCancel', triggerVpaidAdEnd);\n        player.one('vpaid.adEnd', function () {\n            player.off('vast.adsCancel', triggerVpaidAdEnd);\n            removeAdUnit();\n        });\n\n        if (tech) {\n\n            //if it's test-play this routine will invoke initAd and return result to notify the creative is ready to go\n            if (isTestPlay) {\n                async.waterfall([\n                    function (next) {\n                        next(null, tech, vastResponse);\n                    },\n                    this._loadAdUnit.bind(this),\n                    this._initAdUnit.bind(this)\n                ], function (error, adUnit, vastResponse) {\n                    if (error) {\n                        that._trackError(vastResponse);\n                    } else {\n                        player.trigger('an.readytogovpaid');\n                    }\n                    callback(error, vastResponse);\n                });\n            } else {\n                var errorCallback = function (error, adUnit, vastResponse) {\n                    if (error) {\n                        that._trackError(vastResponse);\n                    }\n                    player.trigger('vpaid.adEnd');\n                    callback(error, vastResponse);\n                };\n                var taskList = [\n                    function (next) {\n                        next(null, that.initialisedAdUnit, vastResponse, true);\n                    },\n                    this._playAdUnit.bind(this)\n                ];\n                if(this.initialisedAdUnit){\n                    async.waterfall(taskList, errorCallback);\n                } else {\n                    if(this.initAdUnitCalled){\n                        player.one(\"an.readytogovpaid\", function(){\n                            async.waterfall(taskList, errorCallback);\n                        });\n                    } else{\n                        async.waterfall([\n                            function (next) {\n                                next(null, tech, vastResponse);\n                            },\n                            this._loadAdUnit.bind(this),\n                            this._initAdUnit.bind(this),\n                            this._playAdUnit.bind(this)\n                        ], errorCallback);\n                    }\n                }\n            }\n\n            this._adUnit = {\n                _paused: true,\n                type: 'VPAID',\n                pauseAd: function () {\n                    player.trigger('vpaid.pauseAd');\n                    player.pause(true);//we make sure that the video content gets stopped.\n                },\n                resumeAd: function () {\n                    player.trigger('vpaid.resumeAd');\n                },\n                isPaused: function () {\n                    return this._paused;\n                },\n                getSrc: function () {\n                    return tech.mediaFile;\n                }\n            };\n\n            return this._adUnit;\n        }\n\n        callback(new VASTError('on VPAIDIntegrator.playAd, could not find a supported mediaFile'));\n\n        return null;\n        /*** Local functions ***/\n        function triggerVpaidAdEnd() {\n            player.trigger('vpaid.adEnd');\n        }\n\n        function removeAdUnit() {\n            if (tech) {\n                tech.unloadAdUnit();\n            }\n            dom.removeClass(player.el(), 'vjs-vpaid-ad');\n        }\n    };\n\n    VPAIDIntegrator.prototype._findSupportedTech = function (vastResponse, settings) {\n        if (!(vastResponse instanceof VASTResponse)) {\n            return null;\n        }\n\n        var vpaidMediaFiles = vastResponse.mediaFiles.filter(vastUtil.isVPAID);\n        var i, len, mediaFile, VPAIDTech;\n\n        for (i = 0, len = vpaidMediaFiles.length; i < len; i += 1) {\n            mediaFile = vpaidMediaFiles[i];\n            VPAIDTech = findSupportedTech(mediaFile);\n            if (VPAIDTech) {\n                return new VPAIDTech(mediaFile, settings);\n            }\n        }\n\n        return null;\n\n        /*** Local functions ***/\n        function findSupportedTech(mediafile) {\n            var type = mediafile.type;\n            var i, len, VPAIDTech;\n\n            for (i = 0, len = VPAIDIntegrator.techs.length; i < len; i += 1) {\n                VPAIDTech = VPAIDIntegrator.techs[i];\n                if (VPAIDTech.supports(type)) {\n                    return VPAIDTech;\n                }\n            }\n            return null;\n        }\n    };\n\n    //minthe : loadAdUnit\n    VPAIDIntegrator.prototype._loadAdUnit = function (tech, vastResponse, next) {\n        if(this.initAdUnitCalled){\n            return;\n        }\n        var player = this.player;\n        var vjsTechEl = player.el().querySelector('.vjs-tech');\n        var adCancelTimeout = this.settings.adCancelTimeout || this.options.adCancelTimeout;\n        tech.loadAdUnit(this.containerEl, vjsTechEl, function (error, adUnit) {\n            if (error) {\n                return next(error, adUnit, vastResponse);\n            }\n\n            try {\n                var WrappedAdUnit = new VPAIDAdUnitWrapper(adUnit, {src: tech.mediaFile.src, adCancelTimeout: adCancelTimeout});\n                var techClass = 'vjs-' + tech.name + '-ad';\n                dom.addClass(player.el(), techClass);\n                player.one('vpaid.adEnd', function () {\n                    dom.removeClass(player.el(), techClass);\n                });\n                next(null, WrappedAdUnit, vastResponse);\n            } catch (e) {\n                next(e, adUnit, vastResponse);\n            }\n        });\n    };\n\n\n    //minthe : _testAdUnit\n    VPAIDIntegrator.prototype._initAdUnit = function (adUnit, vastResponse, callback) {\n        if(this.initAdUnitCalled){\n            return;\n        }\n        this.initAdUnitCalled = true;\n        async.waterfall([\n            function (next) {\n                next(null, adUnit, vastResponse);\n            },\n            this._handshake.bind(this),\n            this._setupEvents.bind(this),\n            this._initAd.bind(this)\n        ], callback);\n    };\n\n    //minthe : _playAdUnit\n    VPAIDIntegrator.prototype._playAdUnit = function (adUnit, vastResponse, callback) {\n        async.waterfall([\n            function (next) {\n                next(null, adUnit, vastResponse);\n            },\n            this._addSkipButton.bind(this),\n            this._linkPlayerControls.bind(this),\n            this._startAd.bind(this)\n        ], callback);\n    };\n\n    VPAIDIntegrator.prototype._handshake = function handshake(adUnit, vastResponse, next) {\n        adUnit.handshakeVersion(this.options.VPAID_VERSION, function (error, version) {\n            if (error) {\n                return next(error, adUnit, vastResponse);\n            }\n\n            if (version && isSupportedVersion(version)) {\n                return next(null, adUnit, vastResponse);\n            }\n\n            return next(new VASTError('on VPAIDIntegrator._handshake, unsupported version \"' + version + '\"'), adUnit, vastResponse);\n        });\n\n        function isSupportedVersion(version) {\n            var majorNum = major(version);\n            return majorNum >= 1 && majorNum <= 2;\n        }\n\n        function major(version) {\n            var parts = version.split('.');\n            return parseInt(parts[0], 10);\n        }\n    };\n\n    //minthe : _initAd\n    VPAIDIntegrator.prototype._initAd = function (adUnit, vastResponse, next) {\n        var self = this;\n        var tech = this.player.el().querySelector('.vjs-tech');\n        var dimension = dom.getDimension(tech);\n        // Reset the timeout flag\n        self.initAdTimeout = false;\n\n        timer.startInitAdTimeout(function(error){\n            self.initAdTimeout = true;\n            self._reportTimeout(adUnit, error);\n        });\n        /*\n        adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, {AdParameters: vastResponse.adParameters || ''}, function (error) {\n            self.initialisedAdUnit = adUnit;\n            next(error, adUnit, vastResponse);\n        });\n        */\n\n        adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, {AdParameters: vastResponse.adParameters || ''}, self.settings.vpaidEnvironmentVars, function (error) {\n            self.initialisedAdUnit = adUnit;\n            next(error, adUnit, vastResponse);\n        });\n    };\n\n    VPAIDIntegrator.prototype._setupEvents = function (adUnit, vastResponse, next) {\n        var adUnitSrc = adUnit.options.src;\n        var tracker = new VASTTracker(adUnitSrc, vastResponse);\n        var player = this.player;\n        var that = this;\n\n        function setupEventCallbacks(){\n            var cb = that.settings.vpaidEventCallback;\n            if(!cb) return;\n            that.EVENTS.forEach(function (event) {\n                adUnit.on(event,function(){\n                    cb.call(this, event);\n                });\n            });\n        };\n\n        setupEventCallbacks();\n\n        adUnit.on('AdLoaded', function () {\n            timer.stopInitAdTimeout();\n            logger.info('VPAID event received :: AdLoaded, time = '+ profile.getInitTime() + ', time remaining = ' + profile.getRemainingTime('AdLoaded'));\n        });\n\n        //minthe2 AdStarted Handler\n        //fix for VID-1525\n        adUnit.on('AdStarted', function () {\n\n            adUnit._adStarted = true;\n            profile.adStartedTimestamp = new Date().getTime();\n\n            if (that.settings.delayExpandUntilVPAIDImpression) {\n                if (profile.adImpressionTimestamp !== 0 && profile.adStartedTimestamp !==0) {\n                    timer.stopStartAdTimeout();\n                }\n            } else {\n                timer.stopStartAdTimeout();\n            }\n\n            // if (profile.adImpressionTimestamp !== 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adLoadedTimestamp = profile.adImpressionTimestamp;\n            // }\n\n\n\n\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adImpressionTimestamp === 0) {\n                logger.info('VPAID event received :: AdStarted');\n            } else {\n                logger.info('VPAID event received :: AdStarted, time = '+ profile.getStartTime() + ', total time = '+ profile.getTotalTime() + ', time remaining = ' + profile.getRemainingTime('AdStarted'));\n            }\n\n            handleAdPlayPause();\n            handleAdProgress();\n            player.trigger('vpaid.AdStarted');\n            tracker.trackCreativeView();\n            notifyPlayToPlayer();\n\n\n            //activate impression timer if it's not already started\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adImpressionTimestamp === 0) {\n                profile.adImpressionTimestamp = new Date().getTime();\n                // timer.startAdImpressionTimeout(function (error) {\n                //     that._reportTimeout(adUnit, error);\n                // });\n            }\n        });\n\n        // For creatives that do not use the video tag provided by the player.\n        function handleAdPlayPause(){\n            // Ad creatives do not creative their own video tags on devices so no need to handle AdProgess timer\n            // TODO : find  more reliable way to figure out the video src set.\n            if(isIDevice() || isAndroid()){\n                return;\n            }\n\n            // Ad uses video JS Slot\n            if(isVideoSlotUsed()){\n                return;\n            }\n            var creative = adUnit._adUnit._creative;\n            //IE11 has an issue to not listen this pause event - VID-2405, VID-2406\n            //video.js has their own event pooling sytem for video element and parent div of video element, the \"pause event\" area is so crowded for now - when vpaid player injects \"pause\" listener to player object on IE11, the video.js doesn't handle as well. looks like incorrect GUID setting problem in order to get events unique\n            //for handling this vpaid-creative.pause by \"pause\" signal from video.js we don't have to stick with the crowded \"pause\" signal. we can do samething with differnet signal for this\n            // player.on('pause', function(){\n            //     if(creative){\n            //         that._adUnit.pauseAd();\n            //     }\n            // });\n            player.on('apn-vpaid-pause', function(){//this \"apn-vpaid-pause\" will be dispatch from video.js pause.\n                if(creative){\n                    // that._adUnit.pauseAd();//no need to dispatch pause again to video.js because video.js already dispatch pause before triggered \"apn-vpaid-pause\". this will also cover a case showing pause button on the UI\n                    player.trigger('vpaid.pauseAd');//vpaid video pause\n                }\n            });\n        };\n\n        // For creatives that do not use the video tag provided by the player.\n        function handleAdProgress() {\n\n            // Ad creatives do not creative their own video tags on devices so no need to handle AdProgess timer\n            // TODO : find  more reliable way to figure out the video src set.\n            //if(isIDevice() || isAndroid()){\n            if(isIDevice()){//for VID-2597\n                return;\n            }\n\n            // Ad uses video JS Slot\n            if(isVideoSlotUsed()){\n                return;\n            }\n\n            // Ad is using its own Video slot.\n            var creative = adUnit._adUnit._creative;\n            var remainingTimeUnknown = false;\n            function updateProgress(){\n                var duration = creative.getAdDuration ? creative.getAdDuration() : 0;\n                var remainingTime = creative.getAdRemainingTime ? creative.getAdRemainingTime() : -1;\n                var currentTime = duration - remainingTime;\n                switch(remainingTime) {\n                    case -2:\n                        // If time is not currently known\n                        remainingTimeUnknown = true;\n                        player.controlBar.currentTimeDisplay.hide();\n                        player.controlBar.timeDivider.hide();\n                        player.controlBar.durationDisplay.hide();\n                        break;\n                    case -1:\n                        // If time is not implemeneted\n                        clearInterval(progressHandler);\n                        player.controlBar.currentTimeDisplay.hide();\n                        player.controlBar.timeDivider.hide();\n                        player.controlBar.durationDisplay.hide();\n                        break;\n                    case 0:\n                        clearInterval(progressHandler);\n                        break;\n                    default:\n                        if(remainingTimeUnknown){\n                            remainingTimeUnknown = false;\n                            player.controlBar.currentTimeDisplay.show();\n                            player.controlBar.timeDivider.show();\n                            player.controlBar.durationDisplay.show();\n                        }\n                        player.currentTime(currentTime);\n                        player.controlBar.currentTimeDisplay.updateContent();\n                        player.duration(duration);\n                        player.controlBar.durationDisplay.updateContent();\n                        break;\n                }\n            }\n            var progressHandler = setInterval(updateProgress, 200);\n            updateProgress();\n        }\n\n        adUnit.on('AdSkipped', function () {\n            logger.log('VPAID event received :: AdSkipped');\n            player.trigger('vpaid.AdSkipped');\n            tracker.trackSkip();\n        });\n\n\n        //minthe2 AdImpression Handler\n        adUnit.on('AdImpression', function () {\n\n            profile.adImpressionTimestamp = new Date().getTime();\n\n\n            if (that.settings.delayExpandUntilVPAIDImpression) {\n                if (profile.adImpressionTimestamp !== 0 && profile.adStartedTimestamp !==0) {\n                    timer.stopStartAdTimeout();\n                }\n            }\n\n            // if (profile.adImpressionTimestamp !== 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adLoadedTimestamp = profile.adImpressionTimestamp;\n            // }\n            // if (profile.adStartedTimestamp === 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adStartedTimestamp = profile.adLoadedTimestamp;\n            // }\n\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adStartedTimestamp === 0) {\n                logger.info('VPAID event received :: AdImpression');\n            } else {\n                logger.info('VPAID event received :: AdImpression, time = '+ profile.getAdImpressionTime() + ', total time = '+ profile.getTotalTime() + ', time remaining = ' + profile.getRemainingTime('AdImpression'));\n            }\n\n\n            player.trigger('vpaid.AdImpression');\n            tracker.trackImpressions();\n        });\n\n        adUnit.on('AdVideoStart', function () {\n            logger.info('VPAID event received :: AdVideoStart');\n            player.trigger('vpaid.AdVideoStart');\n            tracker.trackStart();\n            notifyPlayToPlayer();\n            if(that.settings.initialAudio === 'off'){\n                player.muted(true);\n            } else {\n                player.muted(false);\n            }\n            linkVolumeControl();\n            if(!that.settings.disableControlsOnMouseover) {\n                setupControlsOnMouseover(player,adUnit,that.VIEW_MODE);\n            } else {\n                resizeAd(player,adUnit,that.VIEW_MODE);\n            }\n        });\n\n        adUnit.on('AdPlaying', function () {\n            logger.log('VPAID event received :: AdPlaying');\n            timer.stopKillTimeout();\n            player.trigger('vpaid.AdPlaying');\n            tracker.trackResume();\n            notifyPlayToPlayer();\n        });\n\n        adUnit.on('AdPaused', function () {\n            logger.log('VPAID event received :: AdPaused');\n            timer.stopKillTimeout();\n            player.trigger('vpaid.AdPaused');\n            tracker.trackPause();\n            notifyPauseToPlayer();\n        });\n\n        function notifyPlayToPlayer() {\n            if (that._adUnit && that._adUnit.isPaused()) {\n                that._adUnit._paused = false;\n            }\n            player.trigger('play');\n\n        }\n\n        function notifyPauseToPlayer() {\n            if (that._adUnit) {\n                that._adUnit._paused = true;\n            }\n            player.trigger('pause');\n        }\n\n        adUnit.on('AdVideoFirstQuartile', function () {\n            logger.info('VPAID event received :: AdVideoFirstQuartile');\n            player.trigger('vpaid.AdVideoFirstQuartile');\n            tracker.trackFirstQuartile();\n        });\n\n        adUnit.on('AdVideoMidpoint', function () {\n            logger.info('VPAID event received :: AdVideoMidpoint');\n            player.trigger('vpaid.AdVideoMidpoint');\n            tracker.trackMidpoint();\n        });\n\n        adUnit.on('AdVideoThirdQuartile', function () {\n            logger.info('VPAID event received :: AdVideoThirdQuartile');\n            player.trigger('vpaid.AdVideoThirdQuartile');\n            tracker.trackThirdQuartile();\n        });\n\n        adUnit.on('AdVideoComplete', function () {\n            logger.info('VPAID event received :: AdVideoComplete');\n            player.trigger('vpaid.AdVideoComplete');\n            tracker.trackComplete();\n        });\n\n        adUnit.on('AdClickThru', function (data) {\n            player.trigger('vpaid.AdClickThru');\n            var url = data.url;\n            var playerHandles = data.playerHandles;\n            var clickThruUrl = isNotEmptyString(url) ? url : generateClickThroughURL(vastResponse.clickThrough);\n\n            tracker.trackClick();\n            if (playerHandles && clickThruUrl) {\n                window.open(clickThruUrl, '_blank');\n            }\n\n            function generateClickThroughURL(clickThroughMacro) {\n                var variables = {\n                    ASSETURI: adUnit.options.src,\n                    CONTENTPLAYHEAD: 0 //In VPAID there is no method to know the current time from the adUnit\n                };\n\n                return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : null;\n            }\n        });\n\n        adUnit.on('AdUserAcceptInvitation', function () {\n            player.trigger('vpaid.AdUserAcceptInvitation');\n            tracker.trackAcceptInvitation();\n            tracker.trackAcceptInvitationLinear();\n        });\n\n        adUnit.on('AdUserClose', function () {\n            player.trigger('vpaid.AdUserClose');\n            tracker.trackClose();\n            tracker.trackCloseLinear();\n        });\n\n        adUnit.on('AdUserMinimize', function () {\n            player.trigger('vpaid.AdUserMinimize');\n            tracker.trackCollapse();\n        });\n\n        adUnit.on('AdError', function (message) {\n            timer.stopAdTimeouts();\n            logger.error('VPAID event received :: AdError : message : '+ message);\n            //player.trigger('vast.adError');//TODO jeff's change for VID-583\n            player.trigger('vpaid.AdError');\n            //NOTE: we track errors code 901, as noted in VAST 3.0\n            tracker.trackErrorWithCode(901);\n        });\n\n        adUnit.on('AdVolumeChange', function () {\n            logger.debug('VPAID event received :: AdVolumeChange');\n            player.trigger('vpaid.AdVolumeChange');\n        });\n\n        adUnit.on('AdStopped', function () {\n            logger.info('VPAID event received :: AdStopped');\n            adUnit._adStopped = true;\n            player.trigger('vpaid.AdStopped');\n        });\n\n        var updateViewSize = resizeAd.bind(this, player, adUnit, this.VIEW_MODE);\n        var autoResize = this.settings.autoResize;\n\n        if (autoResize) {\n            dom.addEventListener(window, 'resize', updateViewSize);\n            dom.addEventListener(window, 'orientationchange', updateViewSize);\n        }\n\n        player.on('vast.resize', updateViewSize);\n        player.on('vpaid.pauseAd', pauseAdUnit);\n        player.on('vpaid.resumeAd', resumeAdUnit);\n\n        player.one('vpaid.adEnd', function () {\n            player.off('vast.resize', updateViewSize);\n            player.off('vpaid.pauseAd', pauseAdUnit);\n            player.off('vpaid.resumeAd', resumeAdUnit);\n\n            if (autoResize) {\n                dom.removeEventListener(window, 'resize', updateViewSize);\n                dom.removeEventListener(window, 'orientationchange', updateViewSize);\n            }\n        });\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local Functions ***/\n        function pauseAdUnit() {\n            adUnit.pauseAd(noop);\n        }\n\n        function resumeAdUnit() {\n            adUnit.resumeAd(noop);\n        }\n\n        function isVideoSlotUsed(){\n            var videoSlot = adUnit._adUnit._videoEl;\n            var creative = adUnit._adUnit._creative;\n\n            // Ad uses video JS Slot\n            if( !creative || !videoSlot || videoSlot.src) {\n                return true;\n            }\n            return false;\n        }\n\n        function linkVolumeControl() {\n            // Ad uses video JS slot. Volume be controlled via Player Framework\n            if(isVideoSlotUsed()){\n               return;\n            }\n            // for creatives that create own tag set initial volume appropriately\n            adUnit.setAdVolume(that.initVolume, function(error, result){\n                if(error){\n                    logger.log('The volume change is not implemented as part of the ad unit');\n                } else {\n                    logger.debug('The volume change is implemented as part of the ad unit');\n                }\n            });\n            // Ad is using its own Video slot. Volume be controlled by setAdVolume\n            player.on('volumechange', updateAdUnitVolume);\n\n            player.one('vpaid.adEnd', function () {\n                player.off('volumechange', updateAdUnitVolume);\n            });\n\n            /*** local functions ***/\n            function updateAdUnitVolume() {\n                var vol;\n                if(player.muted()){\n                    vol = 0;\n                } else {\n                    that.volume = player.volume() ? player.volume(): that.volume;\n                    vol = that.volume;\n                }\n                adUnit.setAdVolume(vol, logError);\n            }\n        }\n    };\n\n    VPAIDIntegrator.prototype._addSkipButton = function (adUnit, vastResponse, next) {\n        var skipButton;\n        var player = this.player;\n\n        adUnit.on('AdSkippableStateChange', updateSkipButtonState);\n\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeSkipButton);\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local function ***/\n        function updateSkipButtonState() {\n            player.trigger('vpaid.AdSkippableStateChange');\n            adUnit.getAdSkippableState(function (error, isSkippable) {\n                if (isSkippable) {\n                    if (!skipButton) {\n                        addSkipButton(player);\n                    }\n                } else {\n                    removeSkipButton(player);\n                }\n            });\n        }\n\n        function addSkipButton(player) {\n            skipButton = createSkipButton(player);\n            player.el().appendChild(skipButton);\n        }\n\n        function removeSkipButton() {\n            dom.remove(skipButton);\n            skipButton = null;\n        }\n\n        function createSkipButton() {\n            var skipButton = window.document.createElement(\"div\");\n            dom.addClass(skipButton, \"vast-skip-button\");\n            dom.addClass(skipButton, \"enabled\");\n            skipButton.innerHTML = \"Skip ad\";\n\n            skipButton.onclick = function (e) {\n                adUnit.skipAd(noop);//We skip the adUnit\n\n                //We prevent event propagation to avoid problems with the clickThrough and so on\n                if (window.Event.prototype.stopPropagation !== undefined) {\n                    e.stopPropagation();\n                } else {\n                    return false;\n                }\n            };\n\n            return skipButton;\n        }\n    };\n\n    VPAIDIntegrator.prototype._linkPlayerControls = function (adUnit, vastResponse, next) {\n        var that = this;\n        linkFullScreenControl(this.player, adUnit, this.VIEW_MODE);\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local functions ***/\n\n        function linkFullScreenControl(player, adUnit, VIEW_MODE) {\n            var updateViewSize = resizeAd.bind(this, player, adUnit, VIEW_MODE);\n\n            player.on('fullscreenchange', updateViewSize);\n\n            player.one('vpaid.adEnd', function () {\n                player.off('fullscreenchange', updateViewSize);\n            });\n        }\n    };\n\n    //minthe : _startAd\n    VPAIDIntegrator.prototype._startAd = function (adUnit, vastResponse, next) {\n        var self = this;\n        var player = this.player;\n\n        if(self.initAdTimeout){\n            return;\n        }\n        timer.startStartAdTimeout(function(error){\n            self._reportTimeout(adUnit, error);\n        });\n        adUnit.startAd(function (error) {\n            if (!error) {\n                player.trigger('vast.adStart');\n            }\n        });\n    };\n\n\n    VPAIDIntegrator.prototype._trackError = function trackError(response) {\n        vastUtil.track(response.errorURLMacros, {ERRORCODE: 901});\n    };\n\n    VPAIDIntegrator.prototype._reportTimeout = function (adUnit, error) {\n        var player = this.player;\n        player.trigger({type: 'vast.adTimeout', error: error});\n        try{\n            if(adUnit && adUnit._adUnit){\n                logger.log(\"Calling VPAID stopAd on TIMEOUT\");\n                adUnit._adUnit.stopAd();\n            }\n        }catch(e){\n            logger.log('VPAID error in calling stopAd on Timeout');\n        }\n    };\n\n    function resizeAd(player, adUnit, VIEW_MODE) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var dimension = dom.getDimension(tech);\n        var width = dimension.width;\n        var height = dimension.height;\n        var MODE = player.isFullscreen() ? VIEW_MODE.FULLSCREEN : VIEW_MODE.NORMAL;\n\n        var slot = adUnit._adUnit._el;\n        var videoSlot = adUnit._adUnit._videoEl;\n\n        var controlBar = player.controlBar;\n        var controlBarHeight = controlBar ? controlBar.height() : 0;\n        if(controlBar && controlBarHeight){\n            height = dimension.height - controlBarHeight ;\n        }\n        //Resize both slot and video slot (Ads could use either or both)\n        if(slot && videoSlot){\n            slot.style.height = height + 'px';\n            videoSlot.style.height = height + 'px';\n        }\n        adUnit.resizeAd(width, height, MODE, logError);\n    };\n\n    function setupControlsOnMouseover(player, adUnit, VIEW_MODE){\n        var playerEl = player.el();\n        player.controlBar.hide();\n        if(!playerEl) return;\n        dom.addEventListener(playerEl, 'mouseover', onmouseover);\n        dom.addEventListener(playerEl, 'mouseout', onmouseout);\n\n        adUnit.on('AdStopped', function () {\n            player.controlBar.hide();\n            dom.removeEventListener(playerEl, 'mouseover', onmouseover);\n            dom.removeEventListener(playerEl, 'mouseout', onmouseout);\n        });\n\n        function onmouseover() {\n            var controlBarHeight = player.controlBar ? player.controlBar.height() : 0;\n            if(controlBarHeight === 0){\n                player.controlBar.show();\n                resizeAd(player, adUnit, VIEW_MODE);\n            }\n        };\n\n        function onmouseout() {\n            var controlBarHeight = player.controlBar ? player.controlBar.height() : 0;\n            if(controlBarHeight !== 0){\n                player.controlBar.hide();\n                resizeAd(player, adUnit, VIEW_MODE);\n            }\n        };\n    };\n\n    function logError(error) {\n        if (error) {\n            logger.log('ERROR: ' + error.message);\n        }\n    };\n\n    function Ad(adJTree) {\n        if (!(this instanceof Ad)) {\n            return new Ad(adJTree);\n        }\n\n        this.id = adJTree.attr('id');\n        this.sequence = adJTree.attr('sequence');\n\n        if (adJTree.inLine) {\n            this.inLine = new InLine(adJTree.inLine);\n        }\n\n        if (adJTree.wrapper) {\n            this.wrapper = new Wrapper(adJTree.wrapper);\n        }\n    };\n\n    function Creative(creativeJTree) {\n        if (!(this instanceof Creative)) {\n            return new Creative(creativeJTree);\n        }\n\n        this.id = creativeJTree.attr('id');\n        this.sequence = creativeJTree.attr('sequence');\n        this.adId = creativeJTree.attr('adId');\n        this.apiFramework = creativeJTree.attr('apiFramework');\n\n        if (creativeJTree.linear) {\n            this.linear = new Linear(creativeJTree.linear);\n        }\n    }\n    ;\n    function InLine(inlineJTree) {\n        if (!(this instanceof InLine)) {\n            return new InLine(inlineJTree);\n        }\n\n        //Required Fields\n        this.adTitle = xml.keyValue(inlineJTree.adTitle);\n        this.adSystem = xml.keyValue(inlineJTree.adSystem);\n        this.impressions = vastUtil.parseImpressions(inlineJTree.impression);\n        this.creatives = vastUtil.parseCreatives(inlineJTree.creatives);\n\n        //Optional Fields\n        this.description = xml.keyValue(inlineJTree.description);\n        this.advertiser = xml.keyValue(inlineJTree.advertiser);\n        this.surveys = parseSurveys(inlineJTree.survey);\n        this.error = xml.keyValue(inlineJTree.error);\n        this.pricing = xml.keyValue(inlineJTree.pricing);\n        this.extensions = inlineJTree.extensions;\n\n        /*** Local Functions ***/\n        function parseSurveys(inlineSurveys) {\n            if (inlineSurveys) {\n                return transformArray(isArray(inlineSurveys) ? inlineSurveys : [inlineSurveys], function (survey) {\n                    if (isNotEmptyString(survey.keyValue)) {\n                        return {\n                            uri: survey.keyValue,\n                            type: survey.attr('type')\n                        };\n                    }\n\n                    return undefined;\n                });\n            }\n            return [];\n        }\n    }\n    ;\n    function Linear(linearJTree) {\n        if (!(this instanceof Linear)) {\n            return new Linear(linearJTree);\n        }\n\n        //Required Elements\n        this.duration = vastUtil.parseDuration(xml.keyValue(linearJTree.duration));\n        this.mediaFiles = parseMediaFiles(linearJTree.mediaFiles && linearJTree.mediaFiles.mediaFile);\n\n        //Optional fields\n        this.trackingEvents = parseTrackingEvents(linearJTree.trackingEvents && linearJTree.trackingEvents.tracking, this.duration);\n        this.skipoffset = vastUtil.parseOffset(xml.attr(linearJTree, 'skipoffset'), this.duration);\n\n        if (linearJTree.videoClicks) {\n            this.videoClicks = new VideoClicks(linearJTree.videoClicks);\n        }\n\n        if (linearJTree.adParameters) {\n            this.adParameters = xml.keyValue(linearJTree.adParameters);\n\n            if (xml.attr(linearJTree.adParameters, 'xmlEncoded')) {\n                this.adParameters = xml.decode(this.adParameters);\n            }\n        }\n\n        /*** Local functions ***/\n        function parseTrackingEvents(trackingEvents, duration) {\n            var trackings = [];\n            if (isDefined(trackingEvents)) {\n                trackingEvents = isArray(trackingEvents) ? trackingEvents : [trackingEvents];\n                trackingEvents.forEach(function (trackingData) {\n                    trackings.push(new TrackingEvent(trackingData, duration));\n                });\n            }\n            return trackings;\n        }\n\n        function parseMediaFiles(mediaFilesJxonTree) {\n            var mediaFiles = [];\n            if (isDefined(mediaFilesJxonTree)) {\n                mediaFilesJxonTree = isArray(mediaFilesJxonTree) ? mediaFilesJxonTree : [mediaFilesJxonTree];\n\n                mediaFilesJxonTree.forEach(function (mfData) {\n                    mediaFiles.push(new MediaFile(mfData));\n                });\n            }\n            return mediaFiles;\n        }\n    }\n    ;\n    function MediaFile(mediaFileJTree) {\n        if (!(this instanceof MediaFile)) {\n            return new MediaFile(mediaFileJTree);\n        }\n\n        //Required attributes\n        this.src = xml.keyValue(mediaFileJTree);\n        this.delivery = mediaFileJTree.attr('delivery');\n        this.type = mediaFileJTree.attr('type');\n        this.width = mediaFileJTree.attr('width');\n        this.height = mediaFileJTree.attr('height');\n\n        //Optional attributes\n        this.codec = mediaFileJTree.attr('codec');\n        this.id = mediaFileJTree.attr('id');\n        this.bitrate = mediaFileJTree.attr('bitrate');\n        this.minBitrate = mediaFileJTree.attr('minBitrate');\n        this.maxBitrate = mediaFileJTree.attr('maxBitrate');\n        this.scalable = mediaFileJTree.attr('scalable');\n        this.maintainAspectRatio = mediaFileJTree.attr('maintainAspectRatio');\n        this.apiFramework = mediaFileJTree.attr('apiFramework');\n    }\n    ;\n    function TrackingEvent(trackingJTree, duration) {\n        if (!(this instanceof TrackingEvent)) {\n            return new TrackingEvent(trackingJTree, duration);\n        }\n\n        this.name = trackingJTree.attr('event');\n        this.uri = xml.keyValue(trackingJTree);\n\n        if ('progress' === this.name) {\n            this.offset = vastUtil.parseOffset(trackingJTree.attr('offset'), duration);\n        }\n    }\n\n    ;\n\n    //minthe : VASTClient initialize\n    function VASTClient(options) {\n\n        if (!(this instanceof VASTClient)) {\n            return new VASTClient(options);\n        }\n        var defaultOptions = {\n            WRAPPER_LIMIT: 5\n        };\n\n        options = options || {};\n        this.settings = extend({}, options, defaultOptions);\n        this.errorURLMacros = [];\n    }\n\n    VASTClient.prototype.getVASTResponse = function getVASTResponse(adTagUrl, callback) {\n        var that = this;\n\n        var error = sanityCheck(adTagUrl, callback);\n        if (error) {\n            if (isFunction(callback)) {\n                return callback(error);\n            }\n            throw error;\n        }\n\n        async.waterfall([\n                this._getVASTAd.bind(this, adTagUrl),\n                buildVASTResponse\n            ],\n            callback);\n\n        /*** Local functions ***/\n        function buildVASTResponse(adsChain, cb) {\n            try {\n                var response = that._buildVASTResponse(adsChain);\n                cb(null, response);\n            } catch (e) {\n                cb(e);\n            }\n        }\n\n        function sanityCheck(adTagUrl, cb) {\n            if (!adTagUrl) {\n                return new VASTError('on VASTClient.getVASTResponse, missing ad tag URL');\n            }\n\n            if (!isFunction(cb)) {\n                return new VASTError('on VASTClient.getVASTResponse, missing callback function');\n            }\n        }\n    };\n\n    VASTClient.prototype._getVASTAd = function (adTagUrl, callback) {\n        var that = this;\n\n        getAdWaterfall(adTagUrl, function (error, vastTree) {\n            var waterfallAds = vastTree && isArray(vastTree.ads) ? vastTree.ads : null;\n            if (error) {\n                that._trackError(error, waterfallAds);\n                return callback(error, waterfallAds);\n            }\n\n            getAd(waterfallAds.shift(), [], waterfallHandler);\n\n            /*** Local functions ***/\n            function waterfallHandler(error, adChain) {\n                if (error) {\n                    that._trackError(error, adChain);\n                    if (waterfallAds.length > 0) {\n                        getAd(waterfallAds.shift(), [], waterfallHandler);\n                    } else {\n                        callback(error, adChain);\n                    }\n                } else {\n                    callback(null, adChain);\n                }\n            }\n        });\n\n        /*** Local functions ***/\n        function getAdWaterfall(adTagUrl, callback) {\n            var requestVastXML = that._requestVASTXml.bind(that, adTagUrl);\n            async.waterfall([\n                requestVastXML,\n                buildVastWaterfall\n            ], callback);\n        }\n\n        function buildVastWaterfall(xmlStr, callback) {\n            var vastTree;\n            try {\n                vastTree = xml.toJXONTree(xmlStr);\n                vastTree.ads = isArray(vastTree.ad) ? vastTree.ad : [vastTree.ad];\n                callback(validateVASTTree(vastTree), vastTree);\n            } catch (e) {\n                callback(new VASTError(\"on VASTClient.getVASTAd.buildVastWaterfall, error parsing xml\", 100), null);\n            }\n        }\n\n        function validateVASTTree(vastTree) {\n            var vastVersion = xml.attr(vastTree, 'version');\n\n            if (!vastTree.ad) {\n                return new VASTError('on VASTClient.getVASTAd.validateVASTTree, no Ad in VAST tree', 303);\n            }\n\n            if (vastVersion && (vastVersion != 3 && vastVersion != 2)) {\n                return new VASTError('on VASTClient.getVASTAd.validateVASTTree, not supported VAST version \"' + vastVersion + '\"', 102);\n            }\n\n            return null;\n        }\n\n        function getAd(adTagUrl, adChain, callback) {\n            if (adChain.length >= that.WRAPPER_LIMIT) {\n                return callback(new VASTError(\"on VASTClient.getVASTAd.getAd, players wrapper limit reached (the limit is \" + that.WRAPPER_LIMIT + \")\", 302), adChain);\n            }\n\n            async.waterfall([\n                function (next) {\n                    if (isString(adTagUrl)) {\n                        requestVASTAd(adTagUrl, next);\n                    } else {\n                        next(null, adTagUrl);\n                    }\n                },\n                buildAd\n            ], function (error, ad) {\n                if (ad) {\n                    adChain.push(ad);\n                }\n\n                if (error) {\n                    return callback(error, adChain);\n                }\n\n                if (ad.wrapper) {\n                    return getAd(ad.wrapper.VASTAdTagURI, adChain, callback);\n                }\n\n                return callback(null, adChain);\n            });\n        }\n\n        function buildAd(adJxonTree, callback) {\n            try {\n                var ad = new Ad(adJxonTree);\n                callback(validateAd(ad), ad);\n            } catch (e) {\n                callback(new VASTError('on VASTClient.getVASTAd.buildAd, error parsing xml', 100), null);\n            }\n        }\n\n        function validateAd(ad) {\n            var wrapper = ad.wrapper;\n            var inLine = ad.inLine;\n            var errMsgPrefix = 'on VASTClient.getVASTAd.validateAd, ';\n\n            if (inLine && wrapper) {\n                return new VASTError(errMsgPrefix + \"InLine and Wrapper both found on the same Ad\", 101);\n            }\n\n            if (!inLine && !wrapper) {\n                return new VASTError(errMsgPrefix + \"nor wrapper nor inline elements found on the Ad\", 101);\n            }\n\n            if (inLine && inLine.creatives.length === 0) {\n                return new VASTError(errMsgPrefix + \"missing creative in InLine element\", 101);\n            }\n\n            if (wrapper && !wrapper.VASTAdTagURI) {\n                return new VASTError(errMsgPrefix + \"missing 'VASTAdTagURI' in wrapper\", 101);\n            }\n        }\n\n        function requestVASTAd(adTagUrl, callback) {\n            that._requestVASTXml(adTagUrl, function (error, xmlStr) {\n                if (error) {\n                    return callback(error);\n                }\n                try {\n                    var vastTree = xml.toJXONTree(xmlStr);\n                    callback(validateVASTTree(vastTree), vastTree.ad);\n                } catch (e) {\n                    callback(new VASTError(\"on VASTClient.getVASTAd.requestVASTAd, error parsing xml\", 100));\n                }\n            });\n        }\n    };\n\n    VASTClient.prototype._requestVASTXml = function requestVASTXml(adTagUrl, callback) {\n        try {\n            if (isFunction(adTagUrl)) {\n                adTagUrl(requestHandler);\n            } else {\n                http.get(adTagUrl, requestHandler, {\n                    withCredentials: true\n                });\n            }\n        } catch (e) {\n            callback(e);\n        }\n\n        /*** Local functions ***/\n        function requestHandler(error, response, status) {\n            if (error) {\n                var errMsg = isDefined(status) ?\n                \"on VASTClient.requestVastXML, HTTP request error with status '\" + status + \"'\" :\n                    \"on VASTClient.requestVastXML, Error getting the the VAST XML with he passed adTagXML fn\";\n                return callback(new VASTError(errMsg, 301), null);\n            }\n\n            callback(null, response);\n        }\n    };\n\n    VASTClient.prototype._buildVASTResponse = function buildVASTResponse(adsChain) {\n        var response = new VASTResponse();\n        addAdsToResponse(response, adsChain);\n        validateResponse(response);\n\n        return response;\n\n        //*** Local function ****\n        function addAdsToResponse(response, ads) {\n            ads.forEach(function (ad) {\n                response.addAd(ad);\n            });\n        }\n\n        function validateResponse(response) {\n            var progressEvents = response.trackingEvents.progress;\n\n            if (!response.hasLinear()) {\n                throw new VASTError(\"on VASTClient._buildVASTResponse, Received an Ad type that is not supported\", 200);\n            }\n\n            if (response.duration === undefined) {\n                throw new VASTError(\"on VASTClient._buildVASTResponse, Missing duration field in VAST response\", 101);\n            }\n\n            if (progressEvents) {\n                progressEvents.forEach(function (progressEvent) {\n                    if (!isNumber(progressEvent.offset)) {\n                        throw new VASTError(\"on VASTClient._buildVASTResponse, missing or wrong offset attribute on progress tracking event\", 101);\n                    }\n                });\n            }\n        }\n    };\n\n    VASTClient.prototype._trackError = function (error, adChain) {\n        if (!isArray(adChain) || adChain.length === 0) { //There is nothing to track\n            return;\n        }\n\n        var errorURLMacros = [];\n        adChain.forEach(addErrorUrlMacros);\n        vastUtil.track(errorURLMacros, {ERRORCODE: error.code || 900});  //900 <== Undefined error\n\n        /*** Local functions  ***/\n        function addErrorUrlMacros(ad) {\n            if (ad.wrapper && ad.wrapper.error) {\n                errorURLMacros.push(ad.wrapper.error);\n            }\n\n            if (ad.inLine && ad.inLine.error) {\n                errorURLMacros.push(ad.inLine.error);\n            }\n        }\n    };\n\n    ;\n    var VAST = {};\n\n    function VASTError(message, code) {\n        this.message = 'VAST Error: ' + (message || '');\n        if (code) {\n            this.code = code;\n        }\n    }\n\n    VASTError.prototype = new Error();\n    VASTError.prototype.name = \"VAST Error\";\n    ;\n    /**\n     * Inner helper class that deals with the logic of the individual steps needed to setup an ad in the player.\n     *\n     * @param player {object} instance of the player that will play the ad. It assumes that the videojs-contrib-ads plugin\n     *                        has been initialized when you use its utility functions.\n     *\n     * @constructor\n     */\n    function VASTIntegrator(player) {\n        if (!(this instanceof VASTIntegrator)) {\n            return new VASTIntegrator(player);\n        }\n\n        this.player = player;\n    }\n\n    VASTIntegrator.prototype.playAd = function playAd(vastResponse, callback) {\n        var that = this;\n        callback = callback || noop;\n\n        if (!(vastResponse instanceof VASTResponse)) {\n            return callback(new VASTError('On VASTIntegrator, missing required VASTResponse'));\n        }\n\n        async.waterfall([\n            function (next) {\n                next(null, vastResponse);\n            },\n            this._selectAdSource.bind(this),\n            this._createVASTTracker.bind(this),\n            this._addClickThrough.bind(this),\n            this._addSkipButton.bind(this),\n            this._setupEvents.bind(this),\n            this._playSelectedAd.bind(this)\n        ], function (error, response) {\n            if (error && response) {\n                that._trackError(error, response);\n            }\n            callback(error, response);\n        });\n\n        this._adUnit = {\n            _src: null,\n            type: 'VAST',\n            pauseAd: function () {\n                that.player.pause(true);//video.js player pause\n            },\n\n            resumeAd: function () {\n                that.player.play(true);\n            },\n\n            isPaused: function () {\n                return that.player.paused(true);\n            },\n\n            getSrc: function () {\n                return this._src;\n            }\n        };\n\n        return this._adUnit;\n    };\n\n    VASTIntegrator.prototype._selectAdSource = function selectAdSource(response, callback) {\n        var source;\n\n        var playerWidth = dom.getDimension(this.player.el()).width;\n        response.mediaFiles.sort(function compareTo(a, b) {\n            var deltaA = Math.abs(playerWidth - a.width);\n            var deltaB = Math.abs(playerWidth - b.width);\n            return deltaA - deltaB;\n        });\n\n        source = this.player.selectSource(response.mediaFiles).source;\n\n        if (source) {\n            if (this._adUnit) {\n                this._adUnit._src = source;\n            }\n            return callback(null, source, response);\n        }\n\n        // code 403 <== Couldn't find MediaFile that is supported by this video player\n        callback(new VASTError(\"Could not find Ad mediafile supported by this player\", 403), response);\n    };\n\n    VASTIntegrator.prototype._createVASTTracker = function createVASTTracker(adMediaFile, response, callback) {\n        try {\n            callback(null, adMediaFile, new VASTTracker(adMediaFile.src, response), response);\n        } catch (e) {\n            callback(e, response);\n        }\n    };\n\n    VASTIntegrator.prototype._setupEvents = function setupEvents(adMediaFile, tracker, response, callback) {\n        var previouslyMuted;\n        var player = this.player;\n        player.on('fullscreenchange', trackFullscreenChange);\n        player.on('vast.adStart', trackImpressions);\n        player.on('pause', trackPause);\n        player.on('timeupdate', trackProgress);\n        player.on('volumechange', trackVolumeChange);\n\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], unbindEvents);\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adSkip'], function (evt) {\n            if (evt.type === 'vast.adEnd') {\n                tracker.trackComplete();\n            }\n        });\n\n        return callback(null, adMediaFile, response);\n\n        /*** Local Functions ***/\n        function unbindEvents() {\n            player.off('fullscreenchange', trackFullscreenChange);\n            player.off('vast.adStart', trackImpressions);\n            player.off('pause', trackPause);\n            player.off('timeupdate', trackProgress);\n            player.off('volumechange', trackVolumeChange);\n        }\n\n        function trackFullscreenChange() {\n            if (player.isFullscreen()) {\n                tracker.trackFullscreen();\n            } else {\n                tracker.trackExitFullscreen();\n            }\n        }\n\n        function trackPause() {\n            //NOTE: whenever a video ends the video Element triggers a 'pause' event before the 'ended' event.\n            //      We should not track this pause event because it makes the VAST tracking confusing again we use a\n            //      Threshold of 2 seconds to prevent false positives on IOS.\n            if (Math.abs(player.duration() - player.currentTime()) < 2) {\n                return;\n            }\n\n            tracker.trackPause();\n            playerUtils.once(player, ['play', 'vast.adEnd', 'vast.adsCancel'], function (evt) {\n                if (evt.type === 'play') {\n                    tracker.trackResume();\n                }\n            });\n        }\n\n        function trackProgress() {\n            var currentTimeInMs = player.currentTime() * 1000;\n            tracker.trackProgress(currentTimeInMs);\n        }\n\n        function trackImpressions() {\n            tracker.trackImpressions();\n            tracker.trackCreativeView();\n        }\n\n        function trackVolumeChange() {\n            var muted = player.muted();\n            if (muted) {\n                tracker.trackMute();\n            } else if (previouslyMuted) {\n                tracker.trackUnmute();\n            }\n            previouslyMuted = muted;\n        }\n    };\n\n    VASTIntegrator.prototype._addSkipButton = function addSkipButton(source, tracker, response, callback) {\n        var skipOffsetInSec;\n\n        if (isNumber(response.skipoffset)) {\n            skipOffsetInSec = response.skipoffset / 1000;\n            addSkipButtonToPlayer(this.player, skipOffsetInSec);\n        }\n        callback(null, source, tracker, response);\n\n        /*** Local function ***/\n        function addSkipButtonToPlayer(player, skipOffset) {\n            var skipButton = createSkipButton(player);\n            var updateSkipButton = updateSkipButtonState.bind(this, skipButton, skipOffset, player);\n\n            player.el().appendChild(skipButton);\n            player.on('timeupdate', updateSkipButton);\n\n            playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeSkipButton);\n\n            function removeSkipButton() {\n                player.off('timeupdate', updateSkipButton);\n                dom.remove(skipButton);\n            }\n        }\n\n        function createSkipButton(player) {\n            var skipButton = window.document.createElement(\"div\");\n            dom.addClass(skipButton, \"vast-skip-button\");\n\n            skipButton.onclick = function (e) {\n                if (dom.hasClass(skipButton, 'enabled')) {\n                    tracker.trackSkip();\n                    player.trigger('vast.adSkip');\n                }\n\n                //We prevent event propagation to avoid problems with the clickThrough and so on\n                if (window.Event.prototype.stopPropagation !== undefined) {\n                    e.stopPropagation();\n                } else {\n                    return false;\n                }\n            };\n\n            return skipButton;\n        }\n\n        function updateSkipButtonState(skipButton, skipOffset, player) {\n            var timeLeft = Math.ceil(skipOffset - player.currentTime());\n            if (timeLeft > 0) {\n                skipButton.innerHTML = \"Skip in \" + toFixedDigits(timeLeft, 2) + \"...\";\n            } else {\n                if (!dom.hasClass(skipButton, 'enabled')) {\n                    dom.addClass(skipButton, 'enabled');\n                    skipButton.innerHTML = \"Skip ad\";\n                }\n            }\n        }\n    };\n\n    VASTIntegrator.prototype._addClickThrough = function addClickThrough(mediaFile, tracker, response, callback) {\n        var player = this.player;\n        var blocker = createClickThroughBlocker(player, tracker, response);\n        var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);\n\n        player.el().insertBefore(blocker, player.controlBar.el());\n        player.on('timeupdate', updateBlocker);\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);\n\n        return callback(null, mediaFile, tracker, response);\n\n        /*** Local Functions ***/\n\n        function createClickThroughBlocker(player, tracker, response) {\n            var blocker = window.document.createElement(\"a\");\n            var clickThroughMacro = response.clickThrough;\n\n            dom.addClass(blocker, 'vast-blocker');\n            blocker.href = generateClickThroughURL(clickThroughMacro, player);\n\n            if (isString(clickThroughMacro)) {\n                blocker.target = \"_blank\";\n            }\n\n            blocker.onclick = function (e) {\n                if (player.paused()) {\n                    player.play();\n\n                    //We prevent event propagation to avoid problems with the player's normal pause mechanism\n                    if (window.Event.prototype.stopPropagation !== undefined) {\n                        e.stopPropagation();\n                    }\n                    return false;\n                }\n\n                player.pause();\n                tracker.trackClick();\n            };\n\n            return blocker;\n        }\n\n        function updateBlockerURL(blocker, response, player) {\n            blocker.href = generateClickThroughURL(response.clickThrough, player);\n        }\n\n        function generateClickThroughURL(clickThroughMacro, player) {\n            var variables = {\n                ASSETURI: mediaFile.src,\n                CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)\n            };\n\n            return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';\n        }\n\n        function removeBlocker() {\n            player.off('timeupdate', updateBlocker);\n            dom.remove(blocker);\n        }\n    };\n\n    VASTIntegrator.prototype._playSelectedAd = function playSelectedAd(source, response, callback) {\n        var player = this.player;\n\n        player.preload(\"auto\"); //without preload=auto the durationchange event is never fired\n        player.src(source);\n\n        playerUtils.once(player, ['durationchange', 'error', 'vast.adsCancel'], function (evt) {\n            if (evt.type === 'durationchange') {\n                playAd();\n            } else if (evt.type === 'error') {\n                callback(new VASTError(\"on VASTIntegrator, Player is unable to play the Ad\", 400), response);\n            }\n            //NOTE: If the ads get canceled we do nothing/\n        });\n\n        /**** local functions ******/\n        function playAd() {\n            player.play();\n            playerUtils.once(player, ['playing', 'vast.adsCancel'], function (evt) {\n                if (evt.type === 'vast.adsCancel') {\n                    return;\n                }\n\n                player.trigger('vast.adStart');\n\n                playerUtils.once(player, ['ended', 'vast.adsCancel', 'vast.adSkip'], function (evt) {\n                    if (evt.type === 'ended' || evt.type === 'vast.adSkip') {\n                        callback(null, response);\n                    }\n                    //NOTE: if the ads get cancel we do nothing\n                });\n            });\n        }\n    };\n\n    VASTIntegrator.prototype._trackError = function trackError(error, response) {\n        vastUtil.track(response.errorURLMacros, {ERRORCODE: error.code || 900});\n    };\n\n    ;\n    (function (window) {\n        \"use strict\";\n\n\n        function VASTResponse() {\n            if (!(this instanceof VASTResponse)) {\n                return new VASTResponse();\n            }\n\n            this._linearAdded = false;\n            this.ads = [];\n            this.errorURLMacros = [];\n            this.impressions = [];\n            this.clickTrackings = [];\n            this.customClicks = [];\n            this.trackingEvents = {};\n            this.mediaFiles = [];\n            this.clickThrough = undefined;\n            this.adTitle = '';\n            this.duration = undefined;\n            this.skipoffset = undefined;\n        }\n\n        VASTResponse.prototype.addAd = function (ad) {\n            var inLine, wrapper;\n\n            if (ad instanceof Ad) {\n                inLine = ad.inLine;\n                wrapper = ad.wrapper;\n\n                this.ads.push(ad);\n\n                if (inLine) {\n                    this._addInLine(inLine);\n                }\n\n                if (wrapper) {\n                    this._addWrapper(wrapper);\n                }\n            }\n        };\n\n        VASTResponse.prototype._addErrorTrackUrl = function (error) {\n            var errorURL = error instanceof xml.JXONTree ? xml.keyValue(error) : error;\n            if (errorURL) {\n                this.errorURLMacros.push(errorURL);\n            }\n        };\n\n        VASTResponse.prototype._addImpressions = function (impressions) {\n            isArray(impressions) && appendToArray(this.impressions, impressions);\n        };\n\n        VASTResponse.prototype._addClickThrough = function (clickThrough) {\n            if (isNotEmptyString(clickThrough)) {\n                this.clickThrough = clickThrough;\n            }\n        };\n\n        VASTResponse.prototype._addClickTrackings = function (clickTrackings) {\n            isArray(clickTrackings) && appendToArray(this.clickTrackings, clickTrackings);\n        };\n\n        VASTResponse.prototype._addCustomClicks = function (customClicks) {\n            isArray(customClicks) && appendToArray(this.customClicks, customClicks);\n        };\n\n        VASTResponse.prototype._addTrackingEvents = function (trackingEvents) {\n            var eventsMap = this.trackingEvents;\n\n            if (trackingEvents) {\n                trackingEvents = isArray(trackingEvents) ? trackingEvents : [trackingEvents];\n                trackingEvents.forEach(function (trackingEvent) {\n                    if (!eventsMap[trackingEvent.name]) {\n                        eventsMap[trackingEvent.name] = [];\n                    }\n                    eventsMap[trackingEvent.name].push(trackingEvent);\n                });\n            }\n        };\n\n        VASTResponse.prototype._addTitle = function (title) {\n            if (isNotEmptyString(title)) {\n                this.adTitle = title;\n            }\n        };\n\n        VASTResponse.prototype._addDuration = function (duration) {\n            if (isNumber(duration)) {\n                this.duration = duration;\n            }\n        };\n\n        VASTResponse.prototype._addVideoClicks = function (videoClicks) {\n            if (videoClicks instanceof VideoClicks) {\n                this._addClickThrough(videoClicks.clickThrough);\n                this._addClickTrackings(videoClicks.clickTrackings);\n                this._addCustomClicks(videoClicks.customClicks);\n            }\n        };\n\n        VASTResponse.prototype._addMediaFiles = function (mediaFiles) {\n            isArray(mediaFiles) && appendToArray(this.mediaFiles, mediaFiles);\n        };\n\n        VASTResponse.prototype._addSkipoffset = function (offset) {\n            if (offset) {\n                this.skipoffset = offset;\n            }\n        };\n\n        VASTResponse.prototype._addAdParameters = function (adParameters) {\n            if (adParameters) {\n                this.adParameters = adParameters;\n            }\n        };\n\n        VASTResponse.prototype._addLinear = function (linear) {\n            if (linear instanceof Linear) {\n                this._addDuration(linear.duration);\n                this._addTrackingEvents(linear.trackingEvents);\n                this._addVideoClicks(linear.videoClicks);\n                this._addMediaFiles(linear.mediaFiles);\n                this._addSkipoffset(linear.skipoffset);\n                this._addAdParameters(linear.adParameters);\n                this._linearAdded = true;\n            }\n        };\n\n        VASTResponse.prototype._addInLine = function (inLine) {\n            var that = this;\n\n            if (inLine instanceof InLine) {\n                this._addTitle(inLine.adTitle);\n                this._addErrorTrackUrl(inLine.error);\n                this._addImpressions(inLine.impressions);\n\n                inLine.creatives.forEach(function (creative) {\n                    if (creative.linear) {\n                        that._addLinear(creative.linear);\n                    }\n                });\n            }\n        };\n\n        VASTResponse.prototype._addWrapper = function (wrapper) {\n            var that = this;\n\n            if (wrapper instanceof Wrapper) {\n                this._addErrorTrackUrl(wrapper.error);\n                this._addImpressions(wrapper.impressions);\n\n                wrapper.creatives.forEach(function (creative) {\n                    var linear = creative.linear;\n                    if (linear) {\n                        that._addVideoClicks(linear.videoClicks);\n                        that.clickThrough = undefined;//We ensure that no clickThrough has been added\n                        that._addTrackingEvents(linear.trackingEvents);\n                    }\n                });\n            }\n        };\n\n        VASTResponse.prototype.hasLinear = function () {\n            return this._linearAdded;\n        };\n\n        function appendToArray(array, items) {\n            items.forEach(function (item) {\n                array.push(item);\n            });\n        }\n\n        window.VASTResponse = VASTResponse;\n    })(window);\n\n    ;\n    function VASTTracker(assetURI, vastResponse) {\n        if (!(this instanceof VASTTracker)) {\n            return new VASTTracker(assetURI, vastResponse);\n        }\n\n        sanityCheck(assetURI, vastResponse);\n        this.response = vastResponse;\n        this.assetURI = assetURI;\n        this.progress = 0;\n        this.quartiles = {\n            firstQuartile: {tracked: false, time: Math.round(25 * vastResponse.duration) / 100},\n            midpoint: {tracked: false, time: Math.round(50 * vastResponse.duration) / 100},\n            thirdQuartile: {tracked: false, time: Math.round(75 * vastResponse.duration) / 100}\n        };\n\n        /*** Local Functions ***/\n        function sanityCheck(assetURI, vastResponse) {\n            if (!isString(assetURI) || isEmptyString(assetURI)) {\n                throw new VASTError('on VASTTracker constructor, missing required the URI of the ad asset being played');\n            }\n\n            if (!(vastResponse instanceof VASTResponse)) {\n                throw new VASTError('on VASTTracker constructor, missing required VAST response');\n            }\n        }\n    }\n\n    VASTTracker.prototype.trackURLs = function trackURLs(urls, variables) {\n        if (isArray(urls) && urls.length > 0) {\n            variables = extend({\n                ASSETURI: this.assetURI,\n                CONTENTPLAYHEAD: vastUtil.formatProgress(this.progress)\n            }, variables || {});\n\n            vastUtil.track(urls, variables);\n        }\n    };\n\n    VASTTracker.prototype.trackEvent = function trackEvent(eventName, trackOnce) {\n        this.trackURLs(getEventUris(this.response.trackingEvents[eventName]));\n        if (trackOnce) {\n            this.response.trackingEvents[eventName] = undefined;\n        }\n\n        /*** Local function ***/\n        function getEventUris(trackingEvents) {\n            var uris;\n\n            if (trackingEvents) {\n                uris = [];\n                trackingEvents.forEach(function (event) {\n                    uris.push(event.uri);\n                });\n            }\n            return uris;\n        }\n    };\n\n    VASTTracker.prototype.trackProgress = function trackProgress(newProgressInMs) {\n        var events = [];\n        var ONCE = true;\n        var ALWAYS = false;\n        var trackingEvents = this.response.trackingEvents;\n\n        if (isNumber(newProgressInMs)) {\n            addTrackEvent('start', ONCE, newProgressInMs > 0);\n            addTrackEvent('rewind', ALWAYS, hasRewound(this.progress, newProgressInMs));\n            addQuartileEvents.call(this, newProgressInMs);\n            trackProgressEvents.call(this, newProgressInMs);\n            trackEvents.call(this);\n            this.progress = newProgressInMs;\n        }\n\n        /*** Local function ***/\n        function hasRewound(currentProgress, newProgress) {\n            var REWIND_THRESHOLD = 3000; //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that there was a rewind an that it was on purpose.\n            return currentProgress > newProgressInMs && Math.abs(newProgress - currentProgress) > REWIND_THRESHOLD;\n        }\n\n        function addTrackEvent(eventName, trackOnce, canBeAdded) {\n            if (trackingEvents[eventName] && canBeAdded) {\n                events.push({\n                    name: eventName,\n                    trackOnce: !!trackOnce\n                });\n            }\n        }\n\n        function addQuartileEvents(progress) {\n            var quartiles = this.quartiles;\n            var firstQuartile = this.quartiles.firstQuartile;\n            var midpoint = this.quartiles.midpoint;\n            var thirdQuartile = this.quartiles.thirdQuartile;\n\n            if (!firstQuartile.tracked) {\n                trackQuartile('firstQuartile', progress);\n            } else if (!midpoint.tracked) {\n                trackQuartile('midpoint', progress);\n            } else {\n                trackQuartile('thirdQuartile', progress);\n            }\n\n            /*** Local function ***/\n            function trackQuartile(quartileName, progress) {\n                var quartile = quartiles[quartileName];\n                if (canBeTracked(quartile, progress)) {\n                    quartile.tracked = true;\n                    addTrackEvent(quartileName, ONCE, true);\n                }\n            }\n        }\n\n        function canBeTracked(quartile, progress) {\n            var quartileTime = quartile.time;\n            //We only fire the quartile event if the progress is bigger than the quartile time by 5 seconds at most.\n            return progress >= quartileTime && progress <= (quartileTime + 5000);\n        }\n\n        function trackProgressEvents(progress) {\n            if (!isArray(trackingEvents.progress)) {\n                return; //Nothing to track\n            }\n\n            var pendingProgressEvts = [];\n            var that = this;\n\n            trackingEvents.progress.forEach(function (evt) {\n                if (evt.offset <= progress) {\n                    that.trackURLs([evt.uri]);\n                } else {\n                    pendingProgressEvts.push(evt);\n                }\n            });\n            trackingEvents.progress = pendingProgressEvts;\n        }\n\n        function trackEvents() {\n            events.forEach(function (event) {\n                this.trackEvent(event.name, event.trackOnce);\n            }, this);\n        }\n    };\n\n    [\n        'rewind',\n        'fullscreen',\n        'exitFullscreen',\n        'pause',\n        'resume',\n        'mute',\n        'unmute',\n        'acceptInvitation',\n        'acceptInvitationLinear',\n        'collapse',\n        'expand'\n    ].forEach(function (eventName) {\n            VASTTracker.prototype['track' + capitalize(eventName)] = function () {\n                this.trackEvent(eventName);\n            };\n        });\n\n    [\n        'start',\n        'skip',\n        'close',\n        'closeLinear'\n    ].forEach(function (eventName) {\n            VASTTracker.prototype['track' + capitalize(eventName)] = function () {\n                this.trackEvent(eventName, true);\n            };\n        });\n\n    [\n        'firstQuartile',\n        'midpoint',\n        'thirdQuartile'\n    ].forEach(function (quartile) {\n            VASTTracker.prototype['track' + capitalize(quartile)] = function () {\n                this.quartiles[quartile].tracked = true;\n                this.trackEvent(quartile, true);\n            };\n        });\n\n    VASTTracker.prototype.trackComplete = function () {\n        if (this.quartiles.thirdQuartile.tracked) {\n            this.trackEvent('complete', true);\n        }\n    };\n\n    VASTTracker.prototype.trackErrorWithCode = function trackErrorWithCode(errorcode) {\n        if (isNumber(errorcode)) {\n            this.trackURLs(this.response.errorURLMacros, {ERRORCODE: errorcode});\n        }\n    };\n\n    VASTTracker.prototype.trackImpressions = function trackImpressions() {\n        this.trackURLs(this.response.impressions);\n    };\n\n    VASTTracker.prototype.trackCreativeView = function trackCreativeView() {\n        this.trackEvent('creativeView');\n    };\n\n    VASTTracker.prototype.trackClick = function trackClick() {\n        this.trackURLs(this.response.clickTrackings);\n    };\n\n    ;\n    function VideoClicks(videoClickJTree) {\n        if (!(this instanceof VideoClicks)) {\n            return new VideoClicks(videoClickJTree);\n        }\n\n        this.clickThrough = xml.keyValue(videoClickJTree.clickThrough);\n        this.clickTrackings = parseClickTrackings(videoClickJTree.clickTracking);\n        this.customClicks = parseClickTrackings(videoClickJTree.customClick);\n\n        /*** Local functions ***/\n        function parseClickTrackings(trackingData) {\n            var clickTrackings = [];\n            if (trackingData) {\n                trackingData = isArray(trackingData) ? trackingData : [trackingData];\n                trackingData.forEach(function (clickTrackingData) {\n                    clickTrackings.push(xml.keyValue(clickTrackingData));\n                });\n            }\n            return clickTrackings;\n        }\n    }\n    ;\n    function Wrapper(wrapperJTree) {\n        if (!(this instanceof Wrapper)) {\n            return new Wrapper(wrapperJTree);\n        }\n\n        //Required elements\n        this.adSystem = xml.keyValue(wrapperJTree.adSystem);\n        this.impressions = vastUtil.parseImpressions(wrapperJTree.impression);\n        this.VASTAdTagURI = xml.keyValue(wrapperJTree.vASTAdTagURI);\n\n        //Optional elements\n        this.creatives = vastUtil.parseCreatives(wrapperJTree.creatives);\n        this.error = xml.keyValue(wrapperJTree.error);\n        this.extensions = wrapperJTree.extensions;\n\n        //Optional attrs\n        this.followAdditionalWrappers = isDefined(xml.attr(wrapperJTree, 'followAdditionalWrappers')) ? xml.attr(wrapperJTree, 'followAdditionalWrappers') : true;\n        this.allowMultipleAds = xml.attr(wrapperJTree, 'allowMultipleAds');\n        this.fallbackOnNoAd = xml.attr(wrapperJTree, 'fallbackOnNoAd');\n    }\n\n\n    ;\n    \"use strict\";\n\n    var vastUtil = {\n\n        track: function track(URLMacros, variables) {\n            var sources = vastUtil.parseURLMacros(URLMacros, variables);\n            var trackImgs = [];\n            sources.forEach(function (src) {\n                var img = new Image();\n                img.src = src;\n                trackImgs.push(img);\n            });\n            return trackImgs;\n        },\n\n        parseURLMacros: function parseMacros(URLMacros, variables) {\n            var parsedURLs = [];\n\n            variables = variables || {};\n\n            if (!(variables[\"CACHEBUSTING\"])) {\n                variables[\"CACHEBUSTING\"] = Math.round(Math.random() * 1.0e+10);\n            }\n\n            URLMacros.forEach(function (URLMacro) {\n                parsedURLs.push(vastUtil._parseURLMacro(URLMacro, variables));\n            });\n\n            return parsedURLs;\n        },\n\n        parseURLMacro: function parseMacro(URLMacro, variables) {\n            variables = variables || {};\n\n            if (!(variables[\"CACHEBUSTING\"])) {\n                variables[\"CACHEBUSTING\"] = Math.round(Math.random() * 1.0e+10);\n            }\n\n            return vastUtil._parseURLMacro(URLMacro, variables);\n        },\n\n        _parseURLMacro: function parseMacro(URLMacro, variables) {\n            variables = variables || {};\n\n            forEach(variables, function (value, key) {\n                URLMacro = URLMacro.replace(new RegExp(\"\\\\[\" + key + \"\\\\\\]\", 'gm'), value);\n            });\n\n            return URLMacro;\n        },\n\n        parseDuration: function parseDuration(durationStr) {\n            var durationRegex = /(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d\\d\\d))?/;\n            var match, durationInMs;\n\n            if (isString(durationStr)) {\n                match = durationStr.match(durationRegex);\n                if (match) {\n                    durationInMs = parseHoursToMs(match[1]) + parseMinToMs(match[2]) + parseSecToMs(match[3]) + parseInt(match[5] || 0);\n                }\n            }\n\n            return isNaN(durationInMs) ? null : durationInMs;\n\n            /*** local functions ***/\n            function parseHoursToMs(hourStr) {\n                return parseInt(hourStr, 10) * 60 * 60 * 1000;\n            }\n\n            function parseMinToMs(minStr) {\n                return parseInt(minStr, 10) * 60 * 1000;\n            }\n\n            function parseSecToMs(secStr) {\n                return parseInt(secStr, 10) * 1000;\n            }\n        },\n\n        parseImpressions: function parseImpressions(impressions) {\n            if (impressions) {\n                impressions = isArray(impressions) ? impressions : [impressions];\n                return transformArray(impressions, function (impression) {\n                    if (isNotEmptyString(impression.keyValue)) {\n                        return impression.keyValue;\n                    }\n                    return undefined;\n                });\n            }\n            return [];\n        },\n\n        parseCreatives: function parseCreatives(creativesJTree) {\n            var creatives = [];\n            var creativesData;\n            if (isDefined(creativesJTree) && isDefined(creativesJTree.creative)) {\n                creativesData = isArray(creativesJTree.creative) ? creativesJTree.creative : [creativesJTree.creative];\n                creativesData.forEach(function (creative) {\n                    creatives.push(new Creative(creative));\n                });\n            }\n            return creatives;\n        },\n\n        //We assume that the progress is going to arrive in milliseconds\n        formatProgress: function formatProgress(progress) {\n            var hours, minutes, seconds, milliseconds;\n            hours = progress / (60 * 60 * 1000);\n            hours = Math.floor(hours);\n            minutes = (progress / (60 * 1000)) % 60;\n            minutes = Math.floor(minutes);\n            seconds = (progress / 1000) % 60;\n            seconds = Math.floor(seconds);\n            milliseconds = progress % 1000;\n            return toFixedDigits(hours, 2) + ':' + toFixedDigits(minutes, 2) + ':' + toFixedDigits(seconds, 2) + '.' + toFixedDigits(milliseconds, 3);\n        },\n\n        parseOffset: function parseOffset(offset, duration) {\n            if (isPercentage(offset)) {\n                return calculatePercentage(offset, duration);\n            }\n            return vastUtil.parseDuration(offset);\n\n            /*** Local function ***/\n            function isPercentage(offset) {\n                var percentageRegex = /^\\d+(\\.\\d+)?%$/g;\n                return percentageRegex.test(offset);\n            }\n\n            function calculatePercentage(percentStr, duration) {\n                if (duration) {\n                    return calcPercent(duration, parseFloat(percentStr.replace('%', '')));\n                }\n                return null;\n            }\n\n            function calcPercent(quantity, percent) {\n                return quantity * percent / 100;\n            }\n        },\n\n        isVPAID: function isVPAIDMediaFile(mediaFile) {\n            return !!mediaFile && mediaFile.apiFramework === 'VPAID';\n        }\n    };})(window, document, videojs);\n//# sourceMappingURL=videojs-vast-vpaid.js.map\n\n/* jshint ignore:end */\n"

        /***/ },
    /* 22 */
    /***/ function(module, exports) {

        /**
         * ExtendDefaultOption for playerManager
         * This logic will exnted options to have default value
         *
         * @param defaultOptions
         * @param options_
         * @returns {*}
         * @constructor
         */
        var ExtendDefaultOption = function (defaultOptions, options_) {

            function isObject(obj) {
                return typeof obj === 'object';
            }

            function isNull(o) {
                return o === null;
            }

            function extend(obj) {
                var arg, i, k;
                for (i = 1; i < arguments.length; i++) {
                    arg = arguments[i];
                    for (k in arg) {
                        if (arg.hasOwnProperty(k)) {
                            if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {
                                obj[k] = extend({}, obj[k], arg[k]);
                            } else {
                                obj[k] = arg[k];
                            }
                        }
                    }
                }
                return obj;
            }

            //extend by default options
            var options = extend({}, defaultOptions, options_ || {});

            //manual touch
            if (options.playerTechnology === undefined || options.playerTechnology.length === 0) {
                options.playerTechnology = ["html5", "flash"];
            }

            if (!options.width || typeof options.width === "undefined" || options.width === "" || options.width === 0) {
                options.autoInitialSize = true;
            }

            //handle disableCollapse if it's number or true or false
            if (typeof(options.disableCollapse) === "number") {
                if (options.disableCollapse >= 0) {
                    options.disableCollapseForDelay = options.disableCollapse;
                }
                options.disableCollapse = false;
            }


            //this options should be false anytime.
            options.enableExplicitPause = true;

            return options;//TODO is Object.create required for this?

        };

        module.exports = ExtendDefaultOption;



        /***/ },
    /* 23 */
    /***/ function(module, exports, __webpack_require__) {

        var APN_OUTSTREAM_VIDEO_PLACEMENT_ID = "apn_outstream_video_placements";
        var APN_OUTSTREAM_IFRAME_NAME = "iframeVideoWrapper";
        //var BLANK_VIDEO_URL = "http://acdn.adnxs.com/video/static/res/b1.mp4";
        var BLANK_VIDEO_URL = "http://acdn.adnxs.com/video/static/res/b2.mp4";//2 seconds 70x70 empty video to resolve VID-1924,VID-1907,VID-1980


        var prefixOfLog = "[PlayerManager_MobileSupport]";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(prefixOfLog, message);
        };
        var error = function (message) {
            APN_Logger.error(prefixOfLog, message);
        };
        var warn = function (message) {
            APN_Logger.warn(prefixOfLog, message);
        };
        // var info = function (message) {
        //     APN_Logger.info(prefixOfLog, message);
        // };

        /**
         * get iOSversion as array [major,minor,build] if it's not proper mobile safari it will returen [0,0,0]
         * @returns {*}
         */
        var iOSversion = function () {
            var browser = "safari";
            try {
                var platform = navigator.platform;
                var agent = navigator.userAgent;
                var appVersion = navigator.appVersion;


                if (/CriOS/.test(agent)) {
                    //do nothing, we decided to allow to use inline for iOS Chrome by VID-1464
                    browser = "chrome";
                }
                if (/iP(hone|od|ad)/.test(platform)) {
                    var v = (appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);//chrome and safari both has iOS version in the user agent string (especially in appVersion)
                    return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10), browser];
                } else {
                    return [0, 0, 0, browser];//return this value when it's not iOS and Mobile Safari browser
                }
            } catch (ex) {
                error(ex);
                return [0, 0, 0, browser];//return [0,0,0] if any error happens;
            }
        };

        var isIOS = function() {
            return (/iphone/i.test(navigator.userAgent.toLowerCase())) ||  (/ipad/i.test(navigator.userAgent.toLowerCase()));
        };


        var getiOSChromeVersion = function() {
            var version = -1;
            if (isIOS()) {
                try {
                    var tmp = navigator.userAgent.match(/CriOS\/([0-9]+)\./);
                    if (tmp && Array.isArray(tmp) && tmp.length > 1) {
                        version = Number.parseInt(tmp[1]);
                    }
                } catch (ex) {
                    debug(ex);
                }
            }
            return version;
        };

        /**
         * detection logic if ad unit requires human activity to initiate adunit itself.
         * @returns {boolean}
         */
        var doesBrowserNeedUserActionToPlayVideo = function() {//for https://jira.corp.appnexus.com/browse/VID-2557
            var result = iOSversion();
            if (result && Array.isArray(result) && result.length >= 4) {
                var majoriOSVersion = result[0];
                var kindOfBrowser = result[3];
                if (kindOfBrowser === "chrome" && majoriOSVersion === 10 && getiOSChromeVersion() === 53) {
                    return true;
                } else {
                    return false;
                }
            }
        };

        /**
         * This method will create empty video placement and play it to resolve initial playback by human activity
         * It's required for breaking iOS and Android limitation which is not playing video automatically
         * @param targetWindow
         */
        var prepareVideoPlacementsForMobile = function (iframes, type, callback, outstreamSelf) {

            var totalStepsForWaterfall = iframes.length;
            var totalCountsOfResolvedHumanActivity = 0;

            var doFinalSteps = function (_type) {
                if (totalCountsOfResolvedHumanActivity === totalStepsForWaterfall) {//if this step is last and all steps resolved human activity
                    //proceed Outstream AdUnit to start expanding
                    if (typeof(callback) === "function") {
                        outstreamSelf.hasDoneFakingAutoStartForAndroid = true;
                        warn("set hasDoneFakingAutoStartForAndroid = true by " + _type);
                        callback();
                    }
                }
            };

            var storeResolvedVideo = function (videoPlacement, _type, targetWindow) {
                if (outstreamSelf.hasDoneFakingAutoStartForAndroid) {
                    return;
                }
                warn("successfully performed autoplay trick by " + _type);
                targetWindow[APN_OUTSTREAM_VIDEO_PLACEMENT_ID] = videoPlacement;
                totalCountsOfResolvedHumanActivity++;
                doFinalSteps(_type);
            };

            var removeFailedIFrames = function (_iframe, index, _type) {
                warn("removing failed iframe #" + (index + 1) + " by " + _type);
                document.getElementById(outstreamSelf.targetElementId).removeChild(_iframe);
            };

            var createEmptyVideoPlacementAndTest = function (_iframe, _index, _type) {
                try {
                    var targetWindow = _iframe.contentWindow;
                    if (!targetWindow[APN_OUTSTREAM_VIDEO_PLACEMENT_ID]) {
                        var videoPlacement;
                        var playPromise;
                        videoPlacement = targetWindow.document.createElement("video");
                        targetWindow.document.body.appendChild(videoPlacement);
                        videoPlacement.src = BLANK_VIDEO_URL;

                        if (_type === "fallback") {
                            videoPlacement.setAttribute("autoplay","");
                            videoPlacement.setAttribute("mute","");
                            storeResolvedVideo(videoPlacement, _type, targetWindow);
                            return;
                        }

                        playPromise = videoPlacement.play();
                        videoPlacement.pause();// VID-1726 Chrome issue for Android playback, When load is interrupting in play state Android Chrome sometimes is not showing video
                        //Android Modern Chrome (+50) returns promise object by invoking play() method to handle asyncnorouse action - https://developers.google.com/web/updates/2016/03/play-returns-promise
                        if (playPromise !== undefined) {
                            playPromise.then(function () {
                                debug("video promise done successfully by " + _type);
                                totalCountsOfResolvedHumanActivity++;
                                doFinalSteps("promise done");
                            }).catch(function (error) {
                                var returnedError = {
                                    "code": error.code,
                                    "name": error.name,
                                    "message": error.message
                                };
                                //TODO unit test to reproduce when touch-start doesn't work
                                // if (_type === "touchstart") {
                                //     returnedError.code = 0;
                                //     returnedError.name = "testing";
                                //     returnedError.message = "testing";
                                // }

                                //TODO unit test to reproduce when touch-start doesn't work
                                // if (_type === "touchend") {
                                //     returnedError.code = 0;
                                //     returnedError.name = "testing";
                                //     returnedError.message = "testing";
                                // }

                                //TODO unit test to reproduce when all event doesn't work (For fallback play)
                                // returnedError.code = 0;
                                // returnedError.name = "testing";
                                // returnedError.message = "testing";

                                if (returnedError.code === 0) {//handle not acceptable error case we have to do fallback, at the time, code : 0, name : Not Allowed, message : Failed to execute 'play' on 'HTMLMediaElement': API can only be initiated by a user gesture.
                                    warn("playback failed : " + returnedError.code + "," + returnedError.name + "," + returnedError.message + " by " + _type);
                                    removeFailedIFrames(_iframe, _index, _type);//remove iframes of touchstart to give "touchend" opportunity which is next order of this execution
                                } else {
                                    //handle accetable error like abort playing
                                    warn("waterfall steps #" + (Number(totalCountsOfResolvedHumanActivity) + 1) + " by " + _type + " : autoplay trick's possible due to video promise be caught with " + error.name);
                                    storeResolvedVideo(videoPlacement, _type, targetWindow);
                                }
                            });
                        }
                    }
                } catch (ex) {
                    debug(ex);
                }

            };

            //start point
            iframes.forEach(function (_iframe, _index) {
                createEmptyVideoPlacementAndTest(_iframe, _index, type);
            });

        };

        var isMobile = function () {
            var index = navigator.appVersion.indexOf("Mobile");
            var indexForAndroid = navigator.appVersion.indexOf("Android");
            return (index > -1) || (indexForAndroid > -1);
        };

        var isAndroid = function () {
            return (/android/i.test(navigator.userAgent.toLowerCase()));
        };


        var getChromeVersion = function() {
            var version = -1;
            if (isAndroid()) {
                try {
                    var tmp = navigator.userAgent.match(/Chrome\/([0-9]+)\./);
                    if (tmp && Array.isArray(tmp) && tmp.length > 1) {
                        version = Number.parseInt(tmp[1]);
                    }
                } catch (ex) {
                    debug(ex);
                }
            }
            return version;
        };




        var isRequiredFakeAndroidAutoStart = function (options) {
            // If "automatedTestingOnlyAndroidSkipTouchStart" flag in options is true don't require a touch to start on android,
            // used to allow automated tests to run without requiring a human touch.

            var isAutoPlay = options && options.initialPlayback && (options.initialPlayback === "auto");
            var isAudioOn = options && options.initialAudio && (options.initialAudio === "on");

            if (getChromeVersion() >= 53) {//Since Chrome53 Google allows autoplay with no-sound refers with https://corpwiki.appnexus.com/display/~ksong/Summarize+HTML5+Video+limitations+on+Mobile+devices
                if (isAndroid() && isAudioOn && isAutoPlay && !options.automatedTestingOnlyAndroidSkipTouchStart) {
                    return true;//require user action
                } else {
                    return false;
                }
            } else {
                //for old version of Chrome
                if (isAndroid() && isAutoPlay && !options.automatedTestingOnlyAndroidSkipTouchStart) {
                    return true;//require user action
                } else {
                    return false;
                }
            }



        };


        var isIosInlineRequired = function (options) {
            var result;
            try {
                result = (iOSversion()[0] >= 8 && options.enableInlineVideoForIos === true);//from iOS8, browser and webview supports a canvas trick to move currentTime of video even if it's not loaded by human's activirty
            } catch (ex) {
                error(ex);
            }
            return result;
        };


        module.exports = {
            APN_OUTSTREAM_VIDEO_PLACEMENT_ID: APN_OUTSTREAM_VIDEO_PLACEMENT_ID,
            APN_OUTSTREAM_IFRAME_NAME: APN_OUTSTREAM_IFRAME_NAME,
            prepareVideoPlacementsForMobile: prepareVideoPlacementsForMobile,
            isMobile: isMobile,
            isRequiredFakeAndroidAutoStart: isRequiredFakeAndroidAutoStart,
            isIosInlineRequired: isIosInlineRequired,
            doesBrowserNeedUserActionToPlayVideo: doesBrowserNeedUserActionToPlayVideo,
            iOSversion: iOSversion,
            getiOSChromeVersion: getiOSChromeVersion,
            isIOS: isIOS
        };


        /***/ },
    /* 24 */
    /***/ function(module, exports, __webpack_require__) {

        var plainCssText = __webpack_require__(25);

        var _logger = __webpack_require__(2);
        var debug = function (message) {
            _logger.debug("Custom Skinning: " + message);
        };

        var render = function(playerSelf, IframeDocument, isInline) {


            debug("Applying custom styles/skins");

            //css for iOS to hide custom control
            var cssForIosInlineVideo = "";
            if (isInline) {
                cssForIosInlineVideo = ".vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {display: block !important;visibility: visible !important;opacity: 1 !important} .vjs-loading-spinner { position: absolute; top: 50%; left: 50%; font-size: 4em; line-height: 1; width: 1em; height: 1em; margin-left: -0.5em; margin-top: -0.5em; opacity: 0.75; display: block; -webkit-animation: spin 1.5s infinite linear; -moz-animation: spin 1.5s infinite linear; -o-animation: spin 1.5s infinite linear; animation: spin 1.5s infinite linear; }\n";
            }//to show controlbar permenantly and activate spinner
            var cssForIos = "video::-webkit-media-controls-start-playback-button {display: none !important;-webkit-appearance: none;}\n";

            var skinCss = "\n";
            if (playerSelf.options.playerSkin) {
                var playerSkin = playerSelf.options.playerSkin;

                if (playerSkin.customPlayerSkin) {
                    plainCssText = decodeURIComponent(playerSkin.customPlayerSkin);
                } else {
                    if (playerSkin.topBarColor) {
                        skinCss += "#top_chrome { background: " + playerSkin.topBarColor + "; }\n";
                    }
                    if (playerSkin.dividerColor) {
                        skinCss += "#top_chrome { border-bottom-color: " + playerSkin.dividerColor + "; }\n";
                    } else {
                        skinCss += "#top_chrome { border-bottom-color: " + playerSelf.options.bottomDividerColor + "; }\n";
                    }
                    if (typeof playerSkin.dividerHeight === "number") {
                        skinCss += "#top_chrome { border-bottom-width: " + playerSkin.dividerHeight + "; border-bottom-style: solid; }\n";
                    } else {
                        skinCss += "#top_chrome { border-bottom-width: " + playerSelf.options.bottomDividerWidth + "; border-bottom-style: solid; }\n";
                    }
                    if (playerSkin.topBarTextColor) {
                        skinCss += ".top-bar-text { color: " + playerSkin.topBarTextColor + "; }\n";
                    }
                    if (playerSkin.controlBarColor) {
                        skinCss += ".vjs-default-skin .vjs-control-bar { background-color: " + playerSkin.controlBarColor + "; }\n";
                    }
                    if (playerSkin.controlBarControlsColor) {
                        skinCss += ".vjs-default-skin .vjs-control-bar { color: " + playerSkin.controlBarControlsColor + "; }\n";
                        skinCss += ".vjs-default-skin:hover .vjs-control-bar { color: " + playerSkin.controlBarControlsColor + "; }\n";
                    }
                    if (playerSkin.bigPlayButtonColor) {
                        skinCss += ".vjs-default-skin .vjs-big-play-button { color: " + playerSkin.bigPlayButtonColor + "; border-color: " + playerSkin.bigPlayButtonColor + "; }\n";
                        skinCss += ".vjs-default-skin:hover .vjs-big-play-button { color: " + playerSkin.bigPlayButtonColor + "; border-color: " + playerSkin.bigPlayButtonColor + "; }\n";
                    }
                }
            } else {
                skinCss += "#top_chrome { border-bottom-color: " + playerSelf.options.bottomDividerColor + "; border-bottom-width: " + playerSelf.options.bottomDividerWidth + "; border-bottom-style: solid; }\n";
            }

            if ((playerSelf.isAndroid && playerSelf.isAndroid()) || playerSelf.options.controlBarPosition === "below") {
                skinCss += ".vjs-default-skin .vjs-control-bar { display: block !important;visibility: visible !important;opacity: 1 !important ;bottom: -3.0em }\n";
            }

            //generate dynamic css
            debug("Generating css element");
            var cssStyle = document.createElement("style");
            cssStyle.type = "text/css";
            cssStyle.innerHTML = plainCssText + cssForIos + skinCss + cssForIosInlineVideo;

            IframeDocument.head.appendChild(cssStyle);

        };

        module.exports = {
            "render": render
        };


        /***/ },
    /* 25 */
    /***/ function(module, exports) {

        module.exports = "/* SKIN\n================================================================================\nThe main class name for all skin-specific styles. To make your own skin,\nreplace all occurrences of 'vjs-default-skin' with a new name. Then add your new\nskin name to your video tag instead of the default skin.\ne.g. <video class=\"video-js my-skin-name\">\n*/\n.vjs-default-skin {\n  color: #CCCCCC;\n}\n/* Custom Icon Font\n--------------------------------------------------------------------------------\nThe control icons are from a custom font. Each icon corresponds to a character\n(e.g. \"\\e001\"). Font icons allow for easy scaling and coloring of icons.\n*/\n@font-face {\n  font-family: 'VideoJS';\n  src: url('font/vjs.eot');\n  src: url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAnMAAsAAAAADWgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAABCAAABokAAAgsXGkfVUZGVE0AAAeUAAAAHAAAABxxb8IrR0RFRgAAB7AAAAAiAAAAJgAnADxPUy8yAAAH1AAAAEMAAABgVDdTq2NtYXAAAAgYAAAAVgAAAWr6rrHraGVhZAAACHAAAAAsAAAANgaEyq9oaGVhAAAInAAAABwAAAAkCSAFLWhtdHgAAAi4AAAAJwAAAEgr1gKfbWF4cAAACOAAAAAGAAAABgAWUABuYW1lAAAI6AAAANUAAAGk8SNjJXBvc3QAAAnAAAAADAAAACAAAwAAeJxlVX9MW9cVvhf88K0Bt2txSTfLxNsSqkZaITjdgrZ2KaZiWYaI47lkCYTgphB+mFB+xFgZJDamqa+TAH4EkoDVNKRA3eF2UEqaJqHENKiVUAJI2zrSLkWZNO2P/dPqPnyg2r2A00zTue87737nfee943vuNUYqFcIYk8P2muqaGgfCcQijXCUDKZlY2RqnZMUrG1Q0KZ4mqQwa9Eij7VlKH9wkqWmuXiqOWiU9TnhUj9Bjepz5Az1K0qv3Po6eEqnikYQISkaPo1SkR0a0GW1BGWgbykYvIDP6DcpHe1AhKkKl6BC3KlTXkNGQ2bA1oyE3I2MVMgVsFZAlwCRgm4DnBPxcwC8EbBewQ8CLAnIEmAXkcshchZcacp/jCX+WsV5srGaE8Ov4JH4D+zDFfnwKn8ZncDvuwJ04gGXchc/ibtyDz+Hz+AJ6MlaVGmnQU+hptINXUYiq0S30Bb6Jb8d1xL0Z96/4syqN6j+SVVKoVpgia6Ny1KrbqAHTikln1GiZdWlet5SynLLCL0nLUviUza/IMJ+gWJfk2L1W2RSVdD/WaJUrrEb3Ew08vfSMmC69wlJ0P9XAC/98iIzOR7Xv61poc7tbdgbpUDC4uHiVEcoe42MfI1mLa2wwOESDTvKtcQo2UniGj92w0Wh0u5vbWiiB5+//X2ZFfDzML8ts9VJkSbu68CqO353XR99K0KvuKhd0PpbX+kXJZGv3sc4W+eAQ7D0LTRScFOzHS6tb3Mda3S2lVu8vT0IeOQ15Hb8a3SM3n/d2e0Yrmf0Ec77Bmk6xvV0fhLoD5zs6e8Zudv7Nz/LI8t8/0h1nxl9/CT/kn/foFoiHXHhpEeLZpjRe3sI/upmRgCGh7eUG+35KXmye++u3Q59cTxungxVnLESJPtnCjDu+hB9xtXZd/fX36p41tZeri/5HPVDRbiFrS7Mkr3DjyyEm5ohldjYSmZ21RMxmi8VsYP2gWmXvTEVm7+yeyjVbducamBn6deWDjuHhwcHhYcdgebnDUW4AlWAHHGHBhh0D5WU1NWUGEBmoOva0gVL194p+FouFB9Zi4ZqBsnIH11UqozxkGyuZmBgbmxChiZIxm62kxGbI4u+xhypHRkKhkZHKkN1eWWk3aBWrksLbMFqv1Is25AubomNh1gT54OImfDjtCD1yqvY0xHFLPQpPnCRvq2//6dNpeod2+WRfF5C/7BBtlUqYizWxfBY2rHdImCdo4igSNvG03LNVz2ecTwNZxYxMDWowcnvgmZqznBc+jU0tT+mytwMuBjUVA49n392+UMwwZWo+xhm+u0Bm8iiVIBVSKVQw7j7f9VX5fXqffjX8+WcslaVSVgHckZkZ6W72OODVTOpiwNuziXbpGybrimmp01FNlnNYleQP+ANUprIv4AsQRTCD1aPOcUoW5+YWF3PmsrJycrLSqNvv8Xu4Aqokx1BpsJgSwWfN5SzybhkNDg5xLY/5PD4PdRPBx/QGvv8Vq843c2zmyK3a6Vdu7hvff8USzr+Uf2nn2Z2+nb7f/rGgtqD294cOFJEDReXW+oL6guO7/NzO/a7f0m957+UPS8ZLJioiDZH66RPTfjLtv3Vu8tLkpWvDox9+MBa6fnGy5115+EyYnEkYHhwIp7WrN8Hzunrb4X0H7Qftf6iyNdoaLW6L3+Lf01N4sfCt/e8eGjk0Un316HVy9Ib7E/+kf7J74uK1ix+Hxv/83vvhK4MfB68FJ+Qbvgnf9ZarjeSjxrGq4VfDr759ILivb3+g0LeXUErbJFrRXxM66S0/cfhYJVnvghCFRqhrhaEO1sZ2MRtrpKJT8qEIaKxVH7TEd7wlQpQ1srpONuSFNtgFNuAC3oz5rIjRWD/HeiqN/5LsGx1lVkjvl7x9rb2eXnKPJYOe6SF5m+QKuALODlLHNoOV1sFmyel1eVweAsn3QA/6e5AseVytLm8TgfTXKFhZ+mtSR1OnS3YREyTzHHqm/Vq64On19HlJP6QzK+1n6VJfR2/gQoAwrYnxF5lYsiT3dvZ29JFl3KozWyJrB0LEsnogiG9MoTqapOF/hk8gCeMNGQWeG3TZBCZmAitYt/ybWXkFfCYlijlnTcsmShURN4mYlHj58ptuWkZWbqtpWaO79jIBL/OCeCiFmaiU+PBBv7BA2YbshYfPd6aBRF4fcEfWj/bEZtrS7u5y9tF3gn0P7ZI1oi/4Du1zxnYLiW0X94mWVe1/AVE82XMAAAAAAAABAAAAANDR138AAAAAz5mnxQAAAADRBELmeJxjYGRgYOABYjEGOQYmBkYgFAViFqAIExAzQjAACdkAZAAAeJxjYGb+xTiBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKIHEC0lxTGBwYGJ8xMB/4f4ABSAJ5QDVwBQpAyAgAobYMfwB4nGNgYGBmgGAZBkYGEEgB8hjBfBYGDyDNx8DBwMTABhRTeMD3QP4Zw/+///+DVSo8YHggB+Uz/n+swCL/VUoUqhsFMLIBMRO6KCpgxi895AEAetoSOQAAeJxjYGQAg2MiZgnx/DZfGbhZwPyLLM4yCPr/LtY45gNALgcDE0gUAOkeCHF4nGNgZGBgPvD/AAMDaxwDA5hkZEAFfABctgNZeJxjYEAAJiBmgeADQNzAguAzsDhAxFnjwHQDgwVcmzyIAABxXQOhAAAAUAAAFgAAeJx1zT0KwjAcBfDXL8UKIiguLh0FoVg8goMU6eLg4tTWIAVtIOpQPIBHcPQ2grfy1f4dG0j6y0tfAmCINyz8hy220MVIbNNzsUOvxC69F3vo4y7uMH+KfYzxYctye/JCYwsDqrFNT8UOvRS79EbsYYJc3GH+EPuY4VVfW/BY48ypUXKb67PWxBYKR9xwQgrDrTreTqlp/78t3/EegwvP6zxAhBALxspcCl0GUbho767ZLX/9FFd+D+xnqLjGv0byb6xVqUx6VYcgq4I410ld/wJ2ozpzAAAAeJxjYGbACwAAfQAE) format(\"woff\"), url('font/vjs.eot?#iefix') format('embedded-opentype'), url('font/vjs.ttf') format('truetype'), url('font/vjs.svg#icomoon') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n/* Base UI Component Classes\n--------------------------------------------------------------------------------\n*/\n/* Slider - used for Volume bar and Seek bar */\n.vjs-default-skin .vjs-slider {\n  /* Replace browser focus highlight with handle highlight */\n  outline: 0;\n  position: relative;\n  cursor: pointer;\n  padding: 0;\n  /* background-color-with-alpha */\n  background-color: #333333;\n  background-color: rgba(51, 51, 51, 0.9);\n}\n.vjs-default-skin .vjs-slider:focus {\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 2em #fff;\n  -moz-box-shadow: 0 0 2em #fff;\n  box-shadow: 0 0 2em #fff;\n}\n.vjs-default-skin .vjs-slider-handle {\n  position: absolute;\n  /* Needed for IE6 */\n  left: 0;\n  top: 0;\n}\n.vjs-default-skin .vjs-slider-handle:before {\n  content: \"\\e009\";\n  font-family: VideoJS;\n  font-size: 1em;\n  line-height: 1;\n  text-align: center;\n  text-shadow: 0em 0em 1em #fff;\n  position: absolute;\n  top: 0;\n  left: 0;\n  /* Rotate the square icon to make a diamond */\n  /* transform */\n  -webkit-transform: rotate(-45deg);\n  -moz-transform: rotate(-45deg);\n  -ms-transform: rotate(-45deg);\n  -o-transform: rotate(-45deg);\n  transform: rotate(-45deg);\n}\n/* Control Bar\n--------------------------------------------------------------------------------\nThe default control bar that is a container for most of the controls.\n*/\n.vjs-default-skin .vjs-control-bar {\n  /* Start hidden */\n  display: none;\n  position: absolute;\n  /* Place control bar at the bottom of the player box/video.\n     If you want more margin below the control bar, add more height. */\n  bottom: 0;\n  /* Use left/right to stretch to 100% width of player div */\n  left: 0;\n  right: 0;\n  /* Height includes any margin you want above or below control items */\n  height: 3.0em;\n  /* background-color-with-alpha */\n  background-color: #07141E;\n  background-color: rgba(7, 20, 30, 0.7);\n}\n/* Show the control bar only once the video has started playing */\n.vjs-default-skin.vjs-has-started .vjs-control-bar {\n  display: block;\n  /* Visibility needed to make sure things hide in older browsers too. */\n  visibility: visible;\n  opacity: 1;\n  /* transition */\n  -webkit-transition: visibility 0.1s, opacity 0.1s;\n  -moz-transition: visibility 0.1s, opacity 0.1s;\n  -o-transition: visibility 0.1s, opacity 0.1s;\n  transition: visibility 0.1s, opacity 0.1s;\n}\n/* Hide the control bar when the video is playing and the user is inactive  */\n.vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {\n  display: block;\n  visibility: hidden;\n  opacity: 0;\n  /* transition */\n  -webkit-transition: visibility 1s, opacity 1s;\n  -moz-transition: visibility 1s, opacity 1s;\n  -o-transition: visibility 1s, opacity 1s;\n  transition: visibility 1s, opacity 1s;\n}\n.vjs-default-skin.vjs-controls-disabled .vjs-control-bar {\n  display: none;\n}\n.vjs-default-skin.vjs-using-native-controls .vjs-control-bar {\n  display: none;\n}\n/* The control bar shouldn't show after an error */\n.vjs-default-skin.vjs-error .vjs-control-bar {\n  display: none;\n}\n/* Don't hide the control bar if it's audio */\n.vjs-audio.vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {\n  opacity: 1;\n  visibility: visible;\n}\n/* IE8 is flakey with fonts, and you have to change the actual content to force\nfonts to show/hide properly.\n  - \"\\9\" IE8 hack didn't work for this\n  - Found in XP IE8 from http://modern.ie. Does not show up in \"IE8 mode\" in IE9\n*/\n@media \\0screen {\n  .vjs-default-skin.vjs-user-inactive.vjs-playing .vjs-control-bar :before {\n    content: \"\";\n  }\n}\n/* General styles for individual controls. */\n.vjs-default-skin .vjs-control {\n  outline: none;\n  position: relative;\n  float: left;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: 3.0em;\n  width: 4em;\n}\n/* Font button icons */\n.vjs-default-skin .vjs-control:before {\n  font-family: VideoJS;\n  font-size: 1.5em;\n  line-height: 2;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);\n}\n/* Replacement for focus outline */\n.vjs-default-skin .vjs-control:focus:before,\n.vjs-default-skin .vjs-control:hover:before {\n  text-shadow: 0em 0em 1em #ffffff;\n}\n.vjs-default-skin .vjs-control:focus {\n  /*  outline: 0; */\n  /* keyboard-only users cannot see the focus on several of the UI elements when\n  this is set to 0 */\n}\n/* Hide control text visually, but have it available for screenreaders */\n.vjs-default-skin .vjs-control-text {\n  /* hide-visually */\n  border: 0;\n  clip: rect(0 0 0 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n/* Play/Pause\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-play-control {\n  width: 5em;\n  cursor: pointer;\n}\n.vjs-default-skin .vjs-play-control:before {\n  content: \"\\e001\";\n}\n.vjs-default-skin.vjs-playing .vjs-play-control:before {\n  content: \"\\e002\";\n}\n/* Playback toggle\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-playback-rate .vjs-playback-rate-value {\n  font-size: 1.5em;\n  line-height: 2;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);\n}\n.vjs-default-skin .vjs-playback-rate.vjs-menu-button .vjs-menu .vjs-menu-content {\n  width: 4em;\n  left: -2em;\n  list-style: none;\n}\n/* Volume/Mute\n-------------------------------------------------------------------------------- */\n.vjs-default-skin .vjs-mute-control,\n.vjs-default-skin .vjs-volume-menu-button {\n  cursor: pointer;\n  float: right;\n}\n.vjs-default-skin .vjs-mute-control:before,\n.vjs-default-skin .vjs-volume-menu-button:before {\n  content: \"\\e006\";\n}\n.vjs-default-skin .vjs-mute-control.vjs-vol-0:before,\n.vjs-default-skin .vjs-volume-menu-button.vjs-vol-0:before {\n  content: \"\\e003\";\n}\n.vjs-default-skin .vjs-mute-control.vjs-vol-1:before,\n.vjs-default-skin .vjs-volume-menu-button.vjs-vol-1:before {\n  content: \"\\e004\";\n}\n.vjs-default-skin .vjs-mute-control.vjs-vol-2:before,\n.vjs-default-skin .vjs-volume-menu-button.vjs-vol-2:before {\n  content: \"\\e005\";\n}\n.vjs-default-skin .vjs-volume-control {\n  width: 5em;\n  float: right;\n}\n.vjs-default-skin .vjs-volume-bar {\n  width: 5em;\n  height: 0.6em;\n  margin: 1.1em auto 0;\n}\n.vjs-default-skin .vjs-volume-level {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 0.5em;\n  /* assuming volume starts at 1.0 */\n  width: 100%;\n  background: #66A8CC url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC) -50% 0 repeat;\n}\n.vjs-default-skin .vjs-volume-bar .vjs-volume-handle {\n  width: 0.5em;\n  height: 0.5em;\n  /* Assumes volume starts at 1.0. If you change the size of the\n     handle relative to the volume bar, you'll need to update this value\n     too. */\n  left: 4.5em;\n}\n.vjs-default-skin .vjs-volume-handle:before {\n  font-size: 0.9em;\n  top: -0.2em;\n  left: -0.2em;\n  width: 1em;\n  height: 1em;\n}\n/* The volume menu button is like menu buttons (captions/subtitles) but works\n    a little differently. It needs to be possible to tab to the volume slider\n    without hitting space bar on the menu button. To do this we're not using\n    display:none to hide the slider menu by default, and instead setting the\n    width and height to zero. */\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu {\n  display: block;\n  width: 0;\n  height: 0;\n  border-top-color: transparent;\n}\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu .vjs-menu-content {\n  height: 0;\n  width: 0;\n}\n.vjs-default-skin .vjs-volume-menu-button:hover .vjs-menu,\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu.vjs-lock-showing {\n  border-top-color: rgba(7, 40, 50, 0.5);\n  /* Same as ul background */\n}\n.vjs-default-skin .vjs-volume-menu-button:hover .vjs-menu .vjs-menu-content,\n.vjs-default-skin .vjs-volume-menu-button .vjs-menu.vjs-lock-showing .vjs-menu-content {\n  height: 2.9em;\n  width: 10em;\n}\n/* Progress\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-progress-control {\n  position: absolute;\n  left: 0;\n  right: 0;\n  width: auto;\n  font-size: 0.3em;\n  height: 1em;\n  /* Set above the rest of the controls. */\n  top: -1em;\n  /* Shrink the bar slower than it grows. */\n  /* transition */\n  -webkit-transition: all 0.4s;\n  -moz-transition: all 0.4s;\n  -o-transition: all 0.4s;\n  transition: all 0.4s;\n}\n/* On hover, make the progress bar grow to something that's more clickable.\n    This simply changes the overall font for the progress bar, and this\n    updates both the em-based widths and heights, as wells as the icon font */\n.vjs-default-skin:hover .vjs-progress-control {\n  font-size: .9em;\n  /* Even though we're not changing the top/height, we need to include them in\n      the transition so they're handled correctly. */\n  /* transition */\n  -webkit-transition: all 0.2s;\n  -moz-transition: all 0.2s;\n  -o-transition: all 0.2s;\n  transition: all 0.2s;\n}\n/* Box containing play and load progresses. Also acts as seek scrubber. */\n.vjs-default-skin .vjs-progress-holder {\n  height: 100%;\n}\n/* Progress Bars */\n.vjs-default-skin .vjs-progress-holder .vjs-play-progress,\n.vjs-default-skin .vjs-progress-holder .vjs-load-progress,\n.vjs-default-skin .vjs-progress-holder .vjs-load-progress div {\n  position: absolute;\n  display: block;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  /* updated by javascript during playback */\n  width: 0;\n  /* Needed for IE6 */\n  left: 0;\n  top: 0;\n}\n.vjs-default-skin .vjs-play-progress {\n  /*\n    Using a data URI to create the white diagonal lines with a transparent\n      background. Surprisingly works in IE8.\n      Created using http://www.patternify.com\n    Changing the first color value will change the bar color.\n    Also using a paralax effect to make the lines move backwards.\n      The -50% left position makes that happen.\n  */\n  background: #66A8CC url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC) -50% 0 repeat;\n}\n.vjs-default-skin .vjs-load-progress {\n  background: #646464 /* IE8- Fallback */;\n  background: rgba(255, 255, 255, 0.2);\n}\n/* there are child elements of the load progress bar that represent the\n   specific time ranges that have been buffered */\n.vjs-default-skin .vjs-load-progress div {\n  background: #787878 /* IE8- Fallback */;\n  background: rgba(255, 255, 255, 0.1);\n}\n.vjs-default-skin .vjs-seek-handle {\n  width: 1.5em;\n  height: 100%;\n}\n.vjs-default-skin .vjs-seek-handle:before {\n  padding-top: 0.1em /* Minor adjustment */;\n}\n/* Live Mode\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin.vjs-live .vjs-time-controls,\n.vjs-default-skin.vjs-live .vjs-time-divider,\n.vjs-default-skin.vjs-live .vjs-progress-control {\n  display: none;\n}\n.vjs-default-skin.vjs-live .vjs-live-display {\n  display: block;\n}\n/* Live Display\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-live-display {\n  display: none;\n  font-size: 1em;\n  line-height: 3em;\n}\n/* Time Display\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-time-controls {\n  font-size: 1em;\n  /* Align vertically by making the line height the same as the control bar */\n  line-height: 3em;\n}\n.vjs-default-skin .vjs-current-time {\n  float: left;\n}\n.vjs-default-skin .vjs-duration {\n  float: left;\n}\n/* Remaining time is in the HTML, but not included in default design */\n.vjs-default-skin .vjs-remaining-time {\n  display: none;\n  float: left;\n}\n.vjs-time-divider {\n  float: left;\n  line-height: 3em;\n}\n/* Fullscreen\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-fullscreen-control {\n  width: 3.8em;\n  cursor: pointer;\n  float: right;\n}\n.vjs-default-skin .vjs-fullscreen-control:before {\n  content: \"\\e000\";\n}\n/* Switch to the exit icon when the player is in fullscreen */\n.vjs-default-skin.vjs-fullscreen .vjs-fullscreen-control:before {\n  content: \"\\e00b\";\n}\n/* Big Play Button (play button at start)\n--------------------------------------------------------------------------------\nPositioning of the play button in the center or other corners can be done more\neasily in the skin designer. http://designer.videojs.com/\n*/\n.vjs-default-skin .vjs-big-play-button {\n  left: 0.5em;\n  top: 0.5em;\n  font-size: 3em;\n  display: block;\n  z-index: 2;\n  position: absolute;\n  width: 4em;\n  height: 2.6em;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  opacity: 1;\n  /* Need a slightly gray bg so it can be seen on black backgrounds */\n  /* background-color-with-alpha */\n  background-color: #07141E;\n  background-color: rgba(7, 20, 30, 0.7);\n  border: 0.1em solid #3b4249;\n  /* border-radius */\n  -webkit-border-radius: 0.8em;\n  -moz-border-radius: 0.8em;\n  border-radius: 0.8em;\n  /* box-shadow */\n  -webkit-box-shadow: 0px 0px 1em rgba(255, 255, 255, 0.25);\n  -moz-box-shadow: 0px 0px 1em rgba(255, 255, 255, 0.25);\n  box-shadow: 0px 0px 1em rgba(255, 255, 255, 0.25);\n  /* transition */\n  -webkit-transition: all 0.4s;\n  -moz-transition: all 0.4s;\n  -o-transition: all 0.4s;\n  transition: all 0.4s;\n}\n/* Optionally center */\n.vjs-default-skin.vjs-big-play-centered .vjs-big-play-button {\n  /* Center it horizontally */\n  left: 50%;\n  margin-left: -2.1em;\n  /* Center it vertically */\n  top: 50%;\n  margin-top: -1.4em;\n}\n/* Hide if controls are disabled */\n.vjs-default-skin.vjs-controls-disabled .vjs-big-play-button {\n  display: none;\n}\n/* Hide when video starts playing */\n.vjs-default-skin.vjs-has-started .vjs-big-play-button {\n  display: none;\n}\n/* Hide on mobile devices. Remove when we stop using native controls\n    by default on mobile  */\n.vjs-default-skin.vjs-using-native-controls .vjs-big-play-button {\n  display: none;\n}\n.vjs-default-skin:hover .vjs-big-play-button,\n.vjs-default-skin .vjs-big-play-button:focus {\n  outline: 0;\n  border-color: #fff;\n  /* IE8 needs a non-glow hover state */\n  background-color: #505050;\n  background-color: rgba(50, 50, 50, 0.75);\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 3em #fff;\n  -moz-box-shadow: 0 0 3em #fff;\n  box-shadow: 0 0 3em #fff;\n  /* transition */\n  -webkit-transition: all 0s;\n  -moz-transition: all 0s;\n  -o-transition: all 0s;\n  transition: all 0s;\n}\n.vjs-default-skin .vjs-big-play-button:before {\n  content: \"\\e001\";\n  font-family: VideoJS;\n  /* In order to center the play icon vertically we need to set the line height\n     to the same as the button height */\n  line-height: 2.6em;\n  text-shadow: 0.05em 0.05em 0.1em #000;\n  text-align: center /* Needed for IE8 */;\n  position: absolute;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n.vjs-error .vjs-big-play-button {\n  display: none;\n}\n/* Error Display\n--------------------------------------------------------------------------------\n*/\n.vjs-error-display {\n  display: none;\n}\n.vjs-error .vjs-error-display {\n  display: block;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n.vjs-error .vjs-error-display:before {\n  content: 'X';\n  font-family: Arial;\n  font-size: 4em;\n  color: #666666;\n  /* In order to center the play icon vertically we need to set the line height\n     to the same as the button height */\n  line-height: 1;\n  text-shadow: 0.05em 0.05em 0.1em #000;\n  text-align: center /* Needed for IE8 */;\n  vertical-align: middle;\n  position: absolute;\n  left: 0;\n  top: 50%;\n  margin-top: -0.5em;\n  width: 100%;\n}\n.vjs-error-display div {\n  position: absolute;\n  bottom: 1em;\n  right: 0;\n  left: 0;\n  font-size: 1.4em;\n  text-align: center;\n  padding: 3px;\n  background: #000000;\n  background: rgba(0, 0, 0, 0.5);\n}\n.vjs-error-display a,\n.vjs-error-display a:visited {\n  color: #F4A460;\n}\n/* Loading Spinner\n--------------------------------------------------------------------------------\n*/\n.vjs-loading-spinner {\n  /* Should be hidden by default */\n  display: none;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  font-size: 4em;\n  line-height: 1;\n  width: 1em;\n  height: 1em;\n  margin-left: -0.5em;\n  margin-top: -0.5em;\n  opacity: 0.75;\n}\n/* Show the spinner when waiting for data and seeking to a new time */\n.vjs-waiting .vjs-loading-spinner,\n.vjs-seeking .vjs-loading-spinner {\n  display: block;\n  /* only animate when showing because it can be processor heavy */\n  /* animation */\n  -webkit-animation: spin 1.5s infinite linear;\n  -moz-animation: spin 1.5s infinite linear;\n  -o-animation: spin 1.5s infinite linear;\n  animation: spin 1.5s infinite linear;\n}\n/* Errors are unrecoverable without user interaction so hide the spinner */\n.vjs-error .vjs-loading-spinner {\n  display: none;\n  /* ensure animation doesn't continue while hidden */\n  /* animation */\n  -webkit-animation: none;\n  -moz-animation: none;\n  -o-animation: none;\n  animation: none;\n}\n.vjs-default-skin .vjs-loading-spinner:before {\n  content: \"\\e01e\";\n  font-family: VideoJS;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 1em;\n  height: 1em;\n  text-align: center;\n  text-shadow: 0em 0em 0.1em #000;\n}\n@-moz-keyframes spin {\n  0% {\n    -moz-transform: rotate(0deg);\n  }\n  100% {\n    -moz-transform: rotate(359deg);\n  }\n}\n@-webkit-keyframes spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n  }\n}\n@-o-keyframes spin {\n  0% {\n    -o-transform: rotate(0deg);\n  }\n  100% {\n    -o-transform: rotate(359deg);\n  }\n}\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(359deg);\n  }\n}\n/* Menu Buttons (Captions/Subtitles/etc.)\n--------------------------------------------------------------------------------\n*/\n.vjs-default-skin .vjs-menu-button {\n  float: right;\n  cursor: pointer;\n}\n.vjs-default-skin .vjs-menu {\n  display: none;\n  position: absolute;\n  bottom: 0;\n  left: 0em;\n  /* (Width of vjs-menu - width of button) / 2 */\n  width: 0em;\n  height: 0em;\n  margin-bottom: 3em;\n  border-left: 2em solid transparent;\n  border-right: 2em solid transparent;\n  border-top: 1.55em solid #000000;\n  /* Same width top as ul bottom */\n  border-top-color: rgba(7, 40, 50, 0.5);\n  /* Same as ul background */\n}\n/* Button Pop-up Menu */\n.vjs-default-skin .vjs-menu-button .vjs-menu .vjs-menu-content {\n  display: block;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  width: 10em;\n  bottom: 1.5em;\n  /* Same bottom as vjs-menu border-top */\n  max-height: 15em;\n  overflow: auto;\n  left: -5em;\n  /* Width of menu - width of button / 2 */\n  /* background-color-with-alpha */\n  background-color: #07141E;\n  background-color: rgba(7, 20, 30, 0.7);\n  /* box-shadow */\n  -webkit-box-shadow: -0.2em -0.2em 0.3em rgba(255, 255, 255, 0.2);\n  -moz-box-shadow: -0.2em -0.2em 0.3em rgba(255, 255, 255, 0.2);\n  box-shadow: -0.2em -0.2em 0.3em rgba(255, 255, 255, 0.2);\n}\n.vjs-default-skin .vjs-menu-button:hover .vjs-control-content .vjs-menu,\n.vjs-default-skin .vjs-control-content .vjs-menu.vjs-lock-showing {\n  display: block;\n}\n/* prevent menus from opening while scrubbing (FF, IE) */\n.vjs-default-skin.vjs-scrubbing .vjs-menu-button:hover .vjs-control-content .vjs-menu {\n  display: none;\n}\n.vjs-default-skin .vjs-menu-button ul li {\n  list-style: none;\n  margin: 0;\n  padding: 0.3em 0 0.3em 0;\n  line-height: 1.4em;\n  font-size: 1.2em;\n  text-align: center;\n  text-transform: lowercase;\n}\n.vjs-default-skin .vjs-menu-button ul li.vjs-selected {\n  background-color: #000;\n}\n.vjs-default-skin .vjs-menu-button ul li:focus,\n.vjs-default-skin .vjs-menu-button ul li:hover,\n.vjs-default-skin .vjs-menu-button ul li.vjs-selected:focus,\n.vjs-default-skin .vjs-menu-button ul li.vjs-selected:hover {\n  outline: 0;\n  color: #111;\n  /* background-color-with-alpha */\n  background-color: #ffffff;\n  background-color: rgba(255, 255, 255, 0.75);\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 1em #ffffff;\n  -moz-box-shadow: 0 0 1em #ffffff;\n  box-shadow: 0 0 1em #ffffff;\n}\n.vjs-default-skin .vjs-menu-button ul li.vjs-menu-title {\n  text-align: center;\n  text-transform: uppercase;\n  font-size: 1em;\n  line-height: 2em;\n  padding: 0;\n  margin: 0 0 0.3em 0;\n  font-weight: bold;\n  cursor: default;\n}\n/* Subtitles Button */\n.vjs-default-skin .vjs-subtitles-button:before {\n  content: \"\\e00c\";\n}\n/* Captions Button */\n.vjs-default-skin .vjs-captions-button:before {\n  content: \"\\e008\";\n}\n/* Chapters Button */\n.vjs-default-skin .vjs-chapters-button:before {\n  content: \"\\e00c\";\n}\n.vjs-default-skin .vjs-chapters-button.vjs-menu-button .vjs-menu .vjs-menu-content {\n  width: 24em;\n  left: -12em;\n}\n/* Replacement for focus outline */\n.vjs-default-skin .vjs-captions-button:focus .vjs-control-content:before,\n.vjs-default-skin .vjs-captions-button:hover .vjs-control-content:before {\n  /* box-shadow */\n  -webkit-box-shadow: 0 0 1em #ffffff;\n  -moz-box-shadow: 0 0 1em #ffffff;\n  box-shadow: 0 0 1em #ffffff;\n}\n/*\nREQUIRED STYLES (be careful overriding)\n================================================================================\nWhen loading the player, the video tag is replaced with a DIV,\nthat will hold the video tag or object tag for other playback methods.\nThe div contains the video playback element (Flash or HTML5) and controls,\nand sets the width and height of the video.\n\n** If you want to add some kind of border/padding (e.g. a frame), or special\npositioning, use another containing element. Otherwise you risk messing up\ncontrol positioning and full window mode. **\n*/\n.video-js {\n  background-color: #000;\n  position: relative;\n  padding: 0;\n  /* Start with 10px for base font size so other dimensions can be em based and\n     easily calculable. */\n  font-size: 10px;\n  /* Allow poster to be vertically aligned. */\n  vertical-align: middle;\n  /*  display: table-cell; */\n  /*This works in Safari but not Firefox.*/\n  /* Provide some basic defaults for fonts */\n  font-weight: normal;\n  font-style: normal;\n  /* Avoiding helvetica: issue #376 */\n  font-family: Arial, sans-serif;\n  /* Turn off user selection (text highlighting) by default.\n     The majority of player components will not be text blocks.\n     Text areas will need to turn user selection back on. */\n  /* user-select */\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n/* Playback technology elements expand to the width/height of the containing div\n    <video> or <object> */\n.video-js .vjs-tech {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n/* Fix for Firefox 9 fullscreen (only if it is enabled). Not needed when\n   checking fullScreenEnabled. */\n.video-js:-moz-full-screen {\n  position: absolute;\n}\n/* Fullscreen Styles */\nbody.vjs-full-window {\n  padding: 0;\n  margin: 0;\n  height: 100%;\n  /* Fix for IE6 full-window. http://www.cssplay.co.uk/layouts/fixed.html */\n  overflow-y: auto;\n}\n.video-js.vjs-fullscreen {\n  position: fixed;\n  overflow: hidden;\n  z-index: 1000;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  width: 100% !important;\n  height: 100% !important;\n  /* IE6 full-window (underscore hack) */\n  _position: absolute;\n}\n.video-js:-webkit-full-screen {\n  width: 100% !important;\n  height: 100% !important;\n}\n.video-js.vjs-fullscreen.vjs-user-inactive {\n  cursor: none;\n}\n/* Poster Styles */\n.vjs-poster {\n  background-repeat: no-repeat;\n  background-position: 50% 50%;\n  background-size: contain;\n  background-color: #000000;\n  cursor: pointer;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vjs-poster img {\n  display: block;\n  margin: 0 auto;\n  max-height: 100%;\n  padding: 0;\n  width: 100%;\n}\n/* Hide the poster after the video has started playing */\n.video-js.vjs-has-started .vjs-poster {\n  display: none;\n}\n/* Don't hide the poster if we're playing audio */\n.video-js.vjs-audio.vjs-has-started .vjs-poster {\n  display: block;\n}\n/* Hide the poster when controls are disabled because it's clickable\n    and the native poster can take over */\n.video-js.vjs-controls-disabled .vjs-poster {\n  display: none;\n}\n/* Hide the poster when native controls are used otherwise it covers them */\n.video-js.vjs-using-native-controls .vjs-poster {\n  display: none;\n}\n/* Text Track Styles */\n/* Overall track holder for both captions and subtitles */\n.video-js .vjs-text-track-display {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 3em;\n  right: 0;\n  pointer-events: none;\n}\n/* Captions Settings Dialog */\n.vjs-caption-settings {\n  position: relative;\n  top: 1em;\n  background-color: #000;\n  opacity: 0.75;\n  color: #FFF;\n  margin: 0 auto;\n  padding: 0.5em;\n  height: 15em;\n  font-family: Arial, Helvetica, sans-serif;\n  font-size: 12px;\n  width: 40em;\n}\n.vjs-caption-settings .vjs-tracksettings {\n  top: 0;\n  bottom: 2em;\n  left: 0;\n  right: 0;\n  position: absolute;\n  overflow: auto;\n}\n.vjs-caption-settings .vjs-tracksettings-colors,\n.vjs-caption-settings .vjs-tracksettings-font {\n  float: left;\n}\n.vjs-caption-settings .vjs-tracksettings-colors:after,\n.vjs-caption-settings .vjs-tracksettings-font:after,\n.vjs-caption-settings .vjs-tracksettings-controls:after {\n  clear: both;\n}\n.vjs-caption-settings .vjs-tracksettings-controls {\n  position: absolute;\n  bottom: 1em;\n  right: 1em;\n}\n.vjs-caption-settings .vjs-tracksetting {\n  margin: 5px;\n  padding: 3px;\n  min-height: 40px;\n}\n.vjs-caption-settings .vjs-tracksetting label {\n  display: block;\n  width: 100px;\n  margin-bottom: 5px;\n}\n.vjs-caption-settings .vjs-tracksetting span {\n  display: inline;\n  margin-left: 5px;\n}\n.vjs-caption-settings .vjs-tracksetting > div {\n  margin-bottom: 5px;\n  min-height: 20px;\n}\n.vjs-caption-settings .vjs-tracksetting > div:last-child {\n  margin-bottom: 0;\n  padding-bottom: 0;\n  min-height: 0;\n}\n.vjs-caption-settings label > input {\n  margin-right: 10px;\n}\n.vjs-caption-settings input[type=\"button\"] {\n  width: 40px;\n  height: 40px;\n}\n/* Hide disabled or unsupported controls */\n.vjs-hidden {\n  display: none !important;\n}\n.vjs-lock-showing {\n  display: block !important;\n  opacity: 1;\n  visibility: visible;\n}\n/*  In IE8 w/ no JavaScript (no HTML5 shim), the video tag doesn't register.\n    The .video-js classname on the video tag also isn't considered.\n    This optional paragraph inside the video tag can provide a message to users\n    about what's required to play video. */\n.vjs-no-js {\n  padding: 2em;\n  color: #ccc;\n  background-color: #333;\n  font-size: 1.8em;\n  font-family: Arial, sans-serif;\n  text-align: center;\n  width: 30em;\n  height: 15em;\n  margin: 0 auto;\n}\n.vjs-no-js a,\n.vjs-no-js a:visited {\n  color: #F4A460;\n}\n/* -----------------------------------------------------------------------------\nThe original source of this file lives at\nhttps://github.com/videojs/video.js/blob/master/src/css/video-js.less */\n"

        /***/ },
    /* 26 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Appnexus Viewability Wrapper for core video framework
         */

        var ANVideoViewabilityTracker = __webpack_require__(27);//appnexus viewability library
        var prefixOfLog = "[PlayerManager_ANVideoViewabilityTracker]";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(prefixOfLog, message);
        };
        var info = function (message) {
            APN_Logger.info(prefixOfLog, message);
        };

        var html5VideoViewability = function () {

            var tracker = null;
            var mappedActions = {
                "video_start": "start",
                "expand": "expand",
                "collapse": "collapse",
                "video_unmute": "sound_on",
                "video_mute": "sound_off",
                "video_pause": "pause",
                "video_resume": "resume",
                "ad-click": "click",
                "video_skip": "stop",
                "video_complete": "stop"
            };

            function parseUrl(_url) {
                "use strict";

                var urlObject = {
                    http: "",
                    params: ""
                };

                try {
                    if (_url && typeof _url === "string") {
                        var split = _url.split(/:/);
                        if (split.length === 2) {
                            _url = split[1];
                            urlObject.http = split[0];
                        }

                        split = _url.split(/\?/);
                        if (split.length === 2) {
                            urlObject.params = split[1];
                        } else if ((urlObject.http === "" || _url.substr(0, 2) !== "//") && _url.indexOf("=") > -1) {
                            urlObject.params = split[0];
                        }

                        if (urlObject.params !== "") {
                            split = urlObject.params.split(/&/);
                            urlObject.params = {};
                            for (var param in split) {
                                // get parameter name and value
                                var keyValue = split[param].split(/=/);
                                if (keyValue.length === 2) {
                                    urlObject.params[keyValue[0]] = decodeURIComponent(keyValue[1]);
                                } else if (keyValue.length > 2) {
                                    var value = "";
                                    for (var i = 1; i < keyValue.length; i++) {
                                        value += "=" + keyValue[i];
                                    }

                                    urlObject.params[keyValue[0]] = decodeURIComponent(value.substr(1));
                                } else {
                                    urlObject.params[keyValue[0]] = "";
                                }
                            }
                        }
                    }
                } catch (ex) {
                    debug(ex);
                }

                return urlObject;
            }

            function parseConfigs(_url) {
                "use strict";
                try {
                    if (_url && typeof _url === "string") {
                        if (_url.substring(0, 9) === "<![CDATA[") {
                            _url = _url.substring(9, _url.length - 3);
                        }
                        var extracted = parseUrl(_url);

                        if (extracted.hasOwnProperty("params") && extracted.params !== "") {
                            return extracted.params;
                        }
                    }
                } catch (ex) {
                    debug(ex);
                }
                // Return empty object
                return {};
            }

            var getDebug = function () {
                // Active debug for this demo
                return true;
            };

            var getConfig = function (options_) {
                return options_ && options_.viewability && options_.viewability.config;
            };

            var getPlayerDOMElement = function (options_) {
                return options_.targetElement;
            };

            var getVideoInfo = function (duration, width, height) {
                return {duration: duration, w: width, h: height};
            };

            var createViewabilityPayload = function (options_) {

                // Create a JSON Formatted viewability payload
                info("createViewabilityPayload");

                var config = getConfig(options_);
                var parameters = parseConfigs(config);

                var payload = {
                    "vp": config,
                    "vjs": parameters.vjs
                };

                debug(payload);
                return payload;
            };

            this.init = function (options_, duration, width, height) {
                info("initialize");
                debug("duration: " + duration + ", width: " + width + ", height: " + height);
                try {
                    tracker = new ANVideoViewabilityTracker(
                        createViewabilityPayload(options_),
                        getPlayerDOMElement(options_),
                        getVideoInfo(duration, width, height), // The duration of the video ad
                        getDebug() // optionnal, true to enable console log
                    );
                    this.isReady = true;
                } catch (ex) {
                    debug(ex);
                }

            };

            this.invokeEvent = function (event_) {
                if (event_ && mappedActions[event_]) {
                    try {
                        info("event invoked : " + mappedActions[event_]);
                        tracker.notifyEvent(mappedActions[event_]);
                    } catch (ex) {
                        debug(ex);
                    }
                }
            };

            this.isReady = false;


        };


        module.exports = html5VideoViewability;

        /***/ },
    /* 27 */
    /***/ function(module, exports) {

        var ANVideoViewabilityTracker = function (_viewabilityPayload, _domElt, _videoInfos, _debug) {
            this.debug = _debug;
            this.adUID = "WR_" + new Date().getTime() + Math.round(Math.random() * 1000);

            // identify document and window of the iframe where the script must be installed
            // get the id of the dom element to analyse (entry could be the id or a dom element)
            var domId = "";
            try {
                if (typeof _domElt === "object") {
                    // try to get document form domElt first, if fail, no id will be set
                    this.videoNodeDocument = _domElt.ownerDocument;
                    this.videoNodeWindow = this.videoNodeDocument.defaultView || this.videoNodeDocument.videoNodeWindow;

                    // if dom Element haven't id, set a default
                    if (_domElt.id === "") {
                        _domElt.id = "an_video_" + this.adUID;
                    }
                    domId = _domElt.id;
                } else {
                    domId = _domElt;
                    this.videoNodeDocument = document;
                    this.videoNodeWindow = window;
                }
            } catch (e) {
                this.videoNodeDocument = document;
                this.videoNodeWindow = window;
            }

            // Get object containing duration, dimension and position
            this.videoInfo = this.decodeVideoInfos(_videoInfos);

            if (this.debug) {
                console.log("ANVideoViewabilityTracker start with parameters  \n" +
                    "DomID:\t\t[" + domId + "]\n" +
                    "adUID:\t\t[" + this.adUID + "]\n" +
                    "Duration:\t[" + this.videoInfo.duration + "]\n" +
                    "Payload:\t" + _viewabilityPayload + "\n\n" +
                    "Dimension:\t(" + this.videoInfo.w + "," + this.videoInfo.h + ")\n" +
                    "Position:\t(" + this.videoInfo.x + "," + this.videoInfo.y + ")"
                );
            }

            // Get object with Viewability Payload
            this.viewabilityData = this.decodePayload(_viewabilityPayload);
            try {
                // Create temporary cache, used to store API calls until the viewability script is loaded
                if (typeof this.videoNodeWindow.anxVVAPICache == 'undefined') {
                    this.videoNodeWindow.anxVVAPICache = {
                        events: Array(),
                        init: Array()
                    };

                    // Injects the viewability script in the page
                    var scriptElement = this.videoNodeDocument.createElement('script');
                    scriptElement.type = 'text/javascript';
                    scriptElement.async = true;
                    scriptElement.src = this.viewabilityData.viewJS;
                    var head = this.videoNodeDocument.getElementsByTagName("head")[0];
                    head.appendChild(scriptElement);
                }
            } catch (e) {
                if (this.debug) {
                    console.error("ANVideoViewabilityTracker initialization failed", e);
                }
            }

            // Init module version
            this.extractVersionModule(this.viewabilityData);

            // Initialize Viewability Script if present, cache informations if not
            if (typeof this.videoNodeWindow.anxVVAPI == 'undefined') {
                var createCall = {
                    a: this.adUID,
                    params: this.viewabilityData.viewParams,
                    id: domId,
                    v: this.VIEWABILITY_MODULE_VERSION,
                    dur: this.videoInfo.duration,
                    // Considering the video size is the player size :
                    w: this.videoInfo.w,
                    h: this.videoInfo.h,
                    x: this.videoInfo.x,
                    y: this.videoInfo.y
                };
                this.videoNodeWindow.anxVVAPICache.init.push(createCall);
            } else {
                this.videoNodeWindow.anxVVAPI.initializeFromParams(
                    this.viewabilityData.viewParams,
                    domId,
                    this.adUID,
                    this.VIEWABILITY_MODULE_VERSION,
                    this.videoInfo.duration,
                    this.videoInfo.w,
                    this.videoInfo.h,
                    this.videoInfo.x,
                    this.videoInfo.y
                );
            }
        };

        ANVideoViewabilityTracker.prototype = {
            // This module version
            VIEWABILITY_MODULE_VERSION: 1,
            // Default debug mode
            debug: false,
            //Sound Tracking
            lastKnownVolume: -1,

            // Convert viewability payload to the expected format
            decodePayload: function (_payload) {
                // Considering the payload is JSON-formatted
                // We already have anything we need
                if (_payload.vjs && _payload.vp) {
                    return {
                        viewJS: _payload.vjs,
                        viewParams: _payload.vp
                    };
                } else {
                    return null;
                }
            },

            // Extract Ad informations (duration, dimensions and positions)
            decodeVideoInfos: function (_videoInfos) {
                var ad = { duration: 0, w: 0, h: 0, x: 0, y: 0 };

                if (typeof _videoInfos.duration === "number" || _videoInfos.duration > 0) {
                    ad.duration = _videoInfos.duration;
                }
                if (typeof _videoInfos.w === "number" || _videoInfos.w > 0) {
                    ad.w = _videoInfos.w;
                }
                if (typeof _videoInfos.h === "number" || _videoInfos.h > 0) {
                    ad.h = _videoInfos.h;
                }
                if (typeof _videoInfos.x === "number" || _videoInfos.x > 0) {
                    ad.x = _videoInfos.x;
                }
                if (typeof _videoInfos.y === "number" || _videoInfos.y > 0) {
                    ad.y = _videoInfos.y;
                }

                return ad;
            },

            // Extract module version from viewability script url
            extractVersionModule: function (_viewData) {
                if (_viewData) {
                    var regex = /.+\/(\d+)\/trk\.js/;
                    var match = regex.exec(_viewData.viewJS);
                    if (match && match[1]) {
                        this.VIEWABILITY_MODULE_VERSION = match[1];
                    }
                }
            },

            // Pass video events to the viewability JS
            notifyEvent: function (_eventCode) {
                if (this.debug) {
                    console.log("notifyEvent: [" + _eventCode + "]");
                }

                var timeData = new Date().getTime();
                try {
                    if (typeof this.videoNodeWindow.anxVVAPI == 'undefined') {
                        var createCall = {
                            a: this.adUID,
                            c: _eventCode,
                            d: timeData
                        };
                        this.videoNodeWindow.anxVVAPICache.events.push(createCall);
                    } else {
                        this.videoNodeWindow.anxVVAPI.notifyEvent(this.adUID, _eventCode);
                    }
                } catch (e) {
                    if (this.debug) {
                        console.error("notifyEvent failed", e);
                    }
                }
            },

            // Update volume state and notify event when volume changed
            onVolumeChange: function (_volume) {
                if (typeof _volume !== "number") {
                    return;
                }

                if (_volume > 1) {
                    _volume = 1;
                }

                if (_volume < 0) {
                    _volume = 0;
                }

                if (_volume != this.lastKnownVolume) {
                    if (_volume > 0) {
                        this.notifyEvent("sound_on");
                    } else {
                        this.notifyEvent("sound_off");
                    }

                    this.lastKnownVolume = _volume;
                }
            }
        };

        module.exports = ANVideoViewabilityTracker;


        /***/ },
    /* 28 */
    /***/ function(module, exports, __webpack_require__) {

        var APNVideo_VastParser = __webpack_require__(29);
        var APN_RenditionManager = __webpack_require__(36);
        var APN_TrackingManager = __webpack_require__(37);
        var APN_CompanionManager = __webpack_require__(38);
        var APN_Logger = __webpack_require__(34);

        var debug = function (message) {
            APN_Logger.debug(message, "AdHandler");
        };


        //common part to load video player
        module.exports = function (targetElement, options, cbAdunits) {


            var VAST_ERROR_UNDEFINED = 900;
            var ERROR_TYPE_VAST = 1;//vast-error (one of the error codes specified in the VAST spec)
            var isDoneCbHandlingRendition = false;//flag for checking callback is done
            var timeToWaitFor = 3000;//callback waiting
            var vastVersion = "2.0";
            var adId = new Date().getTime() + Math.floor(Math.random() * 10000);

            // waterfall Initializations
            var vastObjArr = [];
            var rtbAd;
            var currentAd;
            var impressionSent = false;
            var isWaterfall = false;
            var waterfallTimeout = options.waterfallTimeout;
            var waterfallTimeoutHandler;
            var waterfallTimeoutOccurred = false;
            var waterfallStepLogged = false;
            var adCount = 0;
            var maxNonRtbAdCount = 0;
            var totalAvailableAds = 0;
            var waterfallSteps = options.waterfallSteps;
            var waterfallStartTimestamp;
            //callback for sent waterfall step details to the adUnit
            var waterfallCallback =  function (obj){
                if(cbAdunits.cbWhenWaterfall){
                    cbAdunits.cbWhenWaterfall(obj);
                }
            };
            //inject additional callback (getting override whenDestory callback)
            var tmpCallback = cbAdunits.cbWhenDestroy;
            // callback for impression sent event
            var impCallback = cbAdunits.cbWhenImpression;
            var notificationEventMapping = {
                "creative-view": "creativeView",
                "video-start": "start",
                "video-mid": "midpoint",
                "video-first-quartile": "firstQuartile",
                "video-third-quartile": "thirdQuartile",
                "video-complete": "complete",
                "audio-mute": "mute",
                "audio-unmute": "unmute",
                "video-pause": "pause",
                "video-rewind": "rewind",
                "video-resume": "resume",
                "video-fullscreen": "fullscreen",
                "ad-expand": "expand",
                "ad-collapse": "collapse",
                "video-stopped": "close",
                "video-exit-fullscreen": "exitFullscreen",
                "video-skip": "skip",
                "ad-progress": "progress",
                "acceptInvitation": "acceptInvitation",
                "acceptInvitationLinear": "acceptInvitationLinear",
                "closeLinear": "closeLinear",
                "impression": "impression",
                "error": "error",
                "video-failed": "error",
                "ad-click": "ClickTracking"
            };

            // companions
            var companionAdsObj = null;
            var currentVastObj = null;

            var isIphone = function () {
                var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
                return isFlag;
            };

            var isIos = function () {
                var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
                return isFlag;
            };

            var printWaterfallLog = function(stepLog, succ, errObj) {
                if(!isWaterfall) {return;}
                if(!currentAd) {return;}
                var type = currentAd.rtb ? "rtb" : "csm";
                var id = currentAd.adId;
                var notifyurl = currentAd.notifyurl;
                var currentTimestamp = new Date().getTime();
                var statusObj = {};
                statusObj.step = adCount;
                statusObj.totalAvailableSteps = totalAvailableAds;
                statusObj.stepLimit = waterfallSteps;
                statusObj.maxTime = waterfallTimeout;
                statusObj.timeRemaining = waterfallTimeout;
                if(waterfallStartTimestamp){
                    statusObj.timeRemaining = waterfallTimeout - (currentTimestamp - waterfallStartTimestamp);
                }

                if(stepLog){
                    waterfallStepLogged = false;
                    options.waterfallStepId = "Waterfall_Step_"+ new Date().getTime() + Math.floor(Math.random() * 10000);
                    statusObj.status = 'stepStart';
                    debug("Waterfall Step #" + adCount +" , type=" + type + ", adId=" + id +", timeout="+ waterfallTimeout +  ", notifyurl=" + notifyurl);
                    waterfallCallback(statusObj);
                    return;
                }

                if(waterfallStepLogged){
                    // outcome for the step is already logged;
                    return;
                }
                waterfallStepLogged = true;

                if(succ){
                    statusObj.status = 'stepSuccess';
                    debug("Waterfall outcome, Step #" + adCount + ": ACCEPTED, type= " + type +", adId=" + id +", timeout="+ waterfallTimeout + ", notifyurl=" + notifyurl);
                    waterfallCallback(statusObj);
                    return;
                }

                if(waterfallTimeoutOccurred){
                    statusObj.status = 'timeout';
                    debug("Waterfall outcome, Step #" + adCount + ": TIMED-OUT, type= " + type +", timeout="+ waterfallTimeout +", ads processed="+ adCount);
                    waterfallCallback(statusObj);
                    return;
                }

                if(errObj){
                    statusObj.status = 'stepFail';
                    debug("Waterfall outcome, Step #" + adCount + ": REJECTED, type= " + type +", adId=" + id +", timeout="+ waterfallTimeout+ ", reason=" + errObj.message);
                    waterfallCallback(statusObj);
                }
            };

            var notifyVastTracking = function(eventName) {
                var vastEvent = notificationEventMapping[eventName];
                if (!vastEvent) {
                    // internal event
                    return;
                }
                options.cbNotification('VAST', vastEvent, options.targetId);

                // remove one time deal events
                if (eventName === "impression" || eventName === "video-complete" || eventName === "video-start") {
                    if (notificationEventMapping.hasOwnProperty(eventName)) {
                        delete notificationEventMapping[eventName];
                    }
                }
            };

            var companionCallback = function(obj) {
                if (!obj || !obj.command || !obj.uniqueId) {
                    return;
                }
                var command = obj.command;
                debug("Companion callback command: " + command + ", unique companion id: " + obj.uniqueId);
                switch(command) {
                    case 'addTrackingEvents': {
                        var companion = obj.data;
                        if (companion) {
                            //prepare tracking manager
                            var unrestrictedEvents = [
                                "error",
                                "creative-view",
                                "companion-click"
                            ];
                            var i;
                            APN_TrackingManager.init(unrestrictedEvents, obj.uniqueId);//set unrestricted event (multiple invokes)
                            if (companion.CompanionClickTracking && companion.CompanionClickTracking.length > 0) {
                                for (i = 0; i < companion.CompanionClickTracking.length; i++) {
                                    APN_TrackingManager.addTrackingEvent("companion-click", companion.CompanionClickTracking[i], obj.uniqueId);
                                }
                            }
                            if (companion.TrackingEvents && companion.TrackingEvents.length > 0) {
                                for (i = 0; i < companion.TrackingEvents.length; i++) {
                                    if (companion.TrackingEvents[i].eventType === 'creativeView') {
                                        // only creativeView event is available for companion
                                        APN_TrackingManager.addTrackingEvent("creative-view", companion.TrackingEvents[i].url, obj.uniqueId);
                                    }
                                }
                            }
                        }
                    }
                        break;
                    case 'requestTracking':	{
                        var eventName = obj.data;
                        if (eventName) {
                            APN_TrackingManager.requestTracking(eventName, obj.uniqueId);
                        }
                    }
                        break;
                }
            };

            //function for handle callback invoke from video player framework
            var cbForHandlingDispatchedEvent = function (eventObject) {

                debug("TM>requesting - dispatch : " + eventObject.name);
                var eventName = eventObject.name;


                //normalizated values in tracking manager
                /*
                 * 	- bid-impression
                 *  - network-request
                 *  - network-response
                 * 	- impression
                 * 	- video-start
                 *  - video-first-quartile
                 *  - video-mid
                 *  - video-third-quartile
                 *  - video-complete
                 *  - ad-click
                 *  - video-pause
                 *  - video-rewind
                 *  - video-resume
                 *  - audio-mute
                 *  - audio-unmute
                 *  - video-fullscreen
                 *  - video-exit-fullscreen
                 *  - creative-view
                 *  - ad-expand
                 *  - ad-collapse
                 *  - user-accept-invitation
                 *  - user-close
                 *  - ad-progress
                 *  - error
                 */
                var evenetMappingForFlash = {
                    "video_start": "video-start",
                    "video_impression": "impression",
                    "video_mute": "audio-mute",
                    "video_click": "video-click",
                    "video_complete": "video-complete",
                    "video_fullscreen": "video-fullscreen",
                    "quartile_event": "quartile-event",
                    "video_pause": "video-pause",
                    "video_unmute": "audio-unmute",
                    "video_failed": "video-failed",
                    "video_time": "video-time",
                    "video_resume": "video-resume",
                    "video_stopped": "video-stopped",
                    "fullscreenchange": "video-fullscreen",
                    "video_skip": "video-skip"
                };
                var invokeEventName = evenetMappingForFlash[eventName];


                //convert flash quartile events
                if (invokeEventName === "quartile-event") {
                    switch (eventObject.quartile) {
                        case 1 :
                            invokeEventName = "video-first-quartile";
                            break;
                        case 2 :
                            invokeEventName = "video-mid";
                            break;
                        case 3 :
                            invokeEventName = "video-third-quartile";
                            break;
                    }
                }


                //handle vast3 full-screen-exit
                if (invokeEventName === "video-fullscreen" && vastVersion === "3.0") {
                    switch (eventObject.fullscreenStatus) {
                        case "enter" :
                            invokeEventName = "video-fullscreen";
                            break;
                        case "exit" :
                            invokeEventName = "video-exit-fullscreen";
                            break;
                        default :
                            invokeEventName = "video-fullscreen";
                            break;
                    }
                }

                //if it's for flash, just use it.
                if (invokeEventName === undefined) {
                    invokeEventName = eventName;
                }

                APN_TrackingManager.requestTracking(invokeEventName, adId);

                if (options.hasOwnProperty('cbNotification')) {
                    notifyVastTracking(invokeEventName);
                }

                if (invokeEventName === "canplay") {
                    if (eventObject.companionAds) {
                        currentVastObj.companionAds = APN_CompanionManager.parse(eventObject.companionAds);
                    }
                }

                if(invokeEventName === "impression"){
                    // waterfall
                    impressionSent = true;
                    if(impCallback && typeof(impCallback) === "function"){
                        impCallback();
                    }
                    if(isWaterfall){
                        if(waterfallTimeoutHandler){
                            clearTimeout(waterfallTimeoutHandler);
                        }
                        printWaterfallLog(false, true);
                        APN_TrackingManager.requestTracking("notifyurl", adId);
                    }
                    // companion support
                    if (currentVastObj.hasOwnProperty('companionAds') && currentVastObj.companionAds.companions.length > 0 &&
                        options.hasOwnProperty('companionContainers')) {
                        companionAdsObj = APN_CompanionManager.renderCompanions(currentVastObj.companionAds, options, companionCallback);
                    }
                }
            };

            //function for registring tracking event based on impbus object
            var fnRegisterTracking = function (vastObject) {

                vastVersion = vastObject.vastVersion;

                //prepare tracking manager
                var unrestrictedEvents = [
                    "video-pause",
                    "video-play",
                    "video-fullscreen",
                    "ad-click",
                    "video-rewind",
                    "video-resume",
                    "audio-mute",
                    "audio-unmute",
                    "video-fullscreen",
                    "video-exit-fullscreen",
                    "ad-expand",
                    "ad-collapse",
                    "ad-progress",
                    "creative-view"
                ];
                APN_TrackingManager.init(unrestrictedEvents, adId);//set unrestricted event (multiple invokes)

                //register all tracking nodes in trackins
                APN_TrackingManager.addTrackingEvents(vastObject.trackingUrls, adId);
                //console.log(vastObject.trackingUrls);

                //register indivisual tracking
                /*
                 elemenet to be handled by
                 vastObject.clickTrackingUrls
                 vastObject.clickUrls
                 vastObject.errorUrls
                 vastObject.impressionUrls
                 vastObject.trackingUrls
                 */


                var cnt;
                var url;

                //handle clickTrackingUrls
                var clickTrackingUrls = vastObject.clickTrackingUrls;
                for (cnt = 0; cnt < clickTrackingUrls.length; cnt++) {
                    url = clickTrackingUrls[cnt];
                    debug("register clickTrackingUrls : " + url);
                    APN_TrackingManager.addTrackingEvent("ad-click", url, adId);//TODO make sure eventname
                }


                //handle errorUrls
                var errorUrls = vastObject.errorUrls;

                for (cnt = 0; cnt < errorUrls.length; cnt++) {
                    url = errorUrls[cnt];
                    debug("register errorUrls  : " + url);
                    APN_TrackingManager.addTrackingEvent("error", url, adId);
                }
                //handle impressionUrls
                var impressionUrls = vastObject.impressionUrls;
                for (cnt = 0; cnt < impressionUrls.length; cnt++) {
                    url = impressionUrls[cnt];
                    debug("register impressionUrls  : " + url);
                    APN_TrackingManager.addTrackingEvent("impression", url, adId);
                }

                //handle Notify URL:
                var notifyUrl = vastObject.notifyurl;
                if(isWaterfall && notifyUrl){
                    debug("register notifyurl  : " + notifyUrl);
                    APN_TrackingManager.addTrackingEvent("notifyurl", notifyUrl, adId);
                }
            };


            var setWaterfallTimeout = function(){
                if(isWaterfall && !waterfallTimeoutHandler){
                    waterfallStartTimestamp = new Date().getTime();
                    waterfallTimeoutHandler = setTimeout(function () {
                        waterfallTimeoutOccurred = true;
                    }, waterfallTimeout);
                }
            };


            //callback to handle a step from vast varser
            var cbHandlingRendition = function (vastObject) {
                var errorDescr;
                try {
                    fnRegisterTracking(vastObject);//regist tracking event
                    APN_RenditionManager.init(vastObject.mediaFiles);
                    var renditionResult = APN_RenditionManager.getUrl(options.width, options.height, null, options);


                    if (renditionResult !== null && renditionResult.success === true) {

                        //expected result from rendtion manager
                        /*
                         renditionResult.bitrate;
                         renditionResult.delivery;
                         renditionResult.width;
                         renditionResult.height;
                         renditionResult.maintainAspectRatio;
                         renditionResult.scalable;
                         renditionResult.type;
                         renditionResult.url;
                         renditionResult.variation;
                         renditionResult.requiredPlayer;//0 - any, 1 - html5, 2 - flash
                         */



                        //define options by result of rendition manager
                        options.video = {};
                        options.video.url = renditionResult.url;

                        options.video.width = renditionResult.width;
                        options.video.height = renditionResult.height;


                        if (renditionResult.maintainAspectRatio && renditionResult.maintainAspectRatio !== undefined) {
                            options.video.maintainAspectRatio = renditionResult.maintainAspectRatio;
                            options.maintainAspectRatio = renditionResult.maintainAspectRatio;
                        } else {
                            options.video.maintainAspectRatio = true;
                            options.maintainAspectRatio = true;
                        }

                        if (renditionResult.scalable && renditionResult.scalable !== undefined) {
                            options.video.scalable = renditionResult.scalable;
                            options.canScale = renditionResult.scalable;
                        } else {
                            options.video.scalable = true;
                            options.canScale = true;
                        }


                        options.video.apiFramework = renditionResult.apiFramework;
                        options.video.type = renditionResult.type;
                        options.requiredPlayer = renditionResult.requiredPlayer;
                        options.videoUrl = renditionResult.url;//TODO refactoricing needed
                        options.clickUrls = vastObject.clickUrls;
                        options.adParameters = vastObject.adParameters;	//TODO check adParams
                        options.extensions = vastObject.extensions;


                        if (options.video.apiFramework && options.video.apiFramework.toLowerCase().indexOf('vpaid') >= 0) {
                            options.vpaid = true;
                        } else {
                            options.vpaid = false;
                        }

                        //redefine width,height for vpaid to give a proper values to Flash wrapper
                        //if (options.vpaid && typeof options.width == "undefined" ) {
                        //    options.width = renditionResult.width;
                        //
                        //}
                        //
                        //if (options.vpaid && typeof options.height == "undefined" ) {
                        //    options.height = renditionResult.height;
                        //}

                        //define target element in publisher page
                        options.targetElement = targetElement;

                        //link dispatch callback
                        cbAdunits.cbForHandlingDispatchedEvent = cbForHandlingDispatchedEvent;

                        //render video
                        cbAdunits.cbRenderVideo(cbAdunits, options, setWaterfallTimeout);

                        isDoneCbHandlingRendition = true;

                        currentVastObj = vastObject;
                        return;
                    } else {
                        isDoneCbHandlingRendition = true;
                        cbAdunits.cbWhenDestroy({
                            type: 1,
                            code: renditionResult.errorCode,
                            message: "Unable to select rendition"
                        });
                        return;
                    }

                } catch (ex) {
                    debug(ex);
                    errorDescr = 'Exception error: ' + ex;
                }
                isDoneCbHandlingRendition = true;
                cbAdunits.cbWhenDestroy({type: 0, code: 0, message: errorDescr});
            };

            var handleNextAd = function(vastObj) {
                isDoneCbHandlingRendition = false;
                if(vastObj){
                    cbHandlingRendition(vastObj);
                }
            };

            var getRtbAd = function(){
                var obj = null;
                if (rtbAd){
                    obj = rtbAd;
                    rtbAd = null;
                } else{
                    obj = vastObjArr.shift();
                }
                return obj;
            };

            var getNextEligibleAd = function(totalNonRtbAttempts){
                var obj = null;
                if(adCount < totalNonRtbAttempts){
                    obj = vastObjArr.shift();
                }else {
                    obj = getRtbAd();
                }
                return obj;
            };

            var getNextAd = function() {
                isDoneCbHandlingRendition = false;
                var vastObj = null;
                if(vastObjArr && isWaterfall){
                    switch (waterfallSteps){
                        case 0:
                            if(adCount === 0){
                                vastObj = vastObjArr.shift();
                                if(!vastObj){
                                    vastObj = getRtbAd();
                                }
                            }
                            break;
                        case -1:
                            vastObj = getNextEligibleAd(maxNonRtbAdCount);
                            break;
                        default:
                            if(waterfallSteps < maxNonRtbAdCount){
                                vastObj = getNextEligibleAd(waterfallSteps);
                            } else {
                                vastObj = getNextEligibleAd(maxNonRtbAdCount);
                            }
                            break;
                    }
                } else {
                    vastObj = vastObjArr.shift();
                }
                currentAd = vastObj;
                adCount++;
                printWaterfallLog(true);
                if(vastObj){
                    adId = vastObj.adId;
                }
                return vastObj;
            };

            var cbHandlingParsedVAST = function (succ, id, vast, errorUrls){

                if (succ) {
                    if (Array.isArray(vast)) {
                        // VID-1861 Disable waterfall when non inline IOS player is used due to autoplay limitation
                        if(!isIos() ||(isIos() && options.enableInlineVideoForIos)){
                            // Ad Waterfall is on.
                            isWaterfall = true;
                            options.isWaterfall = true;
                            vastObjArr = vast;
                            totalAvailableAds = vastObjArr.length;
                            // find Rtb Ad
                            for(var index= 0; index< vastObjArr.length; index++){
                                var obj= vastObjArr[index];
                                if(obj.rtb){
                                    rtbAd = obj;
                                    vastObjArr.splice(index, 1);
                                    break;
                                }
                            }
                            maxNonRtbAdCount = vastObjArr.length;
                        } else{
                            isWaterfall = false;
                            vastObjArr = vast;
                        }
                    } else {
                        isWaterfall = false;
                        vastObjArr.push(vast);
                    }
                    var vastObj = getNextAd();
                    if(vastObj) {
                        handleNextAd(vastObj);
                    }
                }
                else {
                    //if not successful by vast-parser
                    var msg = "Vast Parser error (" + vast + ")";

                    //register error tracking to handle errorUrls if errorUrls returns from vast parser in order to handle internal error happened from vast parser
                    if (errorUrls && errorUrls.length > 0) {
                        errorUrls.forEach(function(url) {
                            debug("register errorUrls  : " + url);
                            APN_TrackingManager.addTrackingEvent("error", url, adId);
                        });
                        cbAdunits.cbWhenDestroy({type: ERROR_TYPE_VAST, code: VAST_ERROR_UNDEFINED, message: msg});
                    } else {
                        cbAdunits.cbWhenDestroy({type: 0, code: 0, message: msg});
                    }

                }
            };


            cbAdunits.cbWhenDestroy = function (errorObject, keepFullscreen, _options) {

                //errorObject.type: type of error (0 = general appnexus error, 1 = vast-error (one of the error codes specified in the VAST spec), 2 = http error
                //errorObject.code: code for identifying error condition
                //errorObject.message: message of error

                if(isWaterfall){
                    if( _options && _options.waterfallStepId !== options.waterfallStepId){
                        return;
                    }
                    options = _options;
                    printWaterfallLog(false, false, errorObject);
                }

                if(isWaterfall && !impressionSent && !waterfallTimeoutOccurred){
                    var nextAd = getNextAd();
                    if(nextAd){
                        handleNextAd(nextAd);
                        return;
                    }
                    // For final error in waterfall we would be requesting notifyurl;
                    APN_TrackingManager.requestTracking("notifyurl", adId);
                }

                if (errorObject && typeof(errorObject.type) !== "undefined") {
                    debug("requesting error in whenDestroy callback : " + errorObject.code + "," + errorObject.type + "," + errorObject.message);
                    // VID-2661 - Decision to not report Errors once Impression is sent(as Vast 3.0 spec says report errors before Ad Load.)
                    // Deferring skipOffset error reporting mentioned in Vast 3.0 TODO: need to decide on that with product
                    if(!impressionSent){
                        APN_TrackingManager.requestErrorTracking(errorObject.code, errorObject.type, errorObject.message, adId);
                    }else{
                        debug("not requesting error tracker because the Ad Impression was already reported");
                    }
                } else {
                    debug("requesting error in whenDestroy callback : " + errorObject + "," + (errorObject ? true : false));
                }

                if (companionAdsObj) {
                    APN_CompanionManager.stopCompanions(companionAdsObj);
                    companionAdsObj = null;
                }

                //invoke override whenDestory callback
                if (typeof(tmpCallback) === "function") {
                    tmpCallback(errorObject ? errorObject : false, keepFullscreen);
                }
            };

            //get value from vastXM to decide video URL
            if (options !== undefined && options && options.vastXml) {


                setTimeout(function () {
                    if (!isDoneCbHandlingRendition) {
                        cbAdunits.cbWhenDestroy({type: 0, code: 0, message: "VAST Parser didn't answer until timeout"});
                    }

                }, timeToWaitFor);
                debug("Ad XML : " + options.vastXml);
                APNVideo_VastParser.parse(options.vastXml, cbHandlingParsedVAST, null, 2000, null, null, options);

            }

            //get value from adObj to decide video URL
            if (options !== undefined && options && options.useAdObj && options.adObj) {
                cbHandlingRendition(options.adObj);
            }
        };


        /***/ },
    /* 29 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * VAST Parser module.
         * @module VastParser
         */

        var VastXMLParserHelper = function () {
            this.getSubNodes = function (node, subNodeName) {
                var nodes = node.getElementsByTagName(subNodeName);
                if (nodes.length > 0) {
                    return nodes;
                }
                return null;
            };

            this.getSubNode = function (node, subNodeName, index) {
                if (!index) {
                    index = 0;
                }
                var nodes = node.getElementsByTagName(subNodeName);
                if (nodes.length > index) {
                    return nodes[index];
                }
                return null;
            };

            this.getNodeValue = function (node) {
                if (node.childNodes.length === 0) {
                    return '';
                }
                var val = node.childNodes[0].nodeValue;
                return val.trim();
            };

            this.getNodeValues = function (node) {
                if (node.childNodes.length === 0) {
                    return '';
                }
                var wholeVal = '';
                for (var i = 0; i < node.childNodes.length; i++) {
                    var val = node.childNodes[i].nodeValue;
                    wholeVal += val;
                }
                return wholeVal.trim();
            };

            this.getNodeAttributeValue = function (node, attributeName) {
                var val = node.getAttribute(attributeName);
                if (val === null) {
                    val = '';
                }
                return val;
            };

            this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
                if (!defaultValue) {
                    defaultValue = 0;
                }
                var answer = defaultValue;
                var val = this.getNodeAttributeValue(node, attributeName);

                if (val.length > 0) {
                    if (val.indexOf('.') >= 0) {
                        answer = parseFloat(val);
                    }
                    else {
                        answer = parseInt(val);
                    }
                }

                return answer;
            };

            this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
                if (!defaultValue) {
                    defaultValue = false;
                }
                var answer = defaultValue;
                var val = this.getNodeAttributeValue(node, attributeName);

                if (val.length > 0) {
                    var char = val.toLowerCase().charAt(0);
                    answer = (char === 't');
                }

                return answer;
            };

            this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
                defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
                var subnode = this.getSubNode(parentNode, subNodeName);
                if (subnode !== null) {
                    return this.getNodeValue(subnode);
                }
                return defaultValue;
            };

            this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
                defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
                var subnode = this.getSubNode(parentNode, subNodeName);
                if (subnode !== null) {
                    return this.getNodeValues(subnode);
                }
                return defaultValue;
            };

            this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
                defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

                var value = this.getSubNodeValue(parentNode, subNodeName);
                if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
                    return true;
                }
                if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
                    return false;
                }
                return defaultValue;
            };
        };

        var APN_CompanionAds = __webpack_require__(30);
        var APN_Icons = __webpack_require__(31);
        var VastParser = function(id, nMsecTimeout, options) {

            var _logger = __webpack_require__(2);
            var _prefix = 'VAST Parser';

            var _callback = null;
            var _options = options;
            var _sourceVastXml = null;
            var _id = id;
            var _nTimeOut = nMsecTimeout && nMsecTimeout > 0 ? nMsecTimeout : 1000;	// 1 second default
            var _arrMediaFiles = [],
                _arrTrackings = {},
                _arrImpressions = [],
                _arrClickUrls = [],
                _arrClickTrackings = [],
                _arrErrorUrls = [],
                _arrInternalErrorUrls = [],
                _sExtensions = '',
                _adParameters = '',
                _nMsecDuration = 0,
                _nMsecSkipOffset = 0;

            var _arrTrackingsMerge = {},
                _arrImpressionsMerge = [],
                _arrClickUrlsMerge = [],
                _arrClickTrackingsMerge = [],
                _arrErrorUrlsMerge = [];

            var _helper = new VastXMLParserHelper();
            var _startTime = null;
            var _withWrapper = false;
            var _vastVersion = '';

            var _adTree = [];
            var _currTreeIdx = -1;

            var _terminated = false;

            var _capabilityDetection = __webpack_require__(32);

            var _waterfall = false;
            var _vastObjects = [];
            var _topLevel = false;
            var _notifyurls = {};
            var _curNotifyUrl = '';
            var _buyerMemberIds = {};
            var _curBuyerMemberId = '';

            var _csmCount = 0;
            var _rtbCount = 0;

            _logger.always(_prefix, 'Version 1.1.14');

            function getVASTVersion(vastNode) {
                var version = 'unknown';
                if (vastNode) {
                    version = _helper.getNodeAttributeValue(vastNode, 'version');
                    version = version.trim();
                    if (version.length > 3) {
                        version = version.substr(0, 3);
                    }
                }
                return version;
            }

            function substituteErrorCode(arrErrorUrls, errorCode) {
                if (arrErrorUrls && arrErrorUrls.length > 0) {
                    for (var i = 0; i < arrErrorUrls.length; i++) {
                        arrErrorUrls[i] = arrErrorUrls[i].replace('[ERRORCODE]', errorCode);
                    }
                }
            }

            function traceTreePath(idx, message) {
                var curIdx = idx;
                var text = 'AD DETECTED=' + (message.substr(0,7) === 'SUCCESS' ? 'SUCCESS' : 'NONE') + ' :: Reason=' + message +
                    ', playerTechnology=' + (_options.hasOwnProperty('playerTechnology') ? JSON.stringify(_options.playerTechnology) : 'unknown') +
                    ', platform=' + _capabilityDetection.getPlatformType() + ', Ad tree path=';
                var tree = '';
                while (curIdx !== -1) {
                    var ad = _adTree[curIdx].children[0];
                    if (ad) {
                        var val = _helper.getNodeAttributeValue(ad, 'id');
                        if (tree.length > 0) {
                            tree = ' -> ' + tree;
                        }
                        tree = val + tree;
                    }
                    curIdx = _adTree[curIdx].parentIdx;
                }
                _logger.info(_prefix, text + tree);
            }

            function processWrapper(parentNode) {
                var node = _helper.getSubNode(parentNode, 'VASTAdTagURI');
                if (!node) {
                    traceTreePath(_currTreeIdx, 'INVALID WRAPPER NODE');
                    if (_adTree.length === 0) {
                        reportError('300', 'invalid wrapper node');
                    }
                    else {
                        processNextAd();
                    }
                    return;
                }
                var url = _helper.getNodeValues(node);
                if (!url || url.length === 0) {
                    traceTreePath(_currTreeIdx, 'EMPTY VASTAdTagURI');
                    if (_adTree.length === 0) {
                        reportError('300', 'Invalid VASTAdTagURI node value');
                    }
                    else {
                        processNextAd();
                    }
                    return;
                }

                if (_terminated) {
                    traceTreePath(_currTreeIdx, 'terminated');
                    _callback(false, _id, 'terminated', null);		// terminated
                    return;
                }

                _withWrapper = true;

                var UrlLoader = __webpack_require__(33);
                UrlLoader.load(url,
                    function(error, responseText) {
                        if (_terminated) {
                            traceTreePath(_currTreeIdx, 'terminated');
                            _callback(false, _id, 'terminated', null);		// terminated
                            return;
                        }
                        if (error || responseText.length === 0) {
                            traceTreePath(_currTreeIdx, 'VASTAdTagURI TIMED OUT: ' + url);
                            if (_adTree.length === 0) {
                                reportError('301', 'Timeout of VAST URI provided in wrapper element');
                            }
                            else {
                                processNextAd();
                            }
                        }
                        else {
                            _topLevel = false;
                            parseXML(responseText);
                        }
                    }, _nTimeOut);
            }

            function isInArray(arr, value) {
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] === value) {
                        return true;
                    }
                }
                return false;
            }

            function addErrorUrls(parentNode, arrErrorUrls) {
                if (parentNode) {
                    var nodes = _helper.getSubNodes(parentNode, 'Error');
                    if (nodes) {
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            var url = _helper.getNodeValues(node);
                            if (url && !isInArray(arrErrorUrls, url)) {
                                arrErrorUrls.push(url);
                            }
                        }
                    }
                }
            }

            function addImpressions(parentNode, arrImpressions) {
                if (parentNode) {
                    var nodes = _helper.getSubNodes(parentNode, 'Impression');
                    if (nodes) {
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            var url = _helper.getNodeValues(node);
                            if (url && !isInArray(arrImpressions, url)) {
                                arrImpressions.push(url);
                            }
                        }
                    }
                }
            }

            function addTrackings(parentNode, arrTrackings) {
                if (parentNode) {
                    var linear = _helper.getSubNode(parentNode, 'Linear', 0);
                    if (linear) {
                        var node = _helper.getSubNode(linear, 'TrackingEvents');
                        if (node) {
                            var nodes = _helper.getSubNodes(node, 'Tracking');
                            if (nodes) {
                                for (var i = 0; i < nodes.length; i++) {
                                    node = nodes[i];
                                    var url = _helper.getNodeValues(node);
                                    if (url) {
                                        var event = _helper.getNodeAttributeValue(node, 'event');
                                        if (arrTrackings.hasOwnProperty(event)) {
                                            if (!isInArray(arrTrackings[event], url)) {
                                                arrTrackings[event].push(url);
                                            }
                                        }
                                        else {
                                            arrTrackings[event] = [];
                                            arrTrackings[event].push(url);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function addExtensions(parentNode, treeIdx) {
                if (parentNode) {
                    var node = _helper.getSubNode(parentNode, 'Extensions');
                    if (node && node.innerHTML && node.innerHTML.length > 0) {
                        _adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.innerHTML.toString();
                    }
                }
            }

            function addCompanions(parentNode, treeIdx) {
                if (parentNode) {
                    var node = _helper.getSubNode(parentNode, 'CompanionAds');
                    if (node &&
                        ((node.innerHTML && node.innerHTML.length > 0) ||
                        (node.textContent && node.textContent.length > 0))) {
                        APN_CompanionAds.parse(_adTree[treeIdx].state.companions, node, _helper);
                    }
                }
            }

            function addIcons(parentNode, treeIdx) {
                if (parentNode) {
                    var node = _helper.getSubNode(parentNode, 'Icons');
                    if (node && node.innerHTML && node.innerHTML.length > 0) {
                        APN_Icons.parse(_adTree[treeIdx].state.icons, node, _helper);
                    }
                }
            }

            function addClickUrls(parentNode, arrClickUrls, arrClickTrackings) {
                if (parentNode) {
                    var linear = _helper.getSubNode(parentNode, 'Linear', 0);
                    if (linear) {
                        var url = null;
                        var parentNode2 = _helper.getSubNode(linear, 'VideoClicks');
                        if (parentNode2) {
                            var node = _helper.getSubNode(parentNode2, 'ClickThrough');
                            if (node) {
                                url = _helper.getNodeValues(node);
                                if (url && !isInArray(arrClickUrls, url)) {
                                    arrClickUrls.push(url);
                                }
                            }
                            var nodes = _helper.getSubNodes(parentNode2, 'ClickTracking');
                            if (nodes) {
                                for (var i = 0; i < nodes.length; i++) {
                                    node = nodes[i];
                                    url = _helper.getNodeValues(node);
                                    if (url && !isInArray(arrClickTrackings, url)) {
                                        arrClickTrackings.push(url);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function getMsecTime(strTime, duration) {
                var nPos = strTime.indexOf('%');
                if (nPos > 0) {
                    if (duration && duration > 0) {
                        return Number(strTime.substring(0, nPos));
                    }
                    else {
                        return 0;
                    }
                } else {
                    nPos = strTime.indexOf('.');
                    var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1)) : 0;
                    if (nPos > 0) {
                        strTime = strTime.substring(0, nPos);
                    }
                    var arr = strTime.split(':');
                    if (arr.length === 3) {
                        return (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
                    }
                    else {
                        return 0;
                    }
                }
            }

            function isCapable(type, codec) {
                return _capabilityDetection.canPlay(type, codec);
            }

            function isFlashOnlyType(type) {
                return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
                    type === 'application/x-shockwave-flash';
            }

            function isHtml5OnlyType(type) {
                return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
                    type === 'application/x-javascript';
            }

            function isVpaidType(type) {
                return type === 'application/x-shockwave-flash' || type === 'application/javascript' ||
                    type === 'application/x-javascript';
            }

            function isOptionsValidated(type) {
                if (_options.playerTechnology && Array.isArray(_options.playerTechnology) && _options.playerTechnology.length > 0) {
                    var supported = false;
                    for (var i = 0; i < _options.playerTechnology.length; i++) {
                        var tech = _options.playerTechnology[i].toLowerCase();
                        if (!isFlashOnlyType(type.toLowerCase()) && !isHtml5OnlyType(type.toLowerCase())) {
                            supported = true;
                            break;
                        }
                        if (tech === 'flash' && !isHtml5OnlyType(type.toLowerCase())) {
                            supported = true;
                            break;
                        }
                        if (tech === 'html5' && !isFlashOnlyType(type.toLowerCase())) {
                            supported = true;
                            break;
                        }
                    }
                    if (!supported) {
                        return false;
                    }
                }
                if (_options.hasOwnProperty('supportVpaid') && !_options.supportVpaid) {
                    if (isVpaidType(type.toLowerCase())) {
                        return false;
                    }
                }
                return true;
            }

            function configureMediaRendition(node, url, num, mediaTypes) {
                var rendition = null;
                if (node) {
                    rendition = {};
                    rendition.type = _helper.getNodeAttributeValue(node, 'type');
                    if (mediaTypes.indexOf(rendition.type) === -1) {
                        mediaTypes.push(rendition.type);
                    }
                    // check capability
                    if (!rendition.type || rendition.type.length === 0) {
                        return null;
                    }
                    var codec = _helper.getNodeAttributeValue(node, 'codec');
                    if (codec && codec.length > 0) {
                        rendition.codec = codec;
                    }
                    if (!isCapable(rendition.type, codec)) {
                        return null;
                    }
                    if (_options) {
                        if (!isOptionsValidated(rendition.type)) {
                            return null;
                        }
                    }
                    rendition.url = url;
                    rendition.variation = 'Media#' + num;
                    rendition.delivery = _helper.getNodeAttributeValue(node, 'delivery');
                    var bitrate = _helper.getNodeAttributeNumberValue(node, 'bitrate', -1);
                    if (bitrate !== -1) {
                        rendition.bitrate = bitrate;
                    }
                    rendition.width = _helper.getNodeAttributeNumberValue(node, 'width');
                    rendition.height = _helper.getNodeAttributeNumberValue(node, 'height');
                    var valNode = _helper.getNodeAttributeValue(node, 'scalable');
                    if (valNode.length > 0) {
                        rendition.scalable = _helper.getNodeAttributeBooleanValue(node, 'scalable', true);
                    }
                    valNode = _helper.getNodeAttributeValue(node, 'maintainAspectRatio');
                    if (valNode.length > 0) {
                        rendition.maintainAspectRatio = _helper.getNodeAttributeBooleanValue(node, 'maintainAspectRatio', true);
                    }
                    var apiFramework = _helper.getNodeAttributeValue(node, 'apiFramework');
                    if (apiFramework && apiFramework.length > 0) {
                        rendition.apiFramework = apiFramework.toUpperCase();
                    }
                }

                return rendition;
            }

            function addMediaFilesAndDuration(parentNode) {
                _nMsecDuration = 0;
                _nMsecSkipOffset = 0;
                _adParameters = '';
                _arrMediaFiles = [];
                var message = '';
                var mediaTypes = [];
                if (parentNode) {
                    var linear = _helper.getSubNode(parentNode, 'Linear', 0);
                    if (linear) {
                        var node = _helper.getSubNode(linear, 'Duration');
                        if (node) {
                            var str = _helper.getNodeValue(node);
                            _nMsecDuration = getMsecTime(str, -1);
                        }
                        var strSkipOffset = _helper.getNodeAttributeValue(linear, 'skipoffset');
                        if (strSkipOffset && strSkipOffset.length > 0) {
                            _nMsecSkipOffset = getMsecTime(strSkipOffset, _nMsecDuration);
                        }
                        //_adParameters = _helper.getSubNodeValue(linear, 'AdParameters', '');
                        _adParameters = _helper.getSubNodeWholeValue(linear, 'AdParameters', '');

                        node = _helper.getSubNode(linear, 'MediaFiles');
                        if (node) {
                            var nodes = _helper.getSubNodes(node, 'MediaFile');
                            if (nodes) {
                                for (var i = 0; i < nodes.length; i++) {
                                    node = nodes[i];
                                    var url = _helper.getNodeValues(node);

                                    if (url.length > 0) {
                                        var rendition = configureMediaRendition(node, url, i, mediaTypes);

                                        if (rendition) {
                                            _arrMediaFiles.push(rendition);
                                        }
                                    }
                                }
                                if (_arrMediaFiles.length === 0) {
                                    message = 'INCOMPATIBLE MEDIA TYPE, Available = ' + JSON.stringify(mediaTypes);
                                }
                            }
                            else {
                                message = 'MISSING MEDIA FILES';
                            }
                        }
                        else {
                            message = 'MISSING MEDIA FILES';
                        }
                    }
                    else {
                        message = 'INVALID VAST STRUCTURE';
                    }
                }
                return message;
            }

            function trimXml(strVastXml) {
                var nPos = strVastXml.indexOf('<');
                var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
                nPos = strXml.lastIndexOf('>');
                if (nPos !== -1) {
                    strXml = strXml.substr(0, nPos + 1);
                }
                return strXml.trim();
            }

            function isValidVastVersion(vastVersion) {
                return vastVersion === '2.0' || vastVersion === '3.0';
            }

            function reportError(errCode, message) {
                var arrErrorForInternalAndExternal = _arrErrorUrls.concat(_arrInternalErrorUrls);//merge with internal error and external error
                substituteErrorCode(arrErrorForInternalAndExternal, errCode);
                _logger.error(_prefix, 'Error ' + errCode + ' - ' + message);
                _callback(false, _id, 'vast' + errCode, arrErrorForInternalAndExternal);
            }

            function processNextAd() {

                //push error urls to global variable _arrInternalErrorUrls which has empty array as an default, it will be used for reportError() to return array of error urls to _callback
                //the _arrInternalErrorUrls will be emptied by processAd() when exit out of siblings and if there's no internal parsing error
                var arrStateOfNode = _adTree[_currTreeIdx].state;
                if (arrStateOfNode && Array.isArray(arrStateOfNode.arrErrorUrls)) {
                    arrStateOfNode.arrErrorUrls.forEach(function(element) {
                        _arrInternalErrorUrls.push(element);
                    });
                }

                if (_currTreeIdx >= 0) {
                    _adTree[_currTreeIdx].children[0] = null;
                    _adTree[_currTreeIdx].children.splice(0, 1);
                    if (_adTree[_currTreeIdx].children.length === 0) {
                        var parentIdx = _adTree[_currTreeIdx].parentIdx;
                        _adTree.splice(_currTreeIdx, 1);
                        _currTreeIdx = parentIdx;
                        if (_currTreeIdx === -1) {
                            if (_waterfall && _vastObjects.length > 0) {
                                _logger.info(_prefix, 'Waterfall: Vast XML node count detected: # csm nodes: ' + _csmCount + ', # rtb nodes: ' + _rtbCount);
                                _callback(true, _id, _vastObjects, null);
                            }
                            else {
                                reportError('900', 'no Ad available');
                            }
                            return;
                        }
                        else {
                            processNextAd();
                            return;
                        }
                    }
                    _adTree[_currTreeIdx].state = preapareAdStateData();
                    processAd(_adTree[_currTreeIdx].children[0]);
                }
            }

            function preapareAdStateData() {
                var state = {
                    arrTrackings: {},
                    arrImpressions: [],
                    arrClickUrls: [],
                    arrClickTrackings: [],
                    arrErrorUrls: [],
                    sExtensions: '',
                    sequence: 1,
                    companions: {required: 'unknown', companions: []},
                    icons: []
                };
                return state;
            }

            function saveNotificationUrl(adNode) {
                var id = _helper.getNodeAttributeValue(adNode, 'id');
                if (id.length > 0) {
                    var url = _helper.getNodeAttributeValue(adNode, 'notifyurl');
                    if (url && url.length > 0) {
                        _notifyurls[id] = url;
                    }
                }
            }

            function saveBuyerMemberId(adNode) {
                var id = _helper.getNodeAttributeValue(adNode, 'id');
                if (id.length > 0) {
                    var buyerId = _helper.getNodeAttributeValue(adNode, 'buyerMemberId');
                    if (buyerId && buyerId.length > 0) {
                        _buyerMemberIds[id] = buyerId;
                    }
                }
            }

            function parseXML(strVastXml) {
                _startTime = (new Date()).getTime();

                _sourceVastXml = strVastXml;
                var strXml = trimXml(strVastXml);
                if (strXml.length === 0) {
                    traceTreePath(_currTreeIdx, 'EMPTY VAST');
                    if (_adTree.length === 0) {
                        reportError('110', 'no bid response for mediation');
                    }
                    else {
                        processNextAd();
                    }
                    return;
                }
                var xmlDoc = null;
                if (typeof window.DOMParser !== 'undefined') {
                    xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
                    if (xmlDoc.documentElement.nodeName === 'parsererror') {
                        try{
                            _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
                        }
                        catch(e) {}
                        traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
                        if (_adTree.length === 0) {
                            reportError('100', 'VAST XML parsing error');
                        }
                        else {
                            processNextAd();
                        }
                        return;
                    }
                }
                else if (typeof window.ActiveXObject !== 'undefined') {
                    try {
                        xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
                        xmlDoc.loadXML(strXml);
                        if (xmlDoc.parseError.errorCode !== 0) {
                            _logger.error(_prefix, xmlDoc.parseError);
                            traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
                            if (_adTree.length === 0) {
                                reportError('100', xmlDoc.parseError.errorCode + ', Error reason = ' + xmlDoc.parseError.reason);
                            }
                            else {
                                processNextAd();
                            }
                            return;
                        }
                    }
                    catch (ex) {
                        _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
                        traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
                        if (_adTree.length === 0) {
                            reportError('100', 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
                        }
                        else {
                            processNextAd();
                        }
                        return;
                    }
                }
                else {
                    _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
                    traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
                    if (_adTree.length === 0) {
                        reportError('100', 'Failed to get vast xml');
                    }
                    else {
                        processNextAd();
                    }
                    return;
                }
                if (!xmlDoc) {
                    traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
                    if (_adTree.length === 0) {
                        reportError('102', 'VAST XML parsing error');
                    }
                    else {
                        processNextAd();
                    }
                    return;
                }
                var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
                if (!vastNode) {
                    traceTreePath(_currTreeIdx, 'EMPTY VAST');
                    if (_adTree.length === 0) {
                        reportError('110', 'no bid response for mediation');
                    }
                    else {
                        processNextAd();
                    }
                    return;
                }

                var vastVersion = getVASTVersion(vastNode);
                if (isValidVastVersion(vastVersion)) {
                    if (_topLevel) {
                        _waterfall = _helper.getNodeAttributeBooleanValue(vastNode, 'apn_waterfall');
                        if (_waterfall) {
                            _options.waterfall = true;
                        }
                    }
                    var ads = _helper.getSubNodes(vastNode, 'Ad');
                    if (!ads || ads.length === 0) {
                        traceTreePath(_currTreeIdx, 'NO AD NODE');
                        if (_adTree.length === 0) {
                            reportError('900', 'no Ad available');
                        }
                        else {
                            processNextAd();
                        }
                        return;
                    }
                    var children = [];
                    for (var i = 0; i < ads.length; i++) {
                        children.push(ads[i]);
                        if (_waterfall && _topLevel) {
                            saveNotificationUrl(ads[i]);
                        }
                        if (_topLevel) {
                            saveBuyerMemberId(ads[i]);
                        }
                    }
                    var treeElem = {parentIdx: _currTreeIdx, currentIdx: 0, children: children, state: preapareAdStateData()};
                    _adTree.push(treeElem);
                    treeElem.currentIdx = _adTree.length - 1;
                    _currTreeIdx = treeElem.currentIdx;
                    processAd(_adTree[_currTreeIdx].children[0], vastVersion);
                }
                else {
                    traceTreePath(_currTreeIdx, 'INVALID VAST VERSION: ' + vastVersion);
                    if (_adTree.length === 0) {
                        reportError('102', 'VAST version not supported');
                    }
                    else {
                        processNextAd();
                    }
                }
            }

            function mergeTrackings(idx) {
                for (var event in _adTree[idx].state.arrTrackings) {
                    for (var i = 0; i < _adTree[idx].state.arrTrackings[event].length; i++) {
                        if (_arrTrackingsMerge.hasOwnProperty(event)) {
                            if (!isInArray(_arrTrackingsMerge[event], _adTree[idx].state.arrTrackings[event][i])) {
                                _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
                            }
                        }
                        else {
                            _arrTrackingsMerge[event] = [];
                            _arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
                        }
                    }
                }
                return _arrTrackingsMerge;
            }

            function mergeTreeTrackings(treeIdx) {
                var idx = treeIdx;
                while (idx >= 0) {
                    mergeTrackings(idx);
                    idx = _adTree[idx].parentIdx;
                }
                return _arrTrackingsMerge;
            }

            function mergeImpressions(idx) {
                for (var i = 0; i < _adTree[idx].state.arrImpressions.length; i++) {
                    if (!isInArray(_arrImpressionsMerge, _adTree[idx].state.arrImpressions[i])) {
                        _arrImpressionsMerge.push(_adTree[idx].state.arrImpressions[i]);
                    }
                }
                return _arrImpressionsMerge;
            }

            function mergeTreeImpressions(treeIdx) {
                var idx = treeIdx;
                while (idx >= 0) {
                    mergeImpressions(idx);
                    idx = _adTree[idx].parentIdx;
                }
                return _arrImpressionsMerge;
            }

            function mergeClickUrls(idx) {
                for (var i = 0; i < _adTree[idx].state.arrClickUrls.length; i++) {
                    if (!isInArray(_arrClickUrlsMerge, _adTree[idx].state.arrClickUrls[i])) {
                        _arrClickUrlsMerge.push(_adTree[idx].state.arrClickUrls[i]);
                    }
                }
                return _arrClickUrlsMerge;
            }

            function mergeTreeClickUrls(treeIdx) {
                var idx = treeIdx;
                while (idx >= 0) {
                    mergeClickUrls(idx);
                    idx = _adTree[idx].parentIdx;
                }
                return _arrClickUrlsMerge;
            }

            function mergeClickTrackings(idx) {
                for (var i = 0; i < _adTree[idx].state.arrClickTrackings.length; i++) {
                    if (!isInArray(_arrClickTrackingsMerge, _adTree[idx].state.arrClickTrackings[i])) {
                        _arrClickTrackingsMerge.push(_adTree[idx].state.arrClickTrackings[i]);
                    }
                }
                return _arrClickTrackingsMerge;
            }

            function mergeTreeClickTrackings(treeIdx) {
                var idx = treeIdx;
                while (idx >= 0) {
                    mergeClickTrackings(idx);
                    idx = _adTree[idx].parentIdx;
                }
                return _arrClickTrackingsMerge;
            }

            function mergeErrorUrls(idx) {
                for (var i = 0; i < _adTree[idx].state.arrErrorUrls.length; i++) {
                    if (!isInArray(_arrErrorUrlsMerge, _adTree[idx].state.arrErrorUrls[i])) {
                        _arrErrorUrlsMerge.push(_adTree[idx].state.arrErrorUrls[i]);
                    }
                }
                return _arrErrorUrlsMerge;
            }

            function mergeTreeErrorUrls(treeIdx) {
                var idx = treeIdx;
                while (idx >= 0) {
                    mergeErrorUrls(idx);
                    idx = _adTree[idx].parentIdx;
                }
                return _arrErrorUrlsMerge;
            }

            function mergeExtensions(idx) {
                if (_adTree[idx].state.sExtensions.length > 0) {
                    _sExtensions = _sExtensions + _adTree[idx].state.sExtensions;
                }
                return _sExtensions;
            }

            function mergeTreeExtensions(treeIdx) {
                var idx = treeIdx;
                while (idx >= 0) {
                    mergeExtensions(idx);
                    idx = _adTree[idx].parentIdx;
                }
                return _sExtensions;
            }

            function mergeCompanions(treeIdx) {
                var idx = treeIdx;
                while (idx > 0) {
                    var parentIdx = _adTree[idx].parentIdx;
                    APN_CompanionAds.mergeCompanions(_adTree[parentIdx].state.companions, _adTree[idx].state.companions);
                    idx = parentIdx;
                }
                if (_adTree[idx].state.companions.required === 'unknown') {
                    delete _adTree[idx].state.companions.required;
                }
                return _adTree[idx].state.companions;
            }

            function mergeTreeCompanions(treeIdx) {
                var arrCompanions = {required: 'unknown', companions: []};
                var idx = treeIdx;
                while (idx >= 0) {
                    APN_CompanionAds.mergeCompanions(arrCompanions, _adTree[idx].state.companions);
                    idx = _adTree[idx].parentIdx;
                }
                return arrCompanions;
            }

            function isProgramExist(arrIcons, program) {
                for (var i = 0; i < arrIcons.length; i++) {
                    if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
                        return true;
                    }
                }
                return false;
            }

            function removeProgram(arrIcons, program) {
                for (var i = 0; i < arrIcons.length; i++) {
                    if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
                        arrIcons[i].splice(i, 1);
                        return;
                    }
                }
            }

            function mergeIcons(treeIdx) {
                var idx = treeIdx;
                while (idx > 0) {
                    var parentIdx = _adTree[idx].parentIdx;
                    for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
                        // avoid duplicate icons with same program (replace if exist)
                        if (isProgramExist(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program)) {
                            removeProgram(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program);
                        }
                        _adTree[parentIdx].state.icons.push(_adTree[idx].state.icons[i]);
                    }
                    idx = parentIdx;
                }
                return _adTree[idx].state.icons;
            }

            function mergeTreeIcons(treeIdx) {
                var arrIcons = [];
                var idx = treeIdx;
                while (idx >= 0) {
                    for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
                        // avoid duplicate icons with same program
                        if (!isProgramExist(arrIcons, _adTree[idx].state.icons[i].program)) {
                            arrIcons.push(_adTree[idx].state.icons[i]);
                        }
                    }
                    idx = _adTree[idx].parentIdx;
                }
                return arrIcons;
            }

            function aggregateCompanions(companionsObj) {
                // get companions with resources and without resorces
                var resCompanions = [];
                var noresCompanions = [];
                var companions = companionsObj.companions;
                if (!companionsObj.companions) {
                    return companionsObj;
                }
                var companion;
                var i, j;
                for (i = companions.length - 1; i >= 0; i--) {
                    companion = companions[i];
                    if (companion.StaticResource || companion.IFrameResource || companion.HTMLResource) {
                        var sameSize = false;
                        for (j = 0; j < resCompanions.length; j++) {
                            if (companion.width === resCompanions[j].width &&
                                companion.height === resCompanions[j].height) {
                                sameSize = true;
                                break;
                            }
                        }
                        if (!sameSize) {
                            resCompanions.push(companion);
                        }
                    }
                    else {
                        noresCompanions.push(companion);
                    }
                }

                // aggregate companions without resorces into companions with resources
                for (i = 0; i < noresCompanions.length; i++) {
                    for (j = 0; j < resCompanions.length; j++) {
                        if (noresCompanions[i].width === resCompanions[j].width && noresCompanions[i].height === resCompanions[j].height) {
                            if ((noresCompanions[i].id && noresCompanions[i].id === resCompanions[j].id) ||	(!noresCompanions[i].id)) {
                                // add click trackings
                                if (noresCompanions[i].CompanionClickTracking) {
                                    if (!resCompanions[j].CompanionClickTracking) {
                                        resCompanions[j].CompanionClickTracking = [];
                                    }
                                    resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(noresCompanions[i].CompanionClickTracking);
                                }
                                // add view trackings
                                if (noresCompanions[i].TrackingEvents) {
                                    if (!resCompanions[j].TrackingEvents) {
                                        resCompanions[j].TrackingEvents = [];
                                    }
                                    resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(noresCompanions[i].TrackingEvents);
                                }
                            }
                        }
                    }
                }
                var ret = {companions: resCompanions};
                if (companionsObj.required) {
                    ret.required = companionsObj.required;
                }
                return ret;
            }

            function processAd(adNode, vastVersion) {
                var inLineWrapperNode = _helper.getSubNode(adNode, 'Wrapper');
                var isWrapper = inLineWrapperNode !== null;
                if (!isWrapper) {
                    inLineWrapperNode = _helper.getSubNode(adNode, 'InLine');
                }
                if (!inLineWrapperNode) {
                    traceTreePath(_currTreeIdx, 'MISSING WRAPPER / INLINE NODE');
                    processNextAd();
                    return;
                }

                if (vastVersion > _vastVersion) {
                    _vastVersion = vastVersion;
                }

                var id = _helper.getNodeAttributeValue(adNode, 'id');
                if (_notifyurls.hasOwnProperty(id)) {
                    _curNotifyUrl = _notifyurls[id];
                }
                if (_buyerMemberIds.hasOwnProperty(id)) {
                    _curBuyerMemberId = _buyerMemberIds[id];
                }
                // worried only about top level ad sequence attribute
                if (_currTreeIdx === 0) {
                    var seq = _helper.getNodeAttributeValue(adNode, 'sequence');
                    if (seq) {
                        _adTree[_currTreeIdx].state.sequence = Number.parseInt(seq);
                    }
                }

                addErrorUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrErrorUrls);
                addImpressions(inLineWrapperNode, _adTree[_currTreeIdx].state.arrImpressions);
                addTrackings(inLineWrapperNode, _adTree[_currTreeIdx].state.arrTrackings);
                addClickUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrClickUrls, _adTree[_currTreeIdx].state.arrClickTrackings);
                addExtensions(inLineWrapperNode, _currTreeIdx);
                addCompanions(inLineWrapperNode, _currTreeIdx);
                addIcons(inLineWrapperNode, _currTreeIdx);

                _arrInternalErrorUrls = [];//clear _arrInternalErrorUrls at this time, all same sibiling's error will be gathered by processNextAd()

                if (isWrapper) {
                    processWrapper(inLineWrapperNode);
                }
                else {
                    var message = addMediaFilesAndDuration(inLineWrapperNode);
                    if (_arrMediaFiles.length === 0 || message.length > 0) {
                        traceTreePath(_currTreeIdx, message);
                        processNextAd();
                        return;
                    }
                    _arrTrackingsMerge = JSON.parse(JSON.stringify(_arrTrackings));
                    _arrImpressionsMerge = _arrImpressions.slice(0);
                    _arrClickUrlsMerge = _arrClickUrls.slice(0);
                    _arrClickTrackingsMerge = _arrClickTrackings.slice(0);
                    _arrErrorUrlsMerge = _arrErrorUrls.slice(0);
                    _sExtensions = '';

                    var strTrackingUrls = JSON.stringify(mergeTreeTrackings(_adTree[_currTreeIdx].parentIdx));
                    var strImpressionUrls = JSON.stringify(mergeTreeImpressions(_adTree[_currTreeIdx].parentIdx));
                    var strClickUrls = JSON.stringify(mergeTreeClickUrls(_adTree[_currTreeIdx].parentIdx));
                    var strClickTrackingUrls = JSON.stringify(mergeTreeClickTrackings(_adTree[_currTreeIdx].parentIdx));
                    var strErrorUrls = JSON.stringify(mergeTreeErrorUrls(_adTree[_currTreeIdx].parentIdx));
                    var strExtensions = mergeTreeExtensions(_adTree[_currTreeIdx].parentIdx);
                    var strCompanions = JSON.stringify(mergeTreeCompanions(_adTree[_currTreeIdx].parentIdx));
                    var strIcons = JSON.stringify(mergeTreeIcons(_adTree[_currTreeIdx].parentIdx));
                    _sExtensions = '';
                    var companions = mergeCompanions(_currTreeIdx);
                    companions = aggregateCompanions(companions);
                    var vastObj = {
                        vastVersion : _vastVersion,
                        withWrapper: _withWrapper,
                        mediaFiles: _arrMediaFiles,
                        trackingUrls: mergeTrackings(_currTreeIdx),
                        impressionUrls: mergeImpressions(_currTreeIdx),
                        clickUrls: mergeClickUrls(_currTreeIdx),
                        clickTrackingUrls: mergeClickTrackings(_currTreeIdx),
                        errorUrls: mergeErrorUrls(_currTreeIdx),
                        durationMsecs: _nMsecDuration,
                        skipOffsetMsecs: _nMsecSkipOffset,
                        extensions: mergeExtensions(_currTreeIdx),
                        adParameters: _adParameters,
                        vastXml: _sourceVastXml,			// inline vast xml
                        extTrackingUrls: strTrackingUrls,
                        extImpressionUrls: strImpressionUrls,
                        extClickUrls: strClickUrls,
                        extClickTrackingUrls: strClickTrackingUrls,
                        extErrorUrls: strErrorUrls,
                        extExtensions: strExtensions,
                        adId: id,
                        sequence: _adTree[0].state.sequence,
                        companionAds: companions,
                        extCompanions: strCompanions,
                        icons: mergeIcons(_currTreeIdx),
                        extIcons: strIcons
                    };
                    if (_waterfall && _curNotifyUrl.length > 0) {
                        vastObj.notifyurl = _curNotifyUrl;
                    }
                    if (_curBuyerMemberId.length > 0) {
                        vastObj.buyerMemberId = _curBuyerMemberId;
                    }
                    // becaurse waterfall xml always unwrapped, we can set rtb flag base on current ad node
                    var rtb = false;
                    if (_waterfall) {
                        var rtbAttr = _helper.getNodeAttributeValue(adNode, 'rtb');
                        if (rtbAttr && rtbAttr === 'true') {
                            rtb = true;
                            vastObj.rtb = true;
                        }
                    }
                    if (_terminated) {
                        traceTreePath(_currTreeIdx, 'terminated');
                        _callback(false, _id, 'terminated', null);		// terminated
                        return;
                    }
                    var mediaTypes = [];
                    for (var i = 0 ; i < _arrMediaFiles.length; i++) {
                        if (mediaTypes.indexOf(_arrMediaFiles[i].type) === -1) {
                            mediaTypes.push(_arrMediaFiles[i].type);
                        }
                    }
                    traceTreePath(_currTreeIdx, 'SUCCESS, Available=' + JSON.stringify(mediaTypes));
                    if (_waterfall) {
                        _vastObjects.push(vastObj);
                        if (rtb) {
                            _rtbCount++;
                        }
                        else {
                            _csmCount++;
                        }
                        processNextAd();
                    }
                    else {
                        _callback(true, _id, vastObj, null);
                    }
                }
            }

            function prepareExternalTrackers(videoTrackers, impTracker) {

                var url;
                var i;
                var arr;
                var name;
                if (impTracker) {
                    _arrImpressions.push(impTracker.trim());
                }
                if (videoTrackers) {
                    if (Array.isArray(videoTrackers) && videoTrackers.length === 1) {
                        // new format
                        var trackers = videoTrackers[0];
                        if (trackers.impression_urls) {
                            for (i = 0; i < trackers.impression_urls.length; i++) {
                                url = trackers.impression_urls[i].trim();
                                _arrImpressions.push(url);
                            }
                        }
                        if (trackers.error_urls) {
                            for (i = 0; i < trackers.error_urls.length; i++) {
                                url = trackers.error_urls[i].trim();
                                _arrErrorUrls.push(url);
                            }
                        }
                        if (trackers.video_click_urls) {
                            for (i = 0; i < trackers.video_click_urls.length; i++) {
                                url = trackers.video_click_urls[i].trim();
                                _arrClickTrackings.push(url);
                            }
                        }
                        for (name in trackers.video_events) {
                            arr = trackers.video_events[name];
                            for (i = 0; i < arr.length; i++) {
                                url = arr[i].trim();
                                if (_arrTrackings.hasOwnProperty(name)) {
                                    if (!isInArray(_arrTrackings[name], url)) {
                                        _arrTrackings[name].push(url);
                                    }
                                }
                                else {
                                    _arrTrackings[name] = [url];
                                }
                            }
                        }
                    }
                    else {
                        for (name in videoTrackers) {
                            if (name === 'service') {	// ignore not vast related trackers
                                continue;
                            }
                            if (Array.isArray(videoTrackers[name])) {
                                arr = videoTrackers[name];
                                for (i = 0; i < arr.length; i++) {
                                    url = arr[i].trim();
                                    if (name === 'click') {
                                        _arrClickTrackings.push(url);
                                    }
                                    else if (name === 'error') {
                                        _arrErrorUrls.push(url);
                                    }
                                    else if (name === 'impression') {
                                        _arrImpressions.push(url);
                                    }
                                    else {
                                        if (_arrTrackings.hasOwnProperty(name)) {
                                            if (!isInArray(_arrTrackings[name], url)) {
                                                _arrTrackings[name].push(url);
                                            }
                                        }
                                        else {
                                            _arrTrackings[name] = [url];
                                        }
                                    }
                                }
                            }
                            else {
                                url = videoTrackers[name].trim();
                                if (name === 'click') {
                                    _arrClickTrackings.push(url);
                                }
                                else if (name === 'error') {
                                    _arrErrorUrls.push(url);
                                }
                                else if (name === 'impression') {
                                    _arrImpressions.push(url);
                                }
                                else {
                                    if (_arrTrackings.hasOwnProperty(name)) {
                                        if (!isInArray(_arrTrackings[name], url)) {
                                            _arrTrackings[name].push(url);
                                        }
                                    }
                                    else {
                                        _arrTrackings[name] = [url];
                                    }
                                }
                            }
                        }
                    }
                }
            }

            this.parse = function(strVastXml, videoTrackers, impTracker, callback) {
                _callback = callback;
                prepareExternalTrackers(videoTrackers, impTracker);
                _topLevel = true;
                parseXML(strVastXml);
            };

            this.terminate = function() {
                _terminated = true;
            };
        };

        var VastModifier = function(parserData, adToken, notifyUrl, contentSource, buyerMemberId) {

            var _logger = __webpack_require__(2);
            var _prefix = 'VAST Parser';

            var _parserData = parserData;
            var _adToken = adToken;
            var _notifyUrl = notifyUrl;
            var _buyerMemberId = buyerMemberId;
            var _contentSource = contentSource;
            var _helper = new VastXMLParserHelper();

            function trimXml(strVastXml) {
                var nPos = strVastXml.indexOf('<');
                var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
                nPos = strXml.lastIndexOf('>');
                if (nPos !== -1) {
                    strXml = strXml.substr(0, nPos + 1);
                }
                return strXml;
            }

            function prepareDocObject(strVastXml) {
                var strXml = trimXml(strVastXml);
                var xmlDoc = null;
                if (typeof window.DOMParser !== 'undefined') {
                    xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
                    if (xmlDoc.documentElement.nodeName === 'parsererror') {
                        try {
                            _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
                        }
                        catch(e) {}
                        return null;
                    }
                }
                else if (typeof window.ActiveXObject !== 'undefined') {
                    try {
                        xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
                        xmlDoc.loadXML(strXml);
                        if (xmlDoc.parseError.errorCode !== 0) {
                            _logger.error(_prefix, xmlDoc.parseError);
                            return null;
                        }
                    }
                    catch (ex) {
                        _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
                        return null;
                    }
                }
                else {
                    _logger.error(_prefix, 'Failed to get vast xml parser');
                    return null;
                }
                return xmlDoc;
            }

            var _xmlDoc = prepareDocObject(parserData.vastXml);

            function updateVastVersion(vastVersion) {
                if (_xmlDoc) {
                    var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
                    if (vastNode) {
                        var attr = _xmlDoc.createAttribute('version');
                        attr.value = vastVersion;
                        vastNode.setAttributeNode(attr);
                    }
                }
            }

            updateVastVersion(parserData.vastVersion);

            function appendAttributesToAdNode() {
                if (_xmlDoc) {
                    var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
                    if (vastNode) {
                        var ads = _helper.getSubNodes(vastNode, 'Ad');
                        if (ads && ads.length > 0) {
                            for (var i = 0; i < ads.length; i++) {
                                if (_notifyUrl) {
                                    var attr = _xmlDoc.createAttribute('notifyurl');
                                    attr.value = _notifyUrl;
                                    ads[i].setAttributeNode(attr);
                                }
                                if (_contentSource && _contentSource === 'rtb') {
                                    var attr2 = _xmlDoc.createAttribute('rtb');
                                    attr2.value = 'true';
                                    ads[i].setAttributeNode(attr2);
                                }
                                var attr3 = _xmlDoc.createAttribute('sequence');
                                attr3.value = _parserData.sequence.toString();
                                ads[i].setAttributeNode(attr3);
                                if (_buyerMemberId) {
                                    var attr4 = _xmlDoc.createAttribute('buyerMemberId');
                                    attr4.value = _buyerMemberId;
                                    ads[i].setAttributeNode(attr4);
                                }
                            }
                        }
                    }
                }
            }

            appendAttributesToAdNode();

            function addCdataBlock(parentNode, url) {
                var cdata = _xmlDoc.createCDATASection(url);
                parentNode.appendChild(cdata);
            }

            var _creativesNode = null;
            function getLinearNode() {
                if (_adToken) {
                    var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
                    var attr = _xmlDoc.createAttribute('adtoken');
                    attr.value = _adToken;
                    vastNode.setAttributeNode(attr);
                }

                var inLine = _helper.getSubNode(_xmlDoc, 'InLine');
                if (!inLine) {
                    return null;	// VAST xml has no InLine node
                }

                var i;
                if (_parserData.extImpressionUrls && typeof _parserData.extImpressionUrls === 'string') {
                    var impTrackers = JSON.parse(_parserData.extImpressionUrls);
                    if (Array.isArray(impTrackers) && impTrackers.length > 0) {
                        for (i = 0; i < impTrackers.length; i++) {
                            var impNode = _xmlDoc.createElement('Impression');
                            //impNode.textContent = impTrackers[i];
                            addCdataBlock(impNode, impTrackers[i]);
                            inLine.appendChild(impNode);
                        }
                    }
                    delete _parserData.extImpressionUrls;
                }

                if (_parserData.extErrorUrls && typeof _parserData.extErrorUrls === 'string') {
                    var errTrackers = JSON.parse(_parserData.extErrorUrls);
                    if (Array.isArray(errTrackers) && errTrackers.length > 0) {
                        for (i = 0; i < errTrackers.length; i++) {
                            var errNode = _xmlDoc.createElement('Error');
                            //errNode.textContent = errTrackers[i];
                            addCdataBlock(errNode, errTrackers[i]);
                            inLine.appendChild(errNode);
                        }
                    }
                    delete _parserData.extErrorUrls;
                }

                if (_parserData.extExtensions && typeof _parserData.extExtensions === 'string') {
                    var extensions = _parserData.extExtensions;
                    if (extensions.length > 0) {
                        var extensionsNode = _helper.getSubNode(inLine, 'Extensions');
                        if (!extensionsNode) {
                            extensionsNode = _xmlDoc.createElement('Extensions');
                            inLine.appendChild(extensionsNode);
                            extensionsNode.innerHTML = extensions;
                        }
                        else {
                            extensionsNode.innerHTML = extensionsNode.innerHTML.toString() + extensions;
                        }
                    }
                    delete _parserData.extExtensions;
                }

                _creativesNode = _helper.getSubNode(inLine, 'Creatives');
                if (!_creativesNode) {
                    _creativesNode = _xmlDoc.createElement('Creatives');
                    inLine.appendChild(_creativesNode);
                }
                var linearNode = _helper.getSubNode(_creativesNode, 'Linear');
                if (!linearNode) {
                    var creativeNode = _xmlDoc.createElement('Creative');
                    _creativesNode.appendChild(creativeNode);
                    linearNode = _xmlDoc.createElement('Linear');
                    creativeNode.appendChild(linearNode);
                }
                return linearNode;
            }

            function iconAlreadyExist(iconsNode, program) {
                var icons = _helper.getSubNodes(iconsNode, 'Icon');
                if (icons && icons.length > 0) {
                    for (var i = 0; i < icons.length; i++) {
                        var programAttr = _helper.getNodeAttributeValue(icons[i], 'program');
                        if (programAttr.toLowerCase() === program.toLowerCase()) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function appendTrackings(linearNode) {
                var i;
                if (_parserData.extTrackingUrls && typeof _parserData.extTrackingUrls === 'string' &&
                    _parserData.extTrackingUrls.length > 5) {
                    var videoTrackers = JSON.parse(_parserData.extTrackingUrls);
                    var trackersNode = _helper.getSubNode(linearNode, 'TrackingEvents');
                    if (!trackersNode) {
                        trackersNode =  _xmlDoc.createElement('TrackingEvents');
                        linearNode.appendChild(trackersNode);
                    }
                    // enumerate video trackers
                    for (var name in videoTrackers) {
                        var urls = videoTrackers[name];
                        for (i = 0; i < urls.length; i++) {
                            var trackerNode = _xmlDoc.createElement('Tracking');
                            var attr = _xmlDoc.createAttribute('event');
                            attr.value = name;
                            trackerNode.setAttributeNode(attr);
                            //trackerNode.textContent = urls[i];
                            addCdataBlock(trackerNode, urls[i]);
                            trackersNode.appendChild(trackerNode);
                        }
                    }
                    delete _parserData.extTrackingUrls;
                }

                var videoClicksNode;
                if (_parserData.extClickUrls && typeof _parserData.extClickUrls === 'string') {
                    var videoClicks = JSON.parse(_parserData.extClickUrls);
                    if (Array.isArray(videoClicks) && videoClicks.length > 0) {
                        videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
                        if (!videoClicksNode) {
                            videoClicksNode =  _xmlDoc.createElement('TrackingEvents');
                            linearNode.appendChild(videoClicksNode);
                        }
                        if (!_helper.getSubNode(videoClicksNode, 'ClickThrough')) {
                            var clickNode =  _xmlDoc.createElement('ClickThrough');
                            //clickNode.textContent = videoClicks[0];
                            addCdataBlock(clickNode, videoClicks[0]);
                            videoClicksNode.appendChild(clickNode);
                        }
                    }
                    delete _parserData.extClickUrls;
                }

                if (_parserData.extClickTrackingUrls && typeof _parserData.extClickTrackingUrls === 'string') {
                    var clickTrackings = JSON.parse(_parserData.extClickTrackingUrls);
                    if (Array.isArray(clickTrackings) && clickTrackings.length > 0) {
                        videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
                        if (!videoClicksNode) {
                            videoClicksNode =  _xmlDoc.createElement('VideoClicks');
                            linearNode.appendChild(videoClicksNode);
                        }
                        for (i = 0; i < clickTrackings.length; i++) {
                            var clickTrackingNode =  _xmlDoc.createElement('ClickTracking');
                            //clickTrackingNode.textContent = clickTrackings[i];
                            addCdataBlock(clickTrackingNode, clickTrackings[i]);
                            videoClicksNode.appendChild(clickTrackingNode);
                        }
                    }
                    delete _parserData.extClickTrackingUrls;
                }

                if (_parserData.extIcons && typeof _parserData.extIcons === 'string') {
                    var icons = JSON.parse(_parserData.extIcons);
                    if (Array.isArray(icons) && icons.length > 0) {
                        var iconsNode = _helper.getSubNode(linearNode, 'Icons');
                        if (!iconsNode) {
                            iconsNode = _xmlDoc.createElement('Icons');
                            linearNode.appendChild(iconsNode);
                        }
                        for (i = 0; i < icons.length; i++) {
                            // avoid duplicate icons with same program
                            if (!iconAlreadyExist(iconsNode, icons[i].program)) {
                                var iconNode = APN_Icons.createIconNode(_xmlDoc, icons[i]);
                                if (iconNode) {
                                    iconsNode.appendChild(iconNode);
                                }
                            }
                        }
                    }
                    delete _parserData.extIcons;
                }
            }

            function appendNewCompanion(companionAdsNode, newCompanion) {
                // get companions with resources
                var companionNode, j;
                var companionAdsObj = {companions: []};
                APN_CompanionAds.parse(companionAdsObj, companionAdsNode, _helper);
                var resCompanions = companionAdsObj.companions;
                if (newCompanion.StaticResource || newCompanion.IFrameResource || newCompanion.HTMLResource) {
                    var sameSize = false;
                    for (j = 0; j < resCompanions.length; j++) {
                        if (newCompanion.width === resCompanions[j].width &&
                            newCompanion.height === resCompanions[j].height) {
                            sameSize = true;
                            break;
                        }
                    }
                    if (!sameSize) {
                        companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, newCompanion);
                        companionAdsNode.appendChild(companionNode);
                    }
                }
                else {
                    // aggregate companion without resorces into companions with resources
                    var needUpdate = false;
                    for (j = 0; j < resCompanions.length; j++) {
                        if (newCompanion.width === resCompanions[j].width && newCompanion.height === resCompanions[j].height) {
                            if ((newCompanion.id && newCompanion.id === resCompanions[j].id) ||	(!newCompanion.id)) {
                                // add click trackings
                                if (newCompanion.CompanionClickTracking) {
                                    if (!resCompanions[j].CompanionClickTracking) {
                                        resCompanions[j].CompanionClickTracking = [];
                                    }
                                    resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(newCompanion.CompanionClickTracking);
                                }
                                // add view trackings
                                if (newCompanion.TrackingEvents) {
                                    if (!resCompanions[j].TrackingEvents) {
                                        resCompanions[j].TrackingEvents = [];
                                    }
                                    resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(newCompanion.TrackingEvents);
                                }
                                needUpdate = true;
                                break;
                            }
                        }
                    }
                    if (needUpdate) {
                        while (companionAdsNode.firstChild) {
                            companionAdsNode.removeChild(companionAdsNode.firstChild);
                        }
                        for (var i = 0; i < resCompanions.length; i++) {
                            companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, resCompanions[i]);
                            companionAdsNode.appendChild(companionNode);
                        }
                    }
                }
            }

            function appendCompanions() {
                if (_parserData.extCompanions && typeof _parserData.extCompanions === 'string') {
                    var companions = JSON.parse(_parserData.extCompanions);
                    if (Array.isArray(companions.companions) && companions.companions.length > 0) {
                        var companionAdsNode = _helper.getSubNode(_creativesNode, 'CompanionAds');
                        if (!companionAdsNode) {
                            companionAdsNode = _xmlDoc.createElement('CompanionAds');
                            _creativesNode.appendChild(companionAdsNode);
                        }
                        var attr;
                        if (companions.required !== 'unknown') {
                            attr = _xmlDoc.createAttribute('required');
                            attr.value = companions.required;
                            companionAdsNode.setAttributeNode(attr);
                        }
                        for (var i = 0; i < companions.companions.length; i++) {
                            appendNewCompanion(companionAdsNode, companions.companions[i]);
                        }
                    }
                }
            }

            this.addTrackers = function() {
                if (!_xmlDoc) {
                    return '';
                }
                var linearNode = getLinearNode();
                if (!linearNode) {
                    return '';
                }
                appendTrackings(linearNode);
                if (_creativesNode) {
                    appendCompanions();
                }
                var strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
                return strOut;
            };
        };

        var VastMerger = function(xmlList) {

            var _logger = __webpack_require__(2);
            var _prefix = 'VAST Parser';

            var _xmls = xmlList;
            var _helper = new VastXMLParserHelper();

            function trimXml(strVastXml) {
                var nPos = strVastXml.indexOf('<');
                var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
                nPos = strXml.lastIndexOf('>');
                if (nPos !== -1) {
                    strXml = strXml.substr(0, nPos + 1);
                }
                return strXml;
            }

            function prepareDocObject(strVastXml) {
                var strXml = trimXml(strVastXml);
                var xmlDoc = null;
                if (typeof window.DOMParser !== 'undefined') {
                    xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
                    if (xmlDoc.documentElement.nodeName === 'parsererror') {
                        try {
                            _logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
                        }
                        catch(e) {}
                        return null;
                    }
                }
                else if (typeof window.ActiveXObject !== 'undefined') {
                    try {
                        xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
                        xmlDoc.loadXML(strXml);
                        if (xmlDoc.parseError.errorCode !== 0) {
                            _logger.error(_prefix, xmlDoc.parseError);
                            return null;
                        }
                    }
                    catch (ex) {
                        _logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
                        return null;
                    }
                }
                else {
                    _logger.error(_prefix, 'Failed to get vast xml parser');
                    return null;
                }
                return xmlDoc;
            }

            var _xmlDoc = prepareDocObject(_xmls[0]);
            if (!_xmlDoc) {
                return;
            }

            var _vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
            var attr = _xmlDoc.createAttribute('apn_waterfall');
            attr.value = true;
            _vastNode.setAttributeNode(attr);

            var adNodes = [];
            for (var i = 0; i < _xmls.length; i++) {
                var doc = prepareDocObject(_xmls[i]);
                var vastNode = _helper.getSubNode(doc, 'VAST');
                var ads = _helper.getSubNodes(vastNode, 'Ad');
                if (ads && ads.length > 0) {
                    for (var j = 0; j < ads.length; j++) {
                        adNodes.push(ads[j]);
                    }
                }
            }

            adNodes.sort(function(a, b) {
                return _helper.getNodeAttributeNumberValue(a, 'sequence') - _helper.getNodeAttributeNumberValue(b, 'sequence');
            });

            _vastNode.innerHTML = '';
            for (i = 0; i < adNodes.length; i++) {
                _vastNode.appendChild(adNodes[i]);
            }

            this.getVastXml = function() {
                if (!_xmlDoc) {
                    return '';
                }
                var strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
                return strOut;
            };
        };

        module.exports = {
            /** Describe Parser Main Entry Point Here.
             * @param {string} strVastXml - VAST xml.
             * @param {function} fnCallback - Callback function.
             * 		Callback parameters:
             * 			succ: true if success, false otherwise
             * 			sourceId: mediation element identificator
             * 			data: object is success, error code otherwise
             * 			arrErrorUrl: null if success, list of tracking url parsed from vast xml untill parsing has failed
             * @param {object} id - mediation element identificator.
             * @param {number} nMsecTimeout - time out in miliseconds.
             * @param {object} videoTrackers - video_trackings field from impbus request.
             * @param {string} videoTrackers - imp_tracking_url field from impbus request.
             * @param {object} options - publisher options.
             */
            parse: function(strVastXml, fnCallback, id, nMsecTimeout, videoTrackers, impTracker, options) {
                var parserObj = new VastParser(id, nMsecTimeout, options);
                parserObj.parse(strVastXml, videoTrackers, impTracker,
                    function(succ, sourceId, data, arrErrorUrls) {
                        if (fnCallback) {
                            fnCallback(succ, sourceId, data, arrErrorUrls);
                        }
                        parserObj = null;
                    });
                return parserObj;
            },

            /** Describe Vast Unwrapping Entry Point Here.
             * @param {object} parserData - object returned after successful parsing.
             * @param {string} adToken - optional ad identificator used for debug mode
             * @return {string} - unwrapped VAST xml.
             */
            getUnwrappedVastTag: function(parserData, adToken, notifyUrl, contentSource, buyerMemberId) {
                if (!parserData || !parserData.vastXml) {
                    return null;
                }
                var obj = new VastModifier(parserData, adToken, notifyUrl, contentSource, buyerMemberId);
                var xml = obj.addTrackers();
                obj = null;
                return xml;
            },

            /** Describe Vast Merging VAST XMLs Entry Point Here.
             * @param {object} xmlListData - object containes XMLs and additional data:
             * 					xml: VAST XML
             * 					notifyUrl: notification url from impbus response
             * 					buyerMemberId: buyer member idenfificator from impbus response
             * @return {string} - merged VAST xml.
             */
            getMergedVastTag: function(xmlList) {
                if (!xmlList || xmlList.length === 0) {
                    return null;
                }
                var obj = new VastMerger(xmlList);
                var xml = obj.getVastXml();
                obj = null;
                return xml;
            }
        };


        /***/ },
    /* 30 */
    /***/ function(module, exports) {

        var CompanionAds = {

            parse: function (companionAdsDest, companionAdsNode, helper) {
                var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
                if (req && req.length > 0) {
                    companionAdsDest.required = req;
                }

                var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        //var companion = JSON.parse(JSON.stringify(APN_Companion));
                        var companion = {};

                        // required attributes
                        var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
                        var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
                        if (width <= 0 || height <= 0) {
                            continue;
                        }
                        companion.width = width;
                        companion.height = height;

                        // optional attributes and subnodes
                        var val = helper.getNodeAttributeValue(node, 'id');
                        if (val) {
                            companion.id = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
                        if (val > 0) {
                            companion.assetWidth = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
                        if (val > 0) {
                            companion.assetHeight = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
                        if (val > 0) {
                            companion.expandedWidth = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
                        if (val > 0) {
                            companion.expandedHeight = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'apiFramework');
                        if (val) {
                            companion.apiFramework = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'adSlotID');
                        if (val) {
                            companion.adSlotID = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'required');
                        if (val) {
                            companion.required = val;
                        }

                        val = helper.getSubNodeValue(node, 'AltText');
                        if (val) {
                            companion.AltText = val;
                        }

                        val = helper.getSubNodeValue(node, 'AdParameters');
                        if (val) {
                            companion.AdParameters = val;
                        }

                        var resource = helper.getSubNode(node, 'StaticResource');
                        if (resource) {
                            val = helper.getNodeAttributeValue(resource, 'creativeType');
                            if (val) {
                                // validate capability
                                var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
                                var isMobile = false;
                                if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
                                    isMobile = true;
                                }
                                if (isMobile && flashOnlyType) {
                                    // ignore this companion
                                    continue;
                                }

                                var staticResource = {type: val};
                                val = helper.getNodeValues(resource);
                                if (val) {
                                    staticResource.src = val;
                                    companion.StaticResource = staticResource;
                                }
                            }
                        }

                        val = helper.getSubNodeWholeValue(node, 'IFrameResource');
                        if (val) {
                            companion.IFrameResource = val;
                        }

                        val = helper.getSubNodeWholeValue(node, 'HTMLResource');
                        if (val) {
                            companion.HTMLResource = val;
                        }

                        val = helper.getSubNodeValue(node, 'CompanionClickThrough');
                        if (val) {
                            companion.CompanionClickThrough = val;
                        }

                        var j;
                        var trackingNode;
                        var url;
                        var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
                        if (clickTrackinEvents) {
                            companion.CompanionClickTracking = [];
                            for (j = 0; j < clickTrackinEvents.length; j++) {
                                trackingNode = clickTrackinEvents[j];
                                url = helper.getNodeValues(trackingNode);
                                if (url) {
                                    companion.CompanionClickTracking.push(url);
                                }
                            }
                        }

                        var trackinEvents = helper.getSubNodes(node, 'Tracking');
                        if (trackinEvents) {
                            companion.TrackingEvents = [];
                            for (j = 0; j < trackinEvents.length; j++) {
                                trackingNode = trackinEvents[j];
                                var event = helper.getNodeAttributeValue(trackingNode, 'event');
                                url = helper.getNodeValues(trackingNode);
                                if (event && url) {
                                    companion.TrackingEvents.push({eventType: event, url: url});
                                }
                            }
                        }

                        companionAdsDest.companions.push(companion);
                    }
                }
            },

            mergeCompanions: function(companionAdsDest, companionAds) {
                if (companionAdsDest.required === 'unknown') {
                    companionAdsDest.required = companionAds.required;
                }
                companionAdsDest.companions = companionAdsDest.companions.concat(companionAds.companions);
            },

            createCompanionNode: function (xmlDoc, data) {
                var companion = xmlDoc.createElement('Companion');
                var i;
                var elem;
                var attr;
                var cdata;

                var arrAttrs = ['id', 'width', 'height', 'assetWidth', 'assetHeight', 'expandedWidth', 'expandedHeight',
                    'apiFramework', 'adSlotID', 'required'];
                for (i = 0; i < arrAttrs.length; i++) {
                    if (data.hasOwnProperty(arrAttrs[i])) {
                        attr = xmlDoc.createAttribute(arrAttrs[i]);
                        attr.value = data[arrAttrs[i]];
                        companion.setAttributeNode(attr);
                    }
                }

                if (data.hasOwnProperty('StaticResource')) {
                    elem = xmlDoc.createElement('StaticResource');
                    attr = xmlDoc.createAttribute('creativeType');
                    attr.value = data.StaticResource.type;
                    elem.setAttributeNode(attr);
                    cdata = xmlDoc.createCDATASection(data.StaticResource.src);
                    elem.appendChild(cdata);
                    companion.appendChild(elem);
                }

                var arrNodes = ['AdParameters', 'IFrameResource', 'HTMLResource', 'CompanionClickThrough'];
                for (i = 0; i < arrNodes.length; i++) {
                    if (data.hasOwnProperty(arrNodes[i])) {
                        elem = xmlDoc.createElement(arrNodes[i]);
                        cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
                        elem.appendChild(cdata);
                        companion.appendChild(elem);
                    }
                }

                if (data.hasOwnProperty('AltText')) {
                    elem = xmlDoc.createElement('AltText');
                    try {
                        elem.innerHTML = data.AltText;
                    }
                    catch(ex) {
                        // IE 11 does not allow set innerHTML property
                        try {
                            elem.textContent = data.AltText;
                        }
                        catch(ex2) {

                        }
                    }
                    companion.appendChild(elem);
                }

                if (data.hasOwnProperty('CompanionClickTracking')) {
                    for (i = 0; i < data.CompanionClickTracking.length; i++) {
                        var tracking = xmlDoc.createElement('CompanionClickTracking');
                        cdata = xmlDoc.createCDATASection(data.CompanionClickTracking[i]);
                        tracking.appendChild(cdata);
                        companion.appendChild(tracking);
                    }
                }

                if (data.hasOwnProperty('TrackingEvents')) {
                    elem = xmlDoc.createElement('TrackingEvents');
                    // enumerate trackers
                    for (i = 0; i < data.TrackingEvents.length; i++) {
                        var event = xmlDoc.createElement('Tracking');
                        attr = xmlDoc.createAttribute('event');
                        attr.value = data.TrackingEvents[i].eventType;
                        event.setAttributeNode(attr);
                        cdata = xmlDoc.createCDATASection(data.TrackingEvents[i].url);
                        event.appendChild(cdata);
                        elem.appendChild(event);
                    }
                    companion.appendChild(elem);
                }

                return companion;
            }
        };

        module.exports = CompanionAds;

        /***/ },
    /* 31 */
    /***/ function(module, exports) {

        var Icons = {

            parse: function (IconsDest, IconsNode, helper) {
                var nodes = helper.getSubNodes(IconsNode, 'Icon');
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        var icon = {};

                        // required attributes
                        var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
                        var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
                        var program = helper.getNodeAttributeValue(node, 'program');
                        var xPosition = helper.getNodeAttributeValue(node, 'xPosition');
                        var yPosition = helper.getNodeAttributeValue(node, 'yPosition');
                        if (width <= 0 || height <= 0 || program.length === 0 || xPosition.length === 0 || yPosition.length === 0) {
                            continue;
                        }
                        icon.width = width;
                        icon.height = height;
                        icon.program = program;
                        icon.xPosition = xPosition;
                        icon.yPosition = yPosition;

                        // optional attributes and subnodes
                        var val = helper.getNodeAttributeValue(node, 'apiFramework');
                        if (val) {
                            icon.apiFramework = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'offset');
                        if (val) {
                            // validate
                            if (isNaN(Date.parse('January 1, 1970 ' + val))) {
                                // invalid time format
                                continue;
                            }
                            icon.offset = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'duration');
                        if (val) {
                            // validate
                            if (isNaN(Date.parse('January 1, 1970 ' + val))) {
                                // invalid time format
                                continue;
                            }
                            icon.duration = val;
                        }

                        var resource = helper.getSubNode(node, 'StaticResource');
                        if (resource) {
                            val = helper.getNodeAttributeValue(resource, 'creativeType');
                            if (val) {
                                // validate capability
                                var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
                                var isMobile = false;
                                if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
                                    isMobile = true;
                                }
                                if (isMobile && flashOnlyType) {
                                    // ignore this companion
                                    continue;
                                }

                                var staticResource = {type: val};
                                val = helper.getNodeValues(resource);
                                if (val) {
                                    staticResource.src = val;
                                    icon.StaticResource = staticResource;
                                }
                            }
                        }

                        val = helper.getSubNodeWholeValue(node, 'IFrameResource');
                        if (val) {
                            icon.IFrameResource = val;
                        }

                        val = helper.getSubNodeWholeValue(node, 'HTMLResource');
                        if (val) {
                            icon.HTMLResource = val;
                        }

                        var iconClicks = helper.getSubNode(node, 'IconClicks');
                        if (iconClicks) {
                            val = helper.getSubNodeValue(node, 'IconClickThrough');
                            if (val) {
                                icon.IconClickThrough = val;
                            }

                            val = helper.getSubNodeValue(node, 'IconClickTracking');
                            if (val) {
                                icon.IconClickTracking = val;
                            }
                        }

                        val = helper.getSubNodeValue(node, 'IconViewTracking');
                        if (val) {
                            icon.IconViewTracking = val;
                        }

                        IconsDest.push(icon);
                    }
                }
            },

            createIconNode: function (xmlDoc, data) {
                var icon = xmlDoc.createElement('Icon');
                var i;
                var elem;
                var attr;
                var cdata;

                var arrAttrs = ['width', 'height', 'program', 'xPosition', 'yPosition', 'apiFramework', 'offset', 'duration'];
                for (i = 0; i < arrAttrs.length; i++) {
                    if (data.hasOwnProperty(arrAttrs[i])) {
                        attr = xmlDoc.createAttribute(arrAttrs[i]);
                        attr.value = data[arrAttrs[i]];
                        icon.setAttributeNode(attr);
                    }
                }

                if (data.hasOwnProperty('StaticResource')) {
                    elem = xmlDoc.createElement('StaticResource');
                    attr = xmlDoc.createAttribute('creativeType');
                    attr.value = data.StaticResource.type;
                    elem.setAttributeNode(attr);
                    cdata = xmlDoc.createCDATASection(data.StaticResource.src);
                    elem.appendChild(cdata);
                    icon.appendChild(elem);
                }

                var arrNodes = ['IFrameResource', 'HTMLResource', 'IconViewTracking'];
                for (i = 0; i < arrNodes.length; i++) {
                    if (data.hasOwnProperty(arrNodes[i])) {
                        elem = xmlDoc.createElement(arrNodes[i]);
                        cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
                        elem.appendChild(cdata);
                        icon.appendChild(elem);
                    }
                }

                if (data.hasOwnProperty('IconClickThrough') || data.hasOwnProperty('IconClickTracking')) {
                    var iconClicks = xmlDoc.createElement('IconClicks');
                    if (data.hasOwnProperty('IconClickThrough')) {
                        elem = xmlDoc.createElement('IconClickThrough');
                        cdata = xmlDoc.createCDATASection(data.IconClickThrough);
                        elem.appendChild(cdata);
                        iconClicks.appendChild(elem);
                    }
                    if (data.hasOwnProperty('IconClickTracking')) {
                        elem = xmlDoc.createElement('IconClickTracking');
                        cdata = xmlDoc.createCDATASection(data.IconClickTracking);
                        elem.appendChild(cdata);
                        iconClicks.appendChild(elem);
                    }
                    icon.appendChild(iconClicks);
                }

                return icon;
            }
        };

        module.exports = Icons;

        /***/ },
    /* 32 */
    /***/ function(module, exports) {

        /**
         * Capability Detection module.
         * @module CapabilityDetection
         */

        function isMobile(){
            if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
                return true;
            }
            return false;
        }

        function hasFlashPlugin(){
            var flash_installed = typeof navigator.plugins !== 'undefined' && typeof navigator.plugins['Shockwave Flash'] === 'object';
            if (!flash_installed) {
                flash_installed = window.ActiveXObject && (new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
            }
            return flash_installed;
        }

        function isFlashOnlyType(type) {
            return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
                type === 'application/x-shockwave-flash';
        }

        function isHtml5VpaidType(type) {
            return type === 'application/javascript' || type === 'application/x-javascript';
        }

        function isIphone() {
            var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        }

        function isIos() {
            var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        }

        function isAndroid() {
            return (/android/i.test(navigator.userAgent.toLowerCase()));
        }

        module.exports = {
            /** Checks for Flash support.
             * @returns {boolean} True is flash is supported, false otherwise.
             */
            supportsFlash: function() {
                return !isMobile() && hasFlashPlugin();
            },

            /** Detects browser on mobile devices.
             * @returns {boolean} True is browser on mobile, false otherwise.
             */
            isBrowserOnMobile: function() {
                return isMobile();
            },

            /** Detects browser.
             * @returns {string} browser name.
             */
            getBrowserName: function() {
                var ua = navigator.userAgent,
                    tem,
                    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

                if (/trident/i.test(M[1])) {
                    tem =/\brv[ :]+(\d+)/g.exec(ua) || [];
                    return 'IE';
                }
                if (M[1] === 'Chrome') {
                    tem = ua.match(/\bOPR\/(\d+)/);
                    if (tem !== null) {
                        return 'Opera';
                    }
                }
                M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
                if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
                    M.splice(1,1,tem[1]);
                }
                return M[0];
            },

            /** Detects is video type playable for particular browser.
             * @param {string} mimeType - media type from VAST xml.
             * @param {string} codec - codec from VAST xml if present.
             * @returns {boolean} True if playable, false otherwise.
             */
            canPlay: function(mimeType, codec) {
                var alternativeCodec = null;
                if (isFlashOnlyType(mimeType.toLowerCase())) {
                    return !isMobile() && hasFlashPlugin();
                }
                else if (isHtml5VpaidType(mimeType.toLowerCase())) {
                    return true;		// always allow to play html5 vpaid
                }
                else {
                    var type = mimeType.toLowerCase();
                    if (!codec || codec === '') {
                        if (type === 'video/mp4') {
                            codec = 'avc1.42E01E,mp4a.40.2';
                            //only test with video codec for alternativeCodec
                            alternativeCodec = 'avc1.42E01E';//iphone7 + iOS10GM will return "maybe" for the "mp4a.40.2", so alternative codecs should be tested more to provide extra opportunity to be choosen by canPlayType
                            //vid.canPlayType("video/mp4;codecs=avc1.42E01E,mp4a.40.2");
                            //iphone 7 + iOS10GM : maybe
                            //iphone 6 + iOS10GM : probably
                        }
                        else if (type === 'video/webm') {
                            codec = 'vp8,vorbis';
                        }
                        else if (type === 'video/ogg') {
                            codec = 'theora,vorbis';
                        }
                        else {
                            return false;	// unknown video mime type
                        }
                    }
                    var vid = document.createElement('video');
                    var response = vid.canPlayType(type + ';codecs="' + codec + '"');
                    if (response === 'probably') {
                        return true;
                    }
                    if (response === 'maybe') {
                        if (type === 'video/webm') {
                            return true;
                        }
                        //if alternativeCodec exists, do a test once again to give additoinal opportunity to be tested
                        if (alternativeCodec && vid.canPlayType(type + ';codecs="' + alternativeCodec + '"') === "probably") {
                            return true;
                        }
                    }
                    return false;
                }
            },

            /** Returns information about device where ad is running.
             * @returns {string} One of the following: desktop-flash, desktop-no-flash, mobile-Android, mobile-iOS, mobile-unknown.
             */
            getPlatformType: function() {
                if (isMobile()) {
                    if (isAndroid()) {
                        return 'mobile-Android';
                    }
                    if (isIos()) {
                        return 'mobile-iOS';
                    }
                    return 'mobile-unknown';
                }
                else {
                    if (hasFlashPlugin()) {
                        return 'desktop-flash';
                    }
                    return 'desktop-no-flash';
                }
            }
        };


        /***/ },
    /* 33 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * URL Loader module.
         * @module UrlLoader
         */



        var _logger = __webpack_require__(2);

        function ajaxLoad(url, callback, timeout, options) {

            var httpRequest;
            var startTime = 0;
            var duration = 0;
            var calcDuration = false;
            var logger = __webpack_require__(34);
            var cacheManager = __webpack_require__(35);

            var useWithCredentials = true;

            var debug = function(message) {
                logger.logDebug(message, 'URL Loader');
            };

            if (options &&  typeof options.withCredentials !== 'undefined') {
                useWithCredentials = options.withCredentials;
            }

            if (window.XMLHttpRequest) { // Mozilla, Safari, ...
                httpRequest = new XMLHttpRequest();
            } else if (window.ActiveXObject) { // IE
                try {
                    httpRequest = new ActiveXObject('Msxml2.XMLHTTP');
                } catch (msxmlErr) {
                    try {
                        httpRequest = new ActiveXObject('Microsoft.XMLHTTP');
                    } catch (msErr) {}
                }
            }


            if (!httpRequest) {
                if (callback) {
                    callback.call(this, '406', ''); // request is not acceptable
                }
                return;
            }

            httpRequest.onreadystatechange = function() {
                if (httpRequest.readyState === 4) {

                    if (httpRequest.status === 200) {
                        if (callback) {
                            callback.call(this, undefined, httpRequest.responseText, httpRequest);
                        }
                        debug('duration: ' + duration + ', response length: ' + httpRequest.responseText.length);
                        if (calcDuration && httpRequest.responseText && httpRequest.responseText.length > 2048) {
                            var nBandWidth = (httpRequest.responseText.length * 8.0 * 1000.0) / (Math.max(1.0, duration) * 1024.0);
                            var intBandwidth = parseInt(nBandWidth.toString());
                            debug('Bandwidth: ' + intBandwidth);
                            try {
                                cacheManager.setGenericData('anxBandwidth', intBandwidth);
                                //localStorage.setItem('anxBandwidth', intBandwidth);
                            }
                            catch(ex) {
                            }
                        }
                    } else {
                        if (httpRequest.status >= 400 && httpRequest.status < 600) {
                            if (callback) {
                                callback.call(this, httpRequest.status, '', httpRequest);
                            }
                        }
                    }

                }
                else if (httpRequest.readyState === 2) {
                    startTime = (new Date()).getTime();
                }
                else if (httpRequest.readyState === 3) {
                    if (startTime > 0) {
                        calcDuration = true;
                        duration = (new Date()).getTime() - startTime;
                    }
                }
            };

            httpRequest.onerror = function() {
                //if there is an error, it might be becase we are using withCredentials
                //let's try one more time without that flag set.
                //this won't send cookies, but it's better than no ad at all
                if(useWithCredentials) {
                    var newOpts = options ? options : {};
                    newOpts.withCredentials = false;
                    ajaxLoad(url, callback, timeout, newOpts);
                } else {
                    if (callback) {
                        var errorStatus = httpRequest.status === 0 ? '404' : httpRequest.status.toString();
                        callback.call(this, errorStatus, '', httpRequest);
                    }
                }
            };


            httpRequest.ontimeout = function() {
                //_logger.log('Server Timeout');
                if (callback) {
                    callback.call(this, 'Timeout', '', httpRequest);
                }
            };

            httpRequest.open('GET', url);
            if (timeout) {
                httpRequest.timeout = timeout;
            }
            httpRequest.withCredentials = useWithCredentials;
            startTime = 0;
            httpRequest.send();
        }

        function createTrackingPixel(url, eventName) {
            _logger.log('Logging Event: ' + eventName + ' at url:' + url);
            new Image(1, 1).src = url;

        }



        module.exports = {
            /** Load a URL.
             * @param {string} url - Target URL to load.
             * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
             * @param {number} timeout - Timeout (in ms) to use for this URL Load.
             */
            load: function(url, callback, timeout) {
                ajaxLoad(url, callback, timeout, {withCredentials:true});
            },


            /** Track Pixel.
             * @param {String} url - Url of traking pixel to track.
             * @param {String} eventName - Name of event being tracked.
             */
            trackPixel: function(url, eventName) {
                createTrackingPixel(url, eventName);
            }
        };


        /***/ },
    /* 34 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * General Utilities module.
         * @module GeneralUtilities
         */

        var _logger = __webpack_require__(2);


        //////////////////////////////////////////////////////////////////////
        // CONSTANTS
        var MAX_OBJ_TO_STRING_RECURSION = 9;




        //////////////////////////////////////////////////////////////////////
        // VARIABLES


        //////////////////////////////////////////////////////////////////////
        // FUNCTIONS
        function getXmlResponseFromXhrObject(responseObj) {
            if (responseObj) {
                //if the response has parsed XML, trace it as an XML object
                //otherwise, trace it as a string
                if (responseObj.responseXML) {
                    return responseObj.responseXML;
                } else {
                    return responseObj.responseText;
                }
            }
        }

        //////////////////////////////////////////////////////////////////////
        // EXPORTS
        module.exports = {
            /**
             * @deprecated - use @appnexus/videoads-util-logging
             * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
             * @param (string) message = text to be written to the log
             * @param (string) source = optional string which identifies the source of the debug statement
             *      - if present, then it will be prepended to front of the string
             *      - example 1:  debug("hello") ==> <timestamp> hello
             *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
             */
            debug: function() {
                _logger.handleLogDebugLegacySupport.apply(this, arguments);

            },

            /**
             * @deprecated - use @appnexus/videoads-util-logging
             * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
             * @param (string) message = text to be written to the log
             * @param (string) source = optional string which identifies the source of the debug statement
             *      - if present, then it will be prepended to front of the string
             *      - example 1:  debug("hello") ==> <timestamp> hello
             *
             */
            logDebug: function() {
                _logger.handleLogDebugLegacySupport.apply(this, arguments);

            },

            /**
             * @deprecated - use @appnexus/videoads-util-logging
             * Sets debug level for logger
             * @param (string) level = Debug level to use
             */
            setDebugLevel: function(level) {
                _logger.setDebugLevel(level);
            },

            /**
             * Checks to see if a string or an array is not empty:
             *  @param (object) arg = string or array which is being evaluated
             *  @returns (boolean)
             *      - true = arg is defined and the length > 0
             *      - false = arg is null, undefined or has a length of zero
             */
            isNotEmpty: function(arg) {
                var answer = false;
                if (arg !== null && arg) {
                    answer = (arg.length > 0);
                }

                return answer;
            },

            /**
             * @deprecated - since we now have the abilility to directly pass objects to our debug statements, we no longer need this
             * returns a string version of an object
             * if the value of a field is itself an object, then will stringify that object as well
             */
            objectToString: function(obj, recursionCount) {
                /*
                 try{
                 return JSON.stringify(obj);
                 }catch(ex){
                 return "null"
                 }
                 */
                var answer = "null";

                //set default recurisonCount if it's not specified
                recursionCount = typeof recursionCount !== 'undefined' ? recursionCount : 0;

                if (obj !== null) {
                    answer = "OBJ[";
                    var props = "";
                    for (var key in obj) {
                        var val = obj[key];
                        if (typeof val === 'object') {
                            recursionCount++;
                            if (recursionCount < MAX_OBJ_TO_STRING_RECURSION) {
                                try {
                                    val = this.objectToString(val);
                                } catch (ex) {
                                    val = "err:" + ex;
                                }
                            } else {
                                val = "err: max recursion hit";
                            }
                        }
                        if (props.length > 0) {
                            props += ",";
                        }
                        props += (key + "=" + val);
                    }
                    answer += props;
                    answer += "]";
                }


                return answer;

            },

            /**
             *  Generates a alphanueric random string, up to 16 characters long containing the set [0-9,a-z].
             *  Note: It is not guaranteed that this will start with a letter.
             *  Note: These are not UUIDs/GUIDs, do not use as such in critcial situaitons.
             *  Note: This is not guaranteed to be crypogtaphically secure.
             *  @param (object) arg = string or array which is being evaluated
             *  @returns (String)
             *      - random character string
             */
            getRandomString: function() {
                return Math.random().toString(36).substring(2);
            },

            /**
             *  Trace a XML response in a XHR object at the "info" trace level (if enabled)
             *  @param (Object) responseObjects = Single XHR Response object, or Array of XHR Response Objects to trace.
             *  @param (String) tracePrefix = Text to print as part of trace statement.
             *
             */
            traceVastFromXhr: function(responseObjects, tracePrefix) {
                try {
                    if (responseObjects) {
                        //if we are passed an array, treat each item in array as a XHR Response
                        if (Array.isArray(responseObjects)) {
                            if (responseObjects.length > 0) {
                                // var responsesToTrace = [];
                                var xmlUrlLoadingChain = [];

                                //parse URL and payload out of each object
                                for (var curResponseArrayPos in responseObjects) {
                                    // var curResponsePayload = {};
                                    // curResponsePayload.url = responseObjects[curResponseArrayPos].responseURL;
                                    // curResponsePayload.payloadObj = getXmlResponseFromXhrObject(responseObjects[curResponseArrayPos]);
                                    // responsesToTrace.push(curResponsePayload);

                                    xmlUrlLoadingChain.push(responseObjects[curResponseArrayPos].responseURL);
                                }

                                var finalXhrObject = responseObjects[responseObjects.length - 1];
                                if (finalXhrObject) {
                                    var finalXmlTag = getXmlResponseFromXhrObject(finalXhrObject);
                                    var finalXmlTagUrl = finalXhrObject.responseURL;

                                    _logger.info(tracePrefix, "Tag load chain:", xmlUrlLoadingChain, "\n",
                                        "Final Tag URL: ", finalXmlTagUrl, "\n", "Final Tag: ", finalXmlTag);
                                }
                            }
                        } else {
                            //if we didn't get an array, treat responseObjects as a single XHR responsw
                            var responsePayloadToTrace = getXmlResponseFromXhrObject(responseObjects);
                            _logger.info(tracePrefix, "Tag URL:", responseObjects.responseURL, "\n", "Tag:", responsePayloadToTrace);

                        }
                    }
                }catch (e) {}
            }



        };


        /***/ },
    /* 35 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Cache Manager module.
         * @module CacheManager
         */

        var utils = __webpack_require__(34);


        var prefix = "Cache Manager";

        //////////////////////////////////////////////////////////////////////
        // CONSTANTS
        var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
        var MSEC_PER_MINUTE = 60 * 1000;
        var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

        //////////////////////////////////////////////////////////////////////
        // VARIABLES
        var _ttlMsec = TTL_DEFAULT_MSEC;

        var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
        var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

        var backupInMemoryStorageObj = {};

        //storage types:
        //0 - localStorage
        //1 - cookie
        //2 - in memory
        var storageTypeToUse;

        if (isLocalStorageSupported()) {
            storageTypeToUse = 0;
        } else {
            if (isCookieStorageSupported()) {
                storageTypeToUse = 1;
            } else {
                storageTypeToUse = 2;
            }

        }

        utils.debug("Using Cache Method " + storageTypeToUse, prefix);

        //docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
        var docCookies = {
            getItem: function(sKey) {
                if (!sKey) {
                    return null;
                }
                return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
            },
            setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
                if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
                    return false;
                }
                var sExpires = "";
                if (vEnd) {
                    switch (vEnd.constructor) {
                        case Number:
                            sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
                            break;
                        case String:
                            sExpires = "; expires=" + vEnd;
                            break;
                        case Date:
                            sExpires = "; expires=" + vEnd.toUTCString();
                            break;
                    }
                }
                document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
                return true;
            },
            removeItem: function(sKey, sPath, sDomain) {
                if (!this.hasItem(sKey)) {
                    return false;
                }
                document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
                return true;
            },
            hasItem: function(sKey) {
                if (!sKey) {
                    return false;
                }
                return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
            },
            keys: function() {
                var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
                for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
                    aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
                }
                return aKeys;
            }
        };

        //write object to whatever storage method we are using, with specified key
        function writeToStorage(key, obj, dontExpire) {
            switch (storageTypeToUse) {
                case 0:
                    writeToLocalStorage(key, obj);
                    break;
                case 1:
                    writeToCookieStorage(key, obj, dontExpire);
                    break;
                default:
                case 2:
                    writeToInMemoryStorage(key, obj);
                    break;
            }
        }

        //get a object from the storage method we are using, that has the specified key
        function getFromStorage(key) {
            switch (storageTypeToUse) {
                case 0:
                    return getFromLocalStorage(key);
                case 1:
                    return getFromCookieStorage(key);
                default:
                case 2:
                    return getFromInMemoryStorage(key);
            }

        }

        //delete an object in the storaege method we are using,
        function deleteFromStorage(key) {
            switch (storageTypeToUse) {
                case 0:
                    deleteFromLocalStorage(key);
                    break;
                case 1:
                    deleteFromCookieStorage(key);
                    break;
                default:
                case 2:
                    deleteFromInMemoryStorage(key);
                    break;
            }
        }

        function writeToLocalStorage(key, obj) {
            if (localStorage) {
                localStorage.setItem(key, obj);
            }
        }

        function getFromLocalStorage(key) {
            if (localStorage) {
                return localStorage.getItem(key);
            }
        }

        function deleteFromLocalStorage(key) {
            if (localStorage) {
                localStorage.removeItem(key);
            }
        }

        function writeToCookieStorage(key, obj, dontExpire) {
            docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
        }

        function getFromCookieStorage(key) {
            return docCookies.getItem(key);
        }

        function deleteFromCookieStorage(key) {
            docCookies.removeItem(key);
        }

        function writeToInMemoryStorage(key, obj) {
            if (backupInMemoryStorageObj) {
                backupInMemoryStorageObj[key] = obj;
            }
        }

        function getFromInMemoryStorage(key) {
            if (backupInMemoryStorageObj) {
                return backupInMemoryStorageObj[key];
            }
        }

        function deleteFromInMemoryStorage(key) {
            if (backupInMemoryStorageObj) {
                delete backupInMemoryStorageObj[key];
            }
        }

        //return true if localStorage is supported, false otherwise
        function isLocalStorageSupported() {

            //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
            try {
                if (localStorage) {
                    var testValue = "apntestls" + Math.random();
                    try {
                        //try writing and reading something
                        localStorage.setItem(testValue, testValue);
                        localStorage.removeItem(testValue);
                        return true;
                    } catch (e) {}
                }
            } catch (e) {}

            return false;
        }


        //return true if localStorage is supported, false otherwise
        function isCookieStorageSupported() {
            try {
                if (document && document.cookie) {
                    var testValue = "apntestcookie" + Math.random();
                    try {
                        docCookies.setItem(testValue, testValue, Infinity);
                        var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
                        docCookies.removeItem(testValue);
                        return cookieWorked;
                    } catch (e) {}
                }
            } catch (e) {}

            return false;
        }

        // caches the adObject - this will overwrite any existing cached ad
        // the cache will also be timestamp with the current time in milliseconds
        // for calculating time to live
        function addAdToCache(adObject, adId) {
            var cacheObject = {};
            cacheObject.timestamp = new Date().getTime();
            cacheObject.ad = adObject;

            try {
                writeToStorage(adId, JSON.stringify(cacheObject));
            } catch (e) {

            }
        }

        // returns the ad stored in the cache if the cache has not expired
        // returns null if the cache has expired (based on the configured time-to-live)
        // OR if there is no ad in the cache
        // NOTE:  It is not clear yet what to do with placement id - ignore it for now
        function getCachedAd(adId) {
            var ts = new Date().getTime();

            var retrievedCacheItem;

            try {
                var itemFromCache = getFromStorage(adId);
                retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
                // clear the cache, setting it back to default (or empty)
                deleteFromStorage(adId);
            } catch (e) {

            }

            // check to see if the ad cache exists and if the cache has not expired
            if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
                var cacheAge = ts - retrievedCacheItem.timestamp;
                //if we have expired, return nothing
                if (cacheAge <= _ttlMsec) {
                    return retrievedCacheItem.ad;
                }
            }

            return null;
        }

        // clear the ad cache by creating a default ad cache object
        //NOTE:  It is not clear yet what to do with placement id - ignore it for now
        function clearAdCache(adId) {
            try {
                deleteFromStorage(adId);
            } catch (e) {

            }
        }

        // converts the time-to-live argument from minutes to milliseconds
        // to make it easier to compare timestamps
        function setTTL(ttlMinutes) {
            _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
        }

        // gets the current token from the cache
        function getAdToken() {
            var tokenToReturn;
            var tokenFromCache;
            tokenFromCache = getFromStorage(adTokenStorageKey);

            if (tokenFromCache) {
                tokenToReturn = parseInt(tokenFromCache);
            } else {
                //no token found, use default
                tokenToReturn = 0;
            }

            //store new token in localStorage or local memory
            writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


            return tokenToReturn;
        }

        function prependAppnexusIdToKey(incomingKey) {
            return "apn_" + incomingKey;
        }

        module.exports = {

            /**
             * Set generic data in cache
             * @param (string) key = key under which to store data
             * @param (object) value = value to store.
             * @return (boolean) true if value was succesfully stored, false otherwise
             */
            setGenericData: function(key, value) {
                if (typeof key !== "undefined" && typeof value !== "undefined") {
                    key = _genericDataStotagePrefix + key;
                    try {
                        writeToStorage(key, value);
                        return true;
                    } catch (e) {

                    }
                }
                return false;
            },

            /**
             * Get generic data from cache
             * @param (string) key = key to retrive from data
             * @return (object) object contaninig data from cache with given key, undefined if key not found.
             */
            getGenericData: function(key) {
                if (typeof key !== "undefined") {
                    key = _genericDataStotagePrefix + key;
                    return getFromStorage(key);
                }
            },

            /**
             * Delete generic data from cache
             * @param (string) key = key to delete from cache
             */
            deleteGenericData: function(key) {
                if (typeof key !== "undefined") {
                    key = _genericDataStotagePrefix + key;
                    deleteFromStorage(key);
                }
            },

            /**
             * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
             * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
             */
            forceStorageMethod: function(storageType) {
                storageTypeToUse = storageType;
                utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
            },

            /**
             * add the ad data to the cache
             * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
             *      - this will become the input into the ad rendering logic
             * @param (integer) adId = unique identifier for a specific ad cache
             */
            addAd: function(adObject, adId) {
                if (adObject) {
                    addAdToCache(adObject, prependAppnexusIdToKey(adId));
                }
            },

            /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
             * @param (integer) adId = unique identifier for a specific ad cache
             * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
             */
            getAd: function(adId) {
                return getCachedAd(prependAppnexusIdToKey(adId));
            },

            /**
             * Clears the cache, removing any cached ad
             * @param (integer) adId = unique identifier for a specific ad cache
             */
            clearAd: function(adId) {
                clearAdCache(prependAppnexusIdToKey(adId));
            },

            /** Sets the time-to-live settings for the ad cache
             * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
             */
            setTimeToLive: function(timeToLiveMinutes) {
                setTTL(timeToLiveMinutes);
            },

            /**
             * Returns a token unique to this page which is used to identify an ad request.
             */
            getNextAdToken: function() {
                // Remove unnecessary additional characters.
                // return chars.substring(0, len);
                return getAdToken();
            }
        };


        /***/ },
    /* 36 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Rendition Manager module.
         * @module RenditionManager
         */

            //var _mimeTypes = ['video/x-flv', 'video/mp4', 'video/x-m4v', 'video/x-f4v', 'video/m4v', 'video/f4v', 'video/webm',
            //                  'application/x-shockwave-flash', 'application/javascript', 'application/x-javascript'];
        var _mimeTypes = ['video/x-flv', 'video/x-f4v', 'video/f4v', 'video/mp4', 'video/webm', 'video/ogg',
                'application/x-shockwave-flash', 'application/javascript', 'application/x-javascript'];
        var _arrRenditions = [];
        var _priority = 0;	// 0-no priority, 1-html5 only, 2-html5 first, 3-flash only, 4-flash first
        var _cacheManager = __webpack_require__(35);

        var _logger = __webpack_require__(2);
        var _prefix = 'Rendition Manager > ';

        function normalizeRenditions(arrRenditions) {
            var arr = [];
            for (var i = 0; i < arrRenditions.length; i++) {
                var rend = arrRenditions[i];
                if (!rend.hasOwnProperty('type')) {
                    // type is required for rendition
                    continue;
                }

                if (!rend.hasOwnProperty('width')) {
                    rend.width = 0;
                }
                if (!rend.hasOwnProperty('height')) {
                    rend.height = 0;
                }
                if (!rend.hasOwnProperty('bitrate')) {
                    rend.bitrate = 0x7FFFFFFF;
                }
                arr.push(rend);
            }
            return arr;
        }

        function isFlashOnlyType(type) {
            return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
                type === 'application/x-shockwave-flash';
        }

        function isHtml5OnlyType(type) {
            return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
                type === 'application/x-javascript';
        }

        function isCompatibleType(type) {
            if (_priority === 1 && isFlashOnlyType(type)) {
                return false;
            }
            if (_priority === 3 && isHtml5OnlyType(type)) {
                return false;
            }
            for (var i = 0; i < _mimeTypes.length; i++) {
                if (type === _mimeTypes[i]) {
                    return true;
                }
            }
            return false;
        }

        function removeNotCompatibleVideoTypes() {
            for (var i = 0; i < _arrRenditions.length; ) {
                if (isCompatibleType(_arrRenditions[i].type.toLowerCase())) {
                    i++;
                }
                else {
                    _arrRenditions.splice(i, 1);
                }
            }
        }

        function getCloserSizes(width, height) {
            var arrRend = [];
            var desr = -1;
            for (var i = 0; i < _arrRenditions.length; i++) {
                if (_arrRenditions[i].width >= width && (desr === -1 || desr >= (_arrRenditions[i].width - width))) {
                    if (desr > (_arrRenditions[i].width - width)) {
                        arrRend.length = 0;
                    }
                    arrRend.push(_arrRenditions[i]);
                    desr = _arrRenditions[i].width - width;
                }
            }

            if (arrRend.length > 0) {
                _arrRenditions.length = 0;
                _arrRenditions = arrRend.slice();
            } else {
                for (i = 0; i < _arrRenditions.length; i++) {
                    if (_arrRenditions[i].width < width && (desr === -1 || desr >= (width - _arrRenditions[i].width))) {
                        if (desr > (width - _arrRenditions[i].width)) {
                            arrRend.length = 0;
                        }
                        arrRend.push(_arrRenditions[i]);
                        desr = width - _arrRenditions[i].width;
                    }
                }
                if (arrRend.length > 0) {
                    _arrRenditions.length = 0;
                    _arrRenditions = arrRend.slice();
                }
            }
            if (_arrRenditions.length === 1) {
                return;
            }

            arrRend.length = 0;
            desr = -1;
            // height
            for (i = 0; i < _arrRenditions.length; i++) {
                if (_arrRenditions[i].height >= height && (desr === -1 || desr >= (_arrRenditions[i].height - height))) {
                    if (desr > (_arrRenditions[i].height - height)) {
                        arrRend.length = 0;
                    }
                    arrRend.push(_arrRenditions[i]);
                    desr = _arrRenditions[i].height - height;
                }
            }

            if (arrRend.length > 0) {
                _arrRenditions.length = 0;
                _arrRenditions = arrRend.slice();
            } else {
                for (i = 0; i < _arrRenditions.length; i++) {
                    if (_arrRenditions[i].height < height && (desr === -1 || desr >= (height - _arrRenditions[i].height))) {
                        if (desr > (height - _arrRenditions[i].height)) {
                            arrRend.length = 0;
                        }
                        arrRend.push(_arrRenditions[i]);
                        desr = height - _arrRenditions[i].height;
                    }
                }
                if (arrRend.length > 0) {
                    _arrRenditions.length = 0;
                    _arrRenditions = arrRend.slice();
                }
            }
        }

        function matchPriority(type) {
            if (_priority === 0) {
                return true;
            }
            if (_priority === 1 && isFlashOnlyType(type)) {
                return false;
            }
            if (_priority === 3 && isHtml5OnlyType(type)) {
                return false;
            }
            return true;
        }

        function getCloserBitrates(bitrate) {
            var arrRend = [];
            var desr = -1;
            // get the lower closer bitrate rendition
            for (var i = 0; i < _arrRenditions.length; i++) {
                if (_arrRenditions[i].bitrate <= bitrate && (desr === -1 || desr >= (bitrate - _arrRenditions[i].bitrate))) {
                    if (desr > (bitrate - _arrRenditions[i].bitrate)) {
                        arrRend.length = 0;
                    }
                    desr = bitrate - _arrRenditions[i].bitrate;
                    arrRend.push(_arrRenditions[i]);
                }
            }
            if (arrRend.length > 0) {
                _arrRenditions.length = 0;
                _arrRenditions = arrRend.slice();
            } else {
                // get the higher closer bitrate rendition
                for (i = 0; i < _arrRenditions.length; i++) {
                    if (_arrRenditions[i].bitrate >= bitrate && (desr === -1 || desr >= (_arrRenditions[i].bitrate - bitrate))) {
                        if (desr > (_arrRenditions[i].bitrate - bitrate)) {
                            arrRend.length = 0;
                        }
                        desr = _arrRenditions[i].bitrate - bitrate;
                        arrRend.push(_arrRenditions[i]);
                    }
                }
            }
            if (arrRend.length === 1 || _priority === 0) {
                return arrRend[0];
            }
            else {
                if (_priority === 1 || _priority === 3) {
                    for (i = 0; i < arrRend.length; i++) {
                        if (matchPriority(arrRend[i].type.toLowerCase())) {
                            return arrRend[i];
                        }
                    }
                    return null;
                }
                else {
                    for (i = 0; i < arrRend.length; i++) {
                        if (_priority === 2 && !isFlashOnlyType(arrRend[i].type.toLowerCase())) {
                            return arrRend[i];
                        }
                        if (_priority === 4 && isFlashOnlyType(arrRend[i].type.toLowerCase())) {
                            return arrRend[i];
                        }
                    }
                    return arrRend[0];
                }
            }
        }

        function getVpaidRendition(width, height, bitrate) {
            var rend = null;
            var arrNotVpaidRend = [];
            for (var i = 0; i < _arrRenditions.length;) {
                if (!_arrRenditions[i].apiFramework || _arrRenditions[i].apiFramework.toLowerCase().indexOf('vpaid') < 0) {
                    // not vpaid
                    arrNotVpaidRend.push(_arrRenditions[i]);
                    _arrRenditions.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            if (_arrRenditions.length > 0) {
                if (_arrRenditions.length === 1) {
                    return _arrRenditions[0];
                }

                // sizes
                getCloserSizes(width, height);
                if (_arrRenditions.length === 1) {
                    rend = _arrRenditions[0];
                }
                else {
                    // bitrates
                    rend = getCloserBitrates(bitrate);
                }
            }
            if (rend === null) {
                // restore not vpaid renditions
                _arrRenditions = arrNotVpaidRend.slice();
            }
            return rend;
        }

        function setPriority(options) {
            _priority = 2;	// default priority to html5,flash order
            if (options && options.playerTechnology && Array.isArray(options.playerTechnology) && options.playerTechnology.length > 0) {
                if (options.playerTechnology.length === 1) {
                    if (options.playerTechnology[0] === 'html5') {
                        _priority = 1;
                    }
                    else {
                        _priority = 3;
                    }
                }
                else {
                    if (options.playerTechnology[0] === 'flash') {
                        _priority = 4;
                    }
                }
            }
        }

        function setNotVpaidPriority(options) {
            _priority = 2;	// default priority to html5,flash order
            if (options && options.playerTechnology && Array.isArray(options.playerTechnology) && options.playerTechnology.length > 0) {
                if (options.playerTechnology.length === 1) {
                    if (options.playerTechnology[0] === 'html5') {
                        _priority = 1;
                    }
                    else {
                        _priority = 3;
                    }
                }
            }
        }

        function addPlayerPriority(rend) {
            if (!rend) {
                _logger.error(_prefix, 'Failed to select rendition');
                return {success: false, errorCode: 403};
            }

            if (_priority === 1) {
                rend['requiredPlayer'] = 1;
            }
            else if (_priority === 3) {
                rend['requiredPlayer'] = 2;
            }
            else {
                if (isFlashOnlyType(rend.type.toLowerCase())) {
                    rend['requiredPlayer'] = 2;
                }
                else if (isHtml5OnlyType(rend.type.toLowerCase())) {
                    rend['requiredPlayer'] = 1;
                }
                else {
                    rend['requiredPlayer'] = 0;
                }
            }
            rend['success'] = true;
            _logger.info(_prefix, 'Selected rendition: ', rend);
            return rend;
        }

        function getBitrate(bitrate) {
            if (bitrate && bitrate > 0) {
                _logger.info(_prefix, 'Selected bitrate (not from cache): ' + bitrate);
                return bitrate;
            }
            var newBitrate = 1;		// take a lowest bitrate
            try {
                var temp = _cacheManager.getGenericData('anxBandwidth');
                //var temp = localStorage.getItem("anxBandwidth");
                if (temp) {
                    newBitrate = temp;
                    _logger.info(_prefix, 'Selected bitrate (from cache): ' + newBitrate);
                }
                else {
                    _logger.info(_prefix, 'No bitrate data present in cache (use bitrate 1)');
                }
            }
            catch (ex) {
                _logger.warn(_prefix, 'Exception during getting bitrate from cache (use bitrate 1)');
            }
            return newBitrate;
        }

        // iOS code start (temporary)
        function isIos() {
            //return true;
            var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase())) || (/ipad/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        }

        function getNotVpaidRendition(width, height, bitrate) {
            var rend = null;
            var arrVpaidRend = [];
            for (var i = 0; i < _arrRenditions.length;) {
                if (_arrRenditions[i].apiFramework && _arrRenditions[i].apiFramework.toLowerCase().indexOf('vpaid') === 0) {
                    // vpaid
                    arrVpaidRend.push(_arrRenditions[i]);
                    _arrRenditions.splice(i, 1);
                }
                else {
                    i++;
                }
            }
            if (_arrRenditions.length > 0) {
                if (_arrRenditions.length === 1) {
                    return _arrRenditions[0];
                }

                // sizes
                getCloserSizes(width, height);
                if (_arrRenditions.length === 1) {
                    rend = _arrRenditions[0];
                }
                else {
                    // bitrates
                    rend = getCloserBitrates(bitrate);
                }
            }
            if (rend === null) {
                // restore not vpaid renditions
                _arrRenditions = arrVpaidRend.slice();
            }
            return rend;
        }

        function processForIOS(width, height, newBitrate) {

            var rend = getNotVpaidRendition(width, height, newBitrate);
            if (rend) {
                if (matchPriority(rend.type.toLowerCase())) {
                    _logger.info(_prefix, 'Video selected for iOS');
                    return addPlayerPriority(rend);
                }
            }

            _logger.log(_prefix, 'Try select VPAID for iOS');
            if (_arrRenditions.length === 0) {
                return addPlayerPriority(null);
            }
            if (_arrRenditions.length === 1) {
                if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
                    return addPlayerPriority(_arrRenditions[0]);
                }
                else {
                    return addPlayerPriority(null);
                }
            }

            // sizes
            getCloserSizes(width, height);
            if (_arrRenditions.length === 1) {
                _logger.log(_prefix, 'VPAID rendition selected by size');
                if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
                    return addPlayerPriority(_arrRenditions[0]);
                }
                else {
                    return addPlayerPriority(null);
                }
            }

            // bitrates
            _logger.log(_prefix, 'Try select VPAID rendition by bitrate');
            return addPlayerPriority(getCloserBitrates(newBitrate));
        }
        // iOS code end

        //this will switch an order of playerTechnology if it has both flash and html5 and if the first is flash.
        function makeHtml5Preferable(_options) {
            if (_options && _options.playerTechnology && Array.isArray(_options.playerTechnology) && _options.playerTechnology.length === 2 && _options.playerTechnology[0] === "flash" && _options.playerTechnology[1] === "html5") {
                _options.playerTechnology = ["html5","flash"];
            }
            return _options;
        }

        function getUrl(width, height, bitrate, options) {

            options = makeHtml5Preferable(options);

            // set priority
            setPriority(options);

            // types
            removeNotCompatibleVideoTypes();

            var newBitrate = getBitrate(bitrate);

            // iOS code start (temporary)
            if (isIos()) {
                return processForIOS(width, height, newBitrate);
            }
            // iOS code end

            // first try to select vpaid
            var rend = getVpaidRendition(width, height, newBitrate);
            if (rend) {
                if (matchPriority(rend.type.toLowerCase())) {
                    _logger.info(_prefix, 'VPAID selected');
                    return addPlayerPriority(rend);
                }
            }

            setNotVpaidPriority(options);

            if (_arrRenditions.length === 0) {
                return addPlayerPriority(null);
            }
            if (_arrRenditions.length === 1) {
                if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
                    return addPlayerPriority(_arrRenditions[0]);
                }
                else {
                    return addPlayerPriority(null);
                }
            }

            // sizes
            getCloserSizes(width, height);
            if (_arrRenditions.length === 1) {
                _logger.log(_prefix, 'Rendition selected by size');
                if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
                    return addPlayerPriority(_arrRenditions[0]);
                }
                else {
                    return addPlayerPriority(null);
                }
            }

            // bitrates
            _logger.log(_prefix, 'Try select rendition by bitrate');
            return addPlayerPriority(getCloserBitrates(newBitrate));
        }

        function getExactSizes(width, height) {
            var arrRend = [];
            for (var i = 0; i < _arrRenditions.length; i++) {
                if (_arrRenditions[i].width === width && _arrRenditions[i].height === height) {
                    arrRend.push(_arrRenditions[i]);
                }
            }

            _arrRenditions.length = 0;
            if (arrRend.length > 0) {
                _arrRenditions = arrRend.slice();
            }
        }

        function removeSelectedCompanionFromArray(arrCompanions, id) {
            for (var i = 0; i < arrCompanions.length; i++) {
                if (arrCompanions[i].id === id) {
                    arrCompanions.splice(i, 1);
                    break;
                }
            }
        }

        function selectCompanions(companionAds, containers) {
            // validation
            if (!companionAds || companionAds.companions.length === 0 ||
                !containers || containers.length === 0) {
                return;
            }

            // generate rendition array from companionAds
            _arrRenditions = [];
            for (var i = 0; i < companionAds.companions.length; i++) {
                var companion = companionAds.companions[i];
                var rendition;
                try {
                    rendition = Object.assign({}, companion);
                }
                catch(ex) {
                    try {
                        var str = JSON.stringify(companion);
                        rendition = JSON.parse(str);
                    }
                    catch(ex) {
                        continue;
                    }
                }
                rendition.id = i;
                rendition.type = 'unknown';
                if (companion.hasOwnProperty('StaticResource')) {
                    rendition.type = companion.StaticResource.type;
                }

                _arrRenditions.push(rendition);
            }

            if (_arrRenditions.length === 0) {
                return;
            }

            var saveRenditions = _arrRenditions.slice();
            for (i = 0; i < containers.length && saveRenditions.length > 0; i++) {
                var container = containers[i];

                _arrRenditions.length = 0;
                _arrRenditions = saveRenditions.slice();

                // sizes
                getExactSizes(container.width, container.height);
                if (_arrRenditions.length === 1) {
                    _logger.log(_prefix, 'Companion rendition selected by size');
                    container.companion = _arrRenditions[0];
                    // make sure we will not select same companions from different containers
                    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
                    continue;
                }
                if (_arrRenditions.length === 0) {
                    _logger.log(_prefix, 'Companion rendition not selected for container');
                    container.companion = null;
                    continue;
                }

                // check for vpaid
                var bFound = false;
                for (var j = 0; j < _arrRenditions.length; j++) {
                    if (_arrRenditions[j].apiFramework && _arrRenditions[j].apiFramework.toLowerCase().indexOf('vpaid') < 0) {
                        _logger.log(_prefix, 'Companion rendition selected by apiFramework');
                        container.companion = _arrRenditions[j];
                        // make sure we will not select same companions from different containers
                        removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
                        bFound = true;
                        break;
                    }
                }

                if (!bFound) {
                    // select the first one
                    _logger.log(_prefix, 'First companion rendition selected');
                    container.companion = _arrRenditions[0];
                    // make sure we will not select same companions from different containers
                    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
                }
            }
        }


        module.exports = {
            /** Describe Rendition manager Initialization.
             * @param {array} arrRenditions - array of available renditions.
             */
            init: function(arrRenditions) {
                _arrRenditions = normalizeRenditions(arrRenditions);
            },

            /** Describe Rendition manager Main Entry Point Here.
             * @param {number} width - video player width in pixels.
             * @param {number} height - video player height in pixels.
             * @param {number} bitrate - bitrate in Kbps.
             * @param {object} options - options from impbus request.
             * @return {object} return rendition object with all vast information for media file.
             * 		Additionally the property requiredPlayer, success, and errorCode added to the output object.
             * 		requiredPlayer value: 0 - any, 1 - html5, 2 - flash
             * 		success value: true is success, false otherwise (if false errorCode is added)
             * 		errorCode value: VAST error code
             */
            getUrl: function(width, height, bitrate, options) {
                return getUrl(width, height, bitrate, options);
            },

            /** Describe Rendition manager companions selection.
             * @param {object} companionAds - video player width in pixels.
             * 		required - 'required' property from CompanionAds node if present
             * 		companions - array of objects represents Companion nodes
             * @param {array} containers - array of objects represents containers for companions on page.
             * 		each of container object has to have the following properties:
             * 		id - internal identificator
             * 		width - widthy of container
             * 		height - height of container
             * 		companion - pointer to companion object in companionAds.companions (generated by current call)
             */
            selectCompanionsForContainers: function(companionAds, containers) {
                selectCompanions(companionAds, containers);
            }
        };


        /***/ },
    /* 37 */
    /***/ function(module, exports, __webpack_require__) {

        /**
         * Tracking Manager module.
         * @module TrackingManager
         */

        /**
         * @description Unified Tracking Event Names
         * Tracking events will be stored under the following names.
         * These are the names that should be used when requesting tracking for an event
         * Names being passed in from parsing or other structures will be mapped to these events.
         * 	- bid-impression
         *  - network-request
         *  - network-response
         * 	- impression
         * 	- video-start
         *  - video-first-quartile
         *  - video-mid
         *  - video-third-quartile
         *  - video-complete
         *  - ad-click
         *  - video-pause
         *  - video-rewind
         *  - video-resume
         *  - audio-mute
         *  - audio-unmute
         *  - video-fullscreen
         *  - video-exit-fullscreen
         *  - creative-view
         *  - ad-expand
         *  - ad-collapse
         *  - user-accept-invitation
         *  - user-close
         *  - ad-progress
         *  - error
         * If an eventName cannot be mapped (for custom cases), then the name passed in will be used to store the set of video urls.
         */
            /////////////////////////////////////////
            // VARIABLES
            /////////////////////////////////////////
            // CONSTANTS
            //var ERROR_TYPE_GENERAL = 0;
        var ERROR_TYPE_VAST = 1;
        //var ERROR_TYPE_HTTP = 2;
        var VAST_ERROR_MACRO = "[ERRORCODE]";
        var DEFAULT_KEY = "AN_DEFAULT";

        /////////////////////////////////////////
        // VARIABLES
        var tracker = __webpack_require__(33);
        var utils = __webpack_require__(34);

        var prefix = "TM";
        var trackingEvents = {};


        //////////////////////////////////////////
        // Log methods as following https://corpwiki.appnexus.com/pages/viewpage.action?spaceKey=SSV&title=Client+Side+JS+Browser+Console+Logging+Proposal
        var APN_Logger = __webpack_require__(2);
        // var always = function (message) {
        //     //log level 1
        //     APN_Logger.always(prefix, message);
        // };
        // var error = function (message) {
        //     //log level 2
        //     APN_Logger.error(prefix, message);
        // };
        var warn = function (message) {
            //log level 3
            APN_Logger.warn(prefix, message);//for such a case of network related like "url not found"
        };
        var info = function (message) {//for only initial tracking request
            //log level 4
            APN_Logger.info(prefix, message);
        };
        var log = function (message) {//for additional tracking request following intial trackings if it's required
            //log level 5
            APN_Logger.log(prefix, message);
        };
        // var debug = function (message) {
        //     //log level 6
        //     APN_Logger.debug(prefix, message);
        // };
        var verbose = function (message) {
            //log level 7
            APN_Logger.verbose(prefix, message);//for a registration part
        };






        /////////////////////////////////////////
        // CREATING TRACKING EVENTS DATA STRUCTURE
        // reset the trackingEvents object
        function initTrackingEventsObject(){
            trackingEvents = {};
        }

        // create a default tracking event object for a particular event
        // this function assumes that that eventName has been normalized
        // default setting for reportOnce is true
        function createTrackingEventObject(eventName, adId){
            if (!trackingEvents) {
                trackingEvents = {};
            }

            adId = adId || DEFAULT_KEY;

            if (!trackingEvents[adId]) {
                trackingEvents[adId] = {};
            }

            var obj = {};
            obj.isImpression = false;
            obj.reportOnce = true;
            obj.reported = false;
            obj.urls = [];

            trackingEvents[adId][eventName] = obj;
            verbose("tracking data created, adId=" + adId + ", event=" + eventName);
        }

        // normalize all tracking events into standard names
        // unknown names will use the eventName passed in
        function normalizeTrackingEventName(eventName) {
            var answer = eventName;

            // map eventnames found in VAST tags or appnexus structure to standard tracking event name
            switch (eventName) {
                case "impressionUrls" :
                    answer = "impression";
                    break;

                case "clickTrackingUrls" :
                case "click" :
                    answer = "ad-click";
                    break;

                case "errorUrls" :
                    //answer = "vast-error";
                    answer = "error";
                    break;

                case "imp_tracking_url" :
                    answer = "bid-impression";
                    break;

                case "init_cb" :
                    answer = "ad-request";
                    break;

                case "result_cb" :
                    answer = "ad-response";
                    break;

                case "start" :
                    answer = "video-start";
                    break;

                case "firstQuartile" :
                    answer = "video-first-quartile";
                    break;

                case "midpoint" :
                    answer = "video-mid";
                    break;

                case "thirdQuartile" :
                    answer = "video-third-quartile";
                    break;

                case "thirdQuartile" :
                    answer = "video-third-quartile";
                    break;

                case "complete" :
                    answer = "video-complete";
                    break;

                case "unmute" :
                    answer = "audio-unmute";
                    break;

                case "mute" :
                    answer = "audio-mute";
                    break;

                case "pause" :
                    answer = "video-pause";
                    break;

                case "rewind" :
                    answer = "video-rewind";
                    break;

                case "resume" :
                    answer = "video-resume";
                    break;


                case "fullscreen" :
                    answer = "video-fullscreen";
                    break;

                case "exitFullscreen" :
                    answer = "video-exit-fullscreen";
                    break;

                case "creativeView" :
                    answer = "creative-view";
                    break;

                case "expand" :
                    answer = "ad-expand";
                    break;

                case "collapse" :
                    answer = "ad-collapse";
                    break;

                case "acceptInvitation" :
                    answer = "user-accept-invitation";
                    break;

                case "close" :
                    answer = "user-close";
                    break;

                case "progress" :
                    answer = "ad-progress";
                    break;

                case "skip" :
                    answer = "video-skip";
                    break;
            }

            return answer;
        }

        /////////////////////////////////////////
        // ADDING TRACKING EVENTS TO TRACKING MANAGER
        // adds a tracking url for the specified eventName
        // if an event object for that eventName does not already exist,
        // it will be created with default values
        function addTrackingUrlForEvent(eventName, trackingUrl, adId) {
            adId = adId || DEFAULT_KEY;

            eventName = normalizeTrackingEventName(eventName);

            if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
                createTrackingEventObject(eventName, adId);
            }

            trackingEvents[adId][eventName].urls.push(trackingUrl);
            verbose("Tracking added, adId=" + adId + ", event=" + eventName + ", url=" + trackingUrl);
        }

        // create a mediation event name for a specific network
        // this will be the key where the tracking urls are stored
        // as well as the key for looking up the tracking urls for a mediation event for a network
        function createMediationEventName(eventName, networkName) {
            var answer = "";

            if (utils.isNotEmpty(eventName) && utils.isNotEmpty(networkName)) {
                eventName = normalizeTrackingEventName(eventName);
                answer = eventName + "_" + networkName;
            }

            return answer;
        }

        ////////////////////////////////////////////////////////////////////////////
        // CONTROLLING TRACKING
        //returns true if the event name is considered an impression tracker
        //otherwise returns false
        function isImpressionEvent(eventName, adId) {
            adId = adId || DEFAULT_KEY;

            var answer = false;

            var eventObj = trackingEvents[adId][eventName];
            if (eventObj && eventObj.hasOwnProperty("isImpression")) {
                answer = (eventObj.isImpression === true);
            }

            return answer;
        }

        // sets property to control whether an event can be reported only once
        // if it is a mediation tracking event - you need to also pass in the networkName
        // and the eventName will be a combination of the event name and the network name
        // true = report only once, false = may be reported multiple times
        function setReportOnlyOnce(eventName, restricted, adId) {
            adId = adId || DEFAULT_KEY;

            if (utils.isNotEmpty(eventName)) {
                if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
                    createTrackingEventObject(eventName, adId);
                }

                var eventObj = trackingEvents[adId][eventName];
                eventObj.reportOnce = restricted;
                verbose("setting report once, adId=" + adId + ", event=" + eventName + ", setting=" + restricted);
            }
        }

        // sets property to control whether an event can be reported only once
        // if it is a mediation tracking event - you need to also pass in the networkName
        // and the eventName will be a combination of the event name and the network name
        // true = report only once, false = may be reported multiple times
        function setReportOnlyOnceMediation(eventName, restricted, networkName, adId) {
            adId = adId || DEFAULT_KEY;

            if (utils.isNotEmpty(eventName)) {
                // normalize the event name, adding in the network name if specified
                eventName = normalizeTrackingEventName(eventName);
                if (utils.isNotEmpty(networkName)) {
                    eventName = createMediationEventName(eventName, networkName);
                }

                if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
                    createTrackingEventObject(eventName, adId);
                }

                var eventObj = trackingEvents[adId][eventName];
                eventObj.reportOnce = restricted;
                verbose("setting report once, adId=" + adId + ", event=" + eventName + ", setting=" + restricted);
            }
        }

        // resets the reported flag back to false for all the events with the exception of impression events
        // if the resetImpression arg is true, then impression events will also be reset to false
        function resetTrackingEventReported(resetImpression, adId) {
            adId = adId || DEFAULT_KEY;

            if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
                var adObject = trackingEvents[adId];
                for (var eventName in adObject) {
                    if (isImpressionEvent(eventName, adId) && !resetImpression) {
                        verbose("reset history skipping impression event=" + eventName + ", adId=" + adId);
                    }
                    else {
                        var eventObj = trackingEvents[adId][eventName];
                        eventObj.reported = false;
                        verbose("reset history for adId= " + adId + ", event=" + eventName);
                    }
                }
            }
        }

        // marks an event as an impression type
        // used when resetting reporting history -
        // you may or may not want to also reset impression events
        function setEventAsImpression(eventName, isImpression, adId){
            adId = adId || DEFAULT_KEY;

            eventName = normalizeTrackingEventName(eventName);

            if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
                createTrackingEventObject(eventName, adId);
            }

            trackingEvents[adId][eventName].isImpression = isImpression;
        }


        /////////////////////////////////////////
        // EXECUTING TRACKING EVENTS

        //passes the url over to the module that will actually hit the tracking pixel
        //defined for a particular event
        function hitTrackingUrl(url, eventName){
            log("requesting tracking for " + eventName + ", url=" + url);
            tracker.trackPixel(url, eventName);
        }

        //add a param value at the end of a url as a query string value
        //e.g. ?error=123
        //if the url already contains some query string parameters
        //meaning that the ? is already there
        //append the parameter using the &
        function addParameterAsQueryString(url, paramValue) {
            var answer = url;

            var delimiter = "?";
            if (url.indexOf("?") > -1) {
                delimiter = "&";
            }

            answer = url + delimiter + paramValue;

            return answer;
        }


        //replace the macro with the param value
        //this function assumes that you have already checked to make sure
        //that the macro is present
        //if the macro is not found, then the url will be unchanged
        function addParameterAsMacro(url, paramValue, macroValue) {
            var answer = url;

            if (url.indexOf(macroValue) > -1){
                answer = url.replace(macroValue, paramValue);
            }

            return answer;
        }



        //adds a specified parameter to a stored tracking url
        //param is an object which may contain two fields:
        //		- value (required) = value should be added to the tracking url
        //		= macro (optional) = macro which will be replaced with the value
        //if a macro is not specified or if the macro is not found in the url,
        //then the param will be added at the end as a query string parameter
        function addParameterToTrackingUrl(url, param) {
            if (param) {
                // get the value to add to the url
                var val = param.value;
                val = (val && typeof(val) === "number") ? val.toString() : val;//work-around of a bug of isNotEmpty function, isNotEmpty could return false if parameter is integrer and it will be a consequence to not perform the macro substition for VID-2120
                if (utils.isNotEmpty(val)) {
                    // check to see if there if a macro
                    var macro = param.macro;
                    if (utils.isNotEmpty(macro)) {
                        // check to see if the url contains the macro
                        // if so add the parameter as a macro replacement
                        if (url.indexOf(macro) > -1) {
                            url = addParameterAsMacro(url, val, macro);
                        }
                    }
                    else {
                        // a macro was not specified
                        // so add the parameter as a query string parameter
                        url = addParameterAsQueryString(url, val);
                    }
                }
            }

            return url;
        }

        // Reports all tracking urls associated with a particular tracking event name
        function trackEvent(eventName, param, adId){
            adId = adId || DEFAULT_KEY;

            var fnd = false;
            if (trackingEvents.hasOwnProperty(adId) && trackingEvents[adId].hasOwnProperty(eventName)) {
                var eventObj = trackingEvents[adId][eventName];
                if (eventObj){
                    // check to make sure that the event may be reported more than once
                    // or, if it can be reported only once, that it has not already been reported
                    if ((eventObj.reportOnce) && (eventObj.reported)) {
                        info("Cannot report event - event has already been reported: " + eventName + " for adId=" + adId);
                        fnd = true;
                    }
                    else {
                        var urls = eventObj.urls;
                        if (urls) {
                            eventObj.reported = true;
                            for (var i = 0; i < urls.length; i++) {
                                var url = urls[i];
                                if (utils.isNotEmpty(url)) {
                                    fnd = true;
                                    if (param) {
                                        url = addParameterToTrackingUrl(url, param);
                                    }
                                    hitTrackingUrl(url, eventName);
                                }
                            }
                        }
                    }
                }
            }

            if (!fnd) {
                warn("No tracking urls found for adId=" + adId + ", event = " + eventName);
            }
        }


        /////////////////////////////////////////
        // ADDING PARAMETERS TO TRACKING URLS
        // creates a param object for mediation events
        // each field in the object will be a key and the value of the field will be the value
        // the resulting string
        function createMediationTrackingParams (params){
            verbose("Creating params for mediation tracking from obj: " + utils.objectToString(params));
            var answer = {};
            var paramString = "";

            if (params) {
                for (var key in params) {
                    if (params[key] !== null && params[key] !== 'undefined'){
                        if (paramString.length > 0) {
                            paramString += "&";
                        }
                        var str = key + "=" + params[key];
                        paramString += str;
                    }
                }
            }

            answer.value = paramString;
            return answer;
        }


        // reports all tracking urls for a specific event and network
        // params will be added ot the tracking urls
        function trackMediationEvent(eventName, networkName, params, adId) {
            var ename =  createMediationEventName(eventName, networkName);
            var paramObj = createMediationTrackingParams(params);
            trackEvent(ename, paramObj, adId);
        }






        // create an event name for a progress event for a particular offset
        function createProgressEventName(offset) {
            return ("progress>" + offset);
        }
        /////////////////////////////////////////////////////////////////
        // CLEAN UP
        function removeEventsForKey(key, adId) {
            adId = adId || DEFAULT_KEY;
            if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
                var eventList = trackingEvents[adId];
                for (var field in eventList) {
                    // data.substring(0, input.length) === input
                    if (field.indexOf(key) > -1) {
                        delete trackingEvents[adId][field];
                        verbose("Removing event: " + field + " for key=" + key + " and adId=" + adId);
                    }
                }
                if (trackingEvents[adId].length === 0) {
                    delete trackingEvents[adId];
                }
            }
        }

        function removeEvents(adId) {
            adId = adId || DEFAULT_KEY;
            if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
                var eventList = trackingEvents[adId];
                delete trackingEvents[adId];
                for (var event in eventList) {
                    verbose("Removing event: " + event + " for adId=" + adId);
                }
            }
        }

        ////////////////////////////////////////////////////////////////
        // EXPORTS
        module.exports = {
            /**
             * Resets all the data structures for the Tracking Manager
             * @param(array) unrestrictedEventsList - an array of eventNames for events that may be reported more than once
             * 	by default, tracking events are reported only once
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            init : function(unrestrictedEventsList, adId){
                removeEvents(adId);
                if (unrestrictedEventsList) {
                    for (var i = 0; i < unrestrictedEventsList.length; i++) {
                        setReportOnlyOnce(unrestrictedEventsList[i], false, adId);
                    }
                }
            },

            /**
             * Add a tracking event to the set of tracking events
             * being managed by the Tracking Manager
             * @param (string) eventName - name of the event to be tracked
             * @param (string) trackingUrl - tracking url to "hit" whenever this event is reported
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            addTrackingEvent: function(eventName, trackingUrl, adId){
                addTrackingUrlForEvent(eventName, trackingUrl, adId);
            },

            /**
             * Merge the tracking events provided in the argument with
             * the set of tracking events being managed by the Tracking Manager
             * @param (json) trackingObject - object which contains a set of tracking events with associated tracking urls
             * 		- each field name in trackingObject is the name of a tracking event (e.g. "video-start")
             * 		- the value of each field is an array of tracking urls - even if there is only one tracking url
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            addTrackingEvents: function(trackingObject, adId){
                if (trackingObject) {
                    for (var eventName in trackingObject) {
                        var urls = trackingObject[eventName];
                        if (utils.isNotEmpty(urls)){
                            for (var i = 0; i < urls.length; i++) {
                                addTrackingUrlForEvent(eventName, urls[i], adId);
                            }
                        }
                    }
                }
            },

            /**
             * Add tracking events that are used when running client side mediation
             * each url is network dependent so the event name stored in Tracking Manager
             * will contain both the event name and the network name
             * @param (string) eventName = name of tracking event that will be requested
             * 		- eventName will be normalized to a standardized name if needed
             * @param (string) networkName = identifier which uniquely identifies a network to hit for mediation
             * 		- initially this name will be internally generated
             * @param (string) trackingUrl = tracking url to "hit" whenever this event is reported
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            addMediationTrackingEvent : function(eventName, networkName, trackingUrl, adId) {
                var ename = createMediationEventName(eventName, networkName);
                verbose("creating event name for adId=" + (adId ? adId : DEFAULT_KEY) + ", event=" + eventName + ", networkName=" + networkName + " =>" + ename);
                addTrackingUrlForEvent(ename, trackingUrl, adId);
            },

            /**
             * adds a tracking url for a progress event for a particular offset (as defined in the VAST xml)
             * @param (string) offset = some time when this event should be reported
             * 	- this can be a elapsed time in HH:MM:SS or HH:MM:SS.mmm or a %
             * @param (string) trackingUrl = url that is to be hit when this event is to be tracked
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            addProgressTrackingEvent : function (offset, trackingUrl, adId) {
                var eventName = createProgressEventName(offset);
                addTrackingUrlForEvent(eventName, trackingUrl, adId);
            },

            /**
             * Marks an event as an "impression event" - this is used when resetting the reporting history
             * @param (string) eventName = name of event - this name will be normalized
             * @param (boolean) isImpression
             * 		- true = event is an impression event
             * 		- false = event is NOT an impression event
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            markAsImpressionEvent : function(eventName, isImpression, adId) {
                verbose("marking event as impression: " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY) + ", value=" + isImpression);
                setEventAsImpression(eventName, isImpression, adId);
            },

            /**
             * Marks an event as an "impression event" - this is used when resetting the reporting history
             * @param (string) eventName = name of event - this name will be normalized
             * @param (boolean) isImpression
             * 		- true = event is an impression event
             * 		- false = event is NOT an impression event
             * @param (string) networkName = name of a network that is involved in mediation events
             * 		- use only when the event is conisdered to be a mediation event
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            markAsMediationImpressionEvent : function(eventName, isImpression, networkName, adId) {
                if (utils.isNotEmpty(networkName)) {
                    eventName = createMediationEventName(eventName, networkName);
                }

                verbose("marking event as impression: " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY) + ", value=" + isImpression);
                setEventAsImpression(eventName, isImpression, adId);
            },

            /**
             * Mark a tracking event as being "report-only-once", meaning that if the event has already been
             * reported, do not report it again.
             * There will be another method that will reset all the reporting settings, if needed
             * @param (string) eventName - the name of the tracking event
             * @param (boolean) restricted - indicates whether the event may only be reported once
             * 		- true = event will only be reported once (default)
             * 		- false = event will be reported every time it is requested
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            reportOnlyOnce : function(eventName, restricted, adId) {
                setReportOnlyOnce(eventName, restricted, adId);
            },

            /**
             * Mark a tracking event as being "report-only-once", meaning that if the event has already been
             * reported, do not report it again.
             * There will be another method that will reset all the reporting settings, if needed
             * @param (string) eventName - the name of the tracking event
             * @param (boolean) restricted - indicates whether the event may only be reported once
             * 		- true = event will only be reported once (default)
             * 		- false = event will be reported every time it is requested
             * @param (string) networkName = name of network
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            reportMediationOnlyOnce : function(eventName, restricted, networkName, adId) {
                setReportOnlyOnceMediation(eventName, restricted, networkName, adId);
            },

            /**
             * Clears tracking reporting history - used in the case where the ad is being re-played
             * and the ad unit wants to be able to re-report video events and other events
             * or the player is being used for another ad
             * @param (boolean) resetImpression - indicates whether impression events should also be reset
             * 		- true = also reset the impression events
             * 		- false = do NOT reset the impression events
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            resetTrackingHistory : function(resetImpression, adId) {
                resetTrackingEventReported(resetImpression, adId);
            },

            /**
             * request tracking for a tracking event
             * @param(string) eventName - name of the event being tracked
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            requestTracking : function(eventName, adId){
                info("tracking requested for " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY));
                trackEvent(eventName, null, adId);
            },

            /**
             * request tracking for a tracking event that requires a parameter (such as error reporting)
             * @param (string) eventName - name of event being tracked
             * @param (object) param - object containing information about parameters to add to tracking url
             * 		- value = field in object identifying the value to add to the tracking url
             * 		- macro = (optional) field in object identifying a macro present in the tracking url where to place
             * 					the value
             * 		- if macro field is missing or empty, then the param will be added at the end as a query string param
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            requestParamTracking : function(eventName, param, adId){

                info("tracking requested for " + eventName + " with param=" + utils.objectToString(param) + ", adId=" + (adId ? adId : DEFAULT_KEY));
                trackEvent(eventName, param, adId);
            },

            /**
             * request tracking for a mediation related event for a specific network
             * parameters may also be optionally passed in to add to the tracking url
             * @param (string) eventName = name of the event being tracked
             * @param (string) networkName = name identifying the network for whom the event is being tracked
             * @param (json) params = optional object containing parameters that need to be added to the tracking url
             * 		- will contain fields which will be used to create query string params that will
             * 			be added to the end of a mediation tracking url
             * 			example: reason: 0, latency_type: 1, latency: 1500}
             * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            requestMediationTracking : function(eventName, networkName, params, adId) {
                info("tracking requested for mediation event: " + eventName + ", network=" + networkName + " , params=" + utils.objectToString(params) + ", adId=" + (adId ? adId : DEFAULT_KEY));
                trackMediationEvent(eventName, networkName, params, adId);
            },

            /**
             * request tracking for an error condition
             * @param (integer) errorCode = error code identifying the error condition
             * @param (integer) errorType = identifies the type of error (this controls how this is reported); can be one of the following
             * 		0 = general appnexus error
             * 		1 = vast-error (one of the error codes specified in the VAST spec)
             * 		2 = http error
             * @param (string) errorDescription = string used primarily for logging the error
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            requestErrorTracking : function (errorCode, errorType, errorDescription, adId) {
                info("error reported: " + errorCode + ", type=" + errorType + ", desc=" + errorDescription, + ", adId=" + (adId ? adId : DEFAULT_KEY));
                var paramObj = {};
                var eventName = "";

                // check to see if it is a VAST error (which requires macro substitution)
                switch (errorType) {
                    case ERROR_TYPE_VAST :
                        paramObj.macro = VAST_ERROR_MACRO;
                        paramObj.value = errorCode;
                        //eventName = "vast-error";	// note we have to collapse vast errors and errors into errors because impbus also returns error tracking url
                        eventName = "error";
                        break;

                    default :
                        paramObj.value = ("error=" + errorCode);
                        eventName = "error";
                }

                this.requestParamTracking(eventName, paramObj, adId);
            },

            /**
             * request tracking for a progress event for a particular offset
             * @param (string) offset = some time when this event should be reported
             * 	- this can be a elapsed time in HH:MM:SS or HH:MM:SS.mmm or a %
             *  - NOTE: the offset being passed must be exact same format as how the event was created
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            requestProgressTracking : function (offset, adId) {
                var eventName = createProgressEventName(offset);

                info("Tracking requested for progress event, adId=" + (adId ? adId : DEFAULT_KEY) + ", offset=" + offset);
                this.requestTracking(eventName, adId);
            },

            /**
             * clears all the events from the tracking events data structure with adId=adId (or default)
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             *      - if an adId is passes into the function, will remove all events associated with the adId
             *      - if no adId is passed, will remove all events associated with the default adId
             */
            removeEvents : function(adId) {
                removeEvents(adId);
            },

            /**
             * clears all the events from the tracking events data structure with an eventName starting with 'key'
             * optional adId parameter to search through ads associated with a particular adId
             * @param (string) key = string to identify a set of tracking data for a particular set
             * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
             */
            removeEventsForKey : function(key, adId) {
                removeEventsForKey(key, adId);
            },

            /**
             * clears all events from tracking events data structure
             * only use if you are sure you want to remove all events regardless of adId
             */
            removeAllEvents : function() {
                initTrackingEventsObject();
            }
        };

        /***/ },
    /* 38 */
    /***/ function(module, exports, __webpack_require__) {

        var APN_RenditionManager = __webpack_require__(36);
        var APN_Logger = __webpack_require__(2);
        var _prefix = "CompanionsHandler > ";

        var CompanionHandler = function(containerElement, width, height, companionData, notifCallback) {
            var _containerElement = containerElement;
            var _companionData = companionData;
            var _notificationCallback = notifCallback;
            var _containerSize = {width: width, height: height};

            var _uniqueId = new Date().getTime() + Math.floor(Math.random() * 10000);

            // register companion trackings
            _notificationCallback({command: 'addTrackingEvents', uniqueId: _uniqueId, data: _companionData});

            var onClick = function() {
                if (_companionData.CompanionClickTracking) {
                    _notificationCallback({command: 'requestTracking', uniqueId: _uniqueId, data: 'companion-click'});
                }
                if (_companionData.hasOwnProperty('StaticResource') && _companionData.CompanionClickThrough) {
                    window.open(_companionData.CompanionClickThrough);
                }
            };

            var onLoad = function() {
                if (_companionData.TrackingEvents && _companionData.TrackingEvents.length > 0) {
                    _notificationCallback({command: 'requestTracking', uniqueId: _uniqueId, data: 'creative-view'});
                }
            };

            var _needClickHandler = true;
            if (_companionData.hasOwnProperty('StaticResource')) {
                var type = _companionData.StaticResource.type;
                if (type === 'application/x-javascript') {
                    var script = document.createElement('script');
                    script.src = _companionData.StaticResource.src;
                    script.onload = onLoad();
                    _containerElement.appendChild(script);
                }
                else if (type === 'application/x-shockwave-flash') {
                    var flashObj = document.createElement("object");
                    flashObj.type = 'application/x-shockwave-flash';
                    flashObj.data = _companionData.StaticResource.src;
                    flashObj.width = _containerSize.width;
                    flashObj.height = _containerSize.height;
                    flashObj.style.top = '0';
                    flashObj.style.left = '0';
                    flashObj.style.width = _containerSize.width + "px";
                    flashObj.style.height = _containerSize.height + "px";

                    var par1 = document.createElement('param');
                    par1.name = 'allowNetworking';
                    par1.value = 'all';
                    flashObj.appendChild(par1);
                    var par2 = document.createElement('param');
                    par2.name = 'wmode';
                    par2.value = 'opaque';
                    flashObj.appendChild(par2);
                    flashObj.onload = onLoad();
                    _needClickHandler = false;
                    _containerElement.appendChild(flashObj);
                }
                else if (type.indexOf('image') === 0) {
                    // image
                    var img = document.createElement('img');
                    img.src = _companionData.StaticResource.src;
                    img.style.maxWidth = '100%';
                    img.style.maxHeight = '100%';
                    img.style.width = 'auto';
                    img.style.height = 'auto';
                    img.style.margin = 'auto';
                    img.style.display = 'block';
                    img.style.top = 0;
                    img.style.bottom = 0;
                    img.style.left = 0;
                    img.style.right = 0;
                    img.style.position = 'absolute';
                    img.onload = onLoad();
                    img.onclick = onClick;
                    _needClickHandler = false;
                    img.style.cursor = 'pointer';
                    _containerElement.style.display = 'inline-block';
                    _containerElement.style.position = 'relative';
                    _containerElement.appendChild(img);
                }
            }
            else if (_companionData.hasOwnProperty('IFrameResource')) {
                var iframe = document.createElement('iframe');
                iframe.src = _companionData.IFrameResource;
                iframe.scrolling = 'no';
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.overflow = 'hidden';
                iframe.onload = onLoad();
                _needClickHandler = false;
                _containerElement.appendChild(iframe);
            }
            else if (_companionData.hasOwnProperty('HTMLResource')) {
                if (_companionData.HTMLResource.indexOf('http') === 0) {
                    var UrlLoader = __webpack_require__(33);
                    UrlLoader.load(_companionData.HTMLResource,
                        function(error, responseText) {
                            if (error || responseText.length === 0) {
                                // _notificationCallback
                            }
                            else {
                                _containerElement.style.display = 'inline-block';
                                _containerElement.style.position = 'relative';
                                _containerElement.innerHTML = responseText;
                                onLoad();
                            }
                        });
                }
                else {
                    _containerElement.style.display = 'inline-block';
                    _containerElement.style.position = 'relative';
                    _containerElement.innerHTML = _companionData.HTMLResource;
                    onLoad();
                }
            }
            if (_needClickHandler) {
                if (_companionData.hasOwnProperty('StaticResource') && _companionData.CompanionClickThrough) {
                    _containerElement.style.cursor = 'pointer';
                }
                _containerElement.onclick = onClick;
            }

            this.stop = function() {
                _containerElement.innerHTML = '';
            };
        };

        var CompanionsHandler = function(companionAds, options, notifCallback) {
            var _companionAds = companionAds;
            var _options = options;
            var _notificationCallback = notifCallback;

            var _companions = [];

            APN_Logger.always(_prefix, 'Version: 0.1.7');

            var containersData = [];
            for (var i = 0; i < _options.companionContainers.length; i++) {
                try {
                    var styles = window.getComputedStyle(_options.companionContainers[i], null);
                    var obj = {id:i, width: parseInt(styles.width), height: parseInt(styles.height), companion: null};
                    containersData.push(obj);
                }
                catch(ex) {}
            }
            APN_RenditionManager.selectCompanionsForContainers(_companionAds, containersData);
            for (i = 0; i < containersData.length; i++) {
                if (containersData[i].companion) {
                    var companion = new CompanionHandler(_options.companionContainers[i], containersData[i].width, containersData[i].height,
                        containersData[i].companion, _notificationCallback);
                    _companions.push(companion);
                }
            }

            this.stop = function() {
                for (i = 0; i < _companions.length; i++) {
                    _companions[i].stop();
                }
                _companions.length = 0;
            };
        };

        var trimXml = function(strVastXml) {
            var nPos = strVastXml.indexOf('<');
            var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
            nPos = strXml.lastIndexOf('>');
            if (nPos !== -1) {
                strXml = strXml.substr(0, nPos + 1);
            }
            return strXml.trim();
        };

        var parseCompanions = function(strXml) {
            if (strXml.length === 0) {
                APN_Logger.warn(_prefix, 'parseCompanions > empty companions xml');
                return null;
            }
            strXml = trimXml(strXml);
            if (strXml.substr(0,13) !== '<CompanionAds') {
                strXml = '<CompanionAds>' + strXml + '</CompanionAds>';
            }
            var xmlDoc = null;
            if (typeof window.DOMParser !== 'undefined') {
                xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
                if (xmlDoc.documentElement.nodeName === 'parsererror') {
                    try{
                        APN_Logger.error(_prefix, 'parseCompanions > Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
                    }
                    catch(e) {}
                    APN_Logger.warn(_prefix, 'parseCompanions > invalide xml structure');
                    return null;
                }
            }
            else if (typeof window.ActiveXObject !== 'undefined') {
                try {
                    xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
                    xmlDoc.loadXML(strXml);
                    if (xmlDoc.parseError.errorCode !== 0) {
                        APN_Logger.error(_prefix, xmlDoc.parseError);
                        return null;
                    }
                }
                catch (ex) {
                    APN_Logger.error(_prefix, 'parseCompanions > Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
                    return null;
                }
            }
            else {
                APN_Logger.error(_prefix, 'parseCompanions > Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
                return null;
            }
            if (!xmlDoc) {
                APN_Logger.error(_prefix, 'parseCompanions > invalid xml structure');
                return null;
            }

            var APN_CompanionAdsParser = __webpack_require__(39);
            var companionsObj = APN_CompanionAdsParser.parse(xmlDoc);
            return companionsObj;
        };

        module.exports = {
            renderCompanions: function(companionAds, options, fnCallback) {
                APN_Logger.log(_prefix, 'renderCompanions called.');
                var companions = new CompanionsHandler(companionAds, options, fnCallback);
                return companions;
            },

            stopCompanions: function(companionsObj) {
                if (companionsObj) {
                    companionsObj.stop();
                }
            },

            parse: function(strCompanions) {
                return parseCompanions(strCompanions);
            }
        };

        /***/ },
    /* 39 */
    /***/ function(module, exports) {

        var CompanionAdsParser = {

            parse: function (xmlDoc) {
                var companionAdsDest = {companions: []};

                var VastXMLParserHelper = function () {
                    this.getSubNodes = function (node, subNodeName) {
                        var nodes = node.getElementsByTagName(subNodeName);
                        if (nodes.length > 0) {
                            return nodes;
                        }
                        return null;
                    };

                    this.getSubNode = function (node, subNodeName, index) {
                        if (!index) {
                            index = 0;
                        }
                        var nodes = node.getElementsByTagName(subNodeName);
                        if (nodes.length > index) {
                            return nodes[index];
                        }
                        return null;
                    };

                    this.getNodeValue = function (node) {
                        if (node.childNodes.length === 0) {
                            return '';
                        }
                        var val = node.childNodes[0].nodeValue;
                        return val.trim();
                    };

                    this.getNodeValues = function (node) {
                        if (node.childNodes.length === 0) {
                            return '';
                        }
                        var wholeVal = '';
                        for (var i = 0; i < node.childNodes.length; i++) {
                            var val = node.childNodes[i].nodeValue;
                            wholeVal += val;
                        }
                        return wholeVal.trim();
                    };

                    this.getNodeAttributeValue = function (node, attributeName) {
                        var val = node.getAttribute(attributeName);
                        if (val === null) {
                            val = '';
                        }
                        return val;
                    };

                    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
                        if (!defaultValue) {
                            defaultValue = 0;
                        }
                        var answer = defaultValue;
                        var val = this.getNodeAttributeValue(node, attributeName);

                        if (val.length > 0) {
                            if (val.indexOf('.') >= 0) {
                                answer = parseFloat(val);
                            }
                            else {
                                answer = parseInt(val);
                            }
                        }

                        return answer;
                    };

                    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
                        if (!defaultValue) {
                            defaultValue = false;
                        }
                        var answer = defaultValue;
                        var val = this.getNodeAttributeValue(node, attributeName);

                        if (val.length > 0) {
                            var char = val.toLowerCase().charAt(0);
                            answer = (char === 't');
                        }

                        return answer;
                    };

                    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
                        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
                        var subnode = this.getSubNode(parentNode, subNodeName);
                        if (subnode !== null) {
                            return this.getNodeValue(subnode);
                        }
                        return defaultValue;
                    };

                    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
                        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
                        var subnode = this.getSubNode(parentNode, subNodeName);
                        if (subnode !== null) {
                            return this.getNodeValues(subnode);
                        }
                        return defaultValue;
                    };

                    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
                        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

                        var value = this.getSubNodeValue(parentNode, subNodeName);
                        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
                            return true;
                        }
                        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
                            return false;
                        }
                        return defaultValue;
                    };
                };
                var helper = new VastXMLParserHelper();

                var companionAdsNode = helper.getSubNode(xmlDoc, 'CompanionAds');
                var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
                if (req && req.length > 0) {
                    companionAdsDest.required = req;
                }

                var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
                if (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        //var companion = JSON.parse(JSON.stringify(APN_Companion));
                        var companion = {};

                        // required attributes
                        var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
                        var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
                        if (width <= 0 || height <= 0) {
                            continue;
                        }
                        companion.width = width;
                        companion.height = height;

                        // optional attributes and subnodes
                        var val = helper.getNodeAttributeValue(node, 'id');
                        if (val) {
                            companion.id = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
                        if (val > 0) {
                            companion.assetWidth = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
                        if (val > 0) {
                            companion.assetHeight = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
                        if (val > 0) {
                            companion.expandedWidth = val;
                        }

                        val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
                        if (val > 0) {
                            companion.expandedHeight = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'apiFramework');
                        if (val) {
                            companion.apiFramework = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'adSlotID');
                        if (val) {
                            companion.adSlotID = val;
                        }

                        val = helper.getNodeAttributeValue(node, 'required');
                        if (val) {
                            companion.required = val;
                        }

                        val = helper.getSubNodeValue(node, 'AltText');
                        if (val) {
                            companion.AltText = val;
                        }

                        val = helper.getSubNodeValue(node, 'AdParameters');
                        if (val) {
                            companion.AdParameters = val;
                        }

                        var resource = helper.getSubNode(node, 'StaticResource');
                        if (resource) {
                            val = helper.getNodeAttributeValue(resource, 'creativeType');
                            if (val) {
                                // validate capability
                                var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
                                var isMobile = false;
                                if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
                                    isMobile = true;
                                }
                                if (isMobile && flashOnlyType) {
                                    // ignore this companion
                                    continue;
                                }

                                var staticResource = {type: val};
                                val = helper.getNodeValues(resource);
                                if (val) {
                                    staticResource.src = val;
                                    companion.StaticResource = staticResource;
                                }
                            }
                        }

                        val = helper.getSubNodeWholeValue(node, 'IFrameResource');
                        if (val) {
                            companion.IFrameResource = val;
                        }

                        val = helper.getSubNodeWholeValue(node, 'HTMLResource');
                        if (val) {
                            companion.HTMLResource = val;
                        }

                        val = helper.getSubNodeValue(node, 'CompanionClickThrough');
                        if (val) {
                            companion.CompanionClickThrough = val;
                        }

                        var j;
                        var trackingNode;
                        var url;
                        var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
                        if (clickTrackinEvents) {
                            companion.CompanionClickTracking = [];
                            for (j = 0; j < clickTrackinEvents.length; j++) {
                                trackingNode = clickTrackinEvents[j];
                                url = helper.getNodeValues(trackingNode);
                                if (url) {
                                    companion.CompanionClickTracking.push(url);
                                }
                            }
                        }

                        var trackinEvents = helper.getSubNodes(node, 'Tracking');
                        if (trackinEvents) {
                            companion.TrackingEvents = [];
                            for (j = 0; j < trackinEvents.length; j++) {
                                trackingNode = trackinEvents[j];
                                var event = helper.getNodeAttributeValue(trackingNode, 'event');
                                url = helper.getNodeValues(trackingNode);
                                if (event && url) {
                                    companion.TrackingEvents.push({eventType: event, url: url});
                                }
                            }
                        }

                        companionAdsDest.companions.push(companion);
                    }
                }
                return companionAdsDest;
            }
        };

        module.exports = CompanionAdsParser;

        /***/ },
    /* 40 */
    /***/ function(module, exports) {

        /**
         * DefaultOptions : default options for Outstream - define default option for Outstream which can be overrided if it deosn't exists
         * @type {{alignment: string, autoInitialSize: boolean, initialPlayback: string, initialAudio: string, playOnMouseover: boolean, audioOnMouseover: boolean, playVideoVisibleThreshold: number, enableExplicitPause: boolean, skippable: {enabled: boolean, videoThreshold: number, videoOffset: number, skipLocation: string, skipText: string, skipButtonText: string}, adText: string, showMute: boolean, showVolume: boolean, showProgressBar: boolean, allowFullscreen: boolean, expandTime: number, enableInlineVideoForIos: boolean, disableCollapse: boolean, topDividerColor: string, bottomDividerColor: string, topDividerWidth: number, bottomDividerWidth: number, delayExpandUntilVPAIDInit: boolean, delayExpandUntilVPAIDImpression: boolean, delayStartUntilNotified: boolean, nonViewableBehavior: string, waterfallTimeout: number, waterfallSteps: number, maxWaterfallIframes: number, adAttempt: number, fixedSizePlayer: boolean, sideStream: {enabled: boolean, position: string, xOffset: number, yOffset: number, space: string}, sideStreamObject: {}}}
         */
        module.exports = {
            "alignment": "center",
            "autoInitialSize": false,
            "initialPlayback": "auto",
            "initialAudio": "off",
            "playOnMouseover": false,
            "audioOnMouseover": true,
            "playVideoVisibleThreshold": 50,
            "enableExplicitPause": true,
            "skippable": {
                "enabled": true,
                "videoThreshold": 15,
                "videoOffset": 5,
                "skipLocation": "top-left",
                "skipText": "Video can be skipped in %%TIME%% seconds",
                "skipButtonText": "SKIP"
            },
            "adText": "Ad",
            "showMute": true,
            "showVolume": true,
            "showProgressBar": false,
            "allowFullscreen": true,
            "expandTime": 1000,
            "enableInlineVideoForIos": true,
            "disableCollapse": false,
            "topDividerColor": "#606060",
            "bottomDividerColor": "#606060",
            "topDividerWidth": 1,
            "bottomDividerWidth": 1,
            "delayExpandUntilVPAIDInit":true,
            "delayExpandUntilVPAIDImpression":false,
            "delayStartUntilNotified": false,
            "nonViewableBehavior":"mute",
            "waterfallTimeout": 15000,
            "waterfallSteps" : -1,
            "maxWaterfallIframes" : 6,
            "adAttempt" : 0,
            "fixedSizePlayer": false,
            "sideStream": {
                "enabled": false,
                "position": "bottom-right",
                "xOffset": 0,
                "yOffset": 0,
                "space": "empty"
            },
            "sideStreamObject":{},
            "enableNativeInline":false
        };

        /***/ },
    /* 41 */
    /***/ function(module, exports, __webpack_require__) {

        var Utils = __webpack_require__(42);
        var APN_Logger = __webpack_require__(2);
        var AdHandler = __webpack_require__(28);
        var SideStream = __webpack_require__(43);
        var MobileSupport = __webpack_require__(3).mobileSupport;
        var ViewableDetector = __webpack_require__(44);
        var PlayerManager_object = __webpack_require__(3);
        var debug = function (message) {
            APN_Logger.debug("[Outstream_Initialize]", message);
        };


        /**
         * Initialize : initialize routine to work with AdHandler
         * @param outstreamSelf
         * @returns {{start: "start", init: "init", setInitialVariable: "setInitialVariable", getTargetWindow: "getTargetWindow", checkTopWindow: "checkTopWindow"}}
         */
        module.exports = function (outstreamSelf) {
            return {
                "start": function () {


                    /**
                     * set animation speed
                     */
                    var setAnimation = function () {

                        if (outstreamSelf.isVideoRendered === true) {
                            return;
                        }
                        debug("video renderer is about to start");

                        var convertToSeconds = function (ms) {
                            if (ms < 0) {
                                return 0;
                            }
                            return ms / 1000;
                        };

                        outstreamSelf.animationSpeed = convertToSeconds(outstreamSelf.options.expandTime);
                        outstreamSelf.animationSpeed = (outstreamSelf.animationSpeed <= 0) ? 0.001 : outstreamSelf.animationSpeed;//because if it's under zero, transitionEnd event is not reliable
                        outstreamSelf.targetElement.style.overflow = "hidden";
                        outstreamSelf.targetElement.style.height = "0.1px";//required for detecting a timing to start expanding


                        if (Utils.isAndroid()) {
                            //for android4
                            outstreamSelf.targetElement.style.webkitTransition = "height " + outstreamSelf.animationSpeed + "s ease";
                        } else {
                            //for most of modern browser
                            outstreamSelf.targetElement.style.transition = "height " + outstreamSelf.animationSpeed + "s ease";
                        }


                    };
                    /**
                     * all object should be prepared before starting to detect right position for expanding
                     */
                    var setWindowEvents = function () {
                        debug("setWindowEvents");
                        debug("start out-stream-ad");

                        setAnimation();


                        if (Utils.isAndroid()) {
                            outstreamSelf.rWindowForPublisher.addEventListener("touchmove", outstreamSelf.detectAndPlay);
                            outstreamSelf.intervalIdForDetectAndPlay = setInterval(outstreamSelf.detectAndPlay, 100);//if it's in cross domain iframe environment, AST renderer will dispatch an event of top frame by parentIframeGeometryUpdate method
                        } else {
                            outstreamSelf.intervalIdForDetectAndPlay = setInterval(outstreamSelf.detectAndPlay, 100);//if it's in cross domain iframe environment, AST renderer will dispatch an event of top frame by parentIframeGeometryUpdate method
                        }

                        if (Utils.isMobile()) {
                            outstreamSelf.rWindowForPublisher.addEventListener("resize", outstreamSelf.fnRotationChange);
                        }


                        var isInIframe = (outstreamSelf.rWindowForPublisher === window.self) ? false : true;
                        isInIframe = !outstreamSelf.isWindowTopAccessible ? true : isInIframe;//override isInIframe

                        if (isInIframe) {
                            //new pause / resume by page view ability API
                            var hidden, visibilityChange;
                            if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support
                                hidden = "hidden";
                                visibilityChange = "visibilitychange";
                            } else if (typeof document.mozHidden !== "undefined") {
                                hidden = "mozHidden";
                                visibilityChange = "mozvisibilitychange";
                            } else if (typeof document.msHidden !== "undefined") {
                                hidden = "msHidden";
                                visibilityChange = "msvisibilitychange";
                            } else if (typeof document.webkitHidden !== "undefined") {
                                hidden = "webkitHidden";
                                visibilityChange = "webkitvisibilitychange";
                            }
                            var handleVisibilityChange = function () {
                                if (document[hidden]) {
                                    outstreamSelf.listenerBlur();
                                } else {
                                    outstreamSelf.listenerFocus();
                                }
                            };
                            document.addEventListener("visibilitychange", handleVisibilityChange, false);
                        } else {
                            outstreamSelf.triggerCheckFocus = outstreamSelf.rWindow.setInterval(function () {
                                if (document.hasFocus() && outstreamSelf.hasFocus === false) {
                                    outstreamSelf.listenerFocus();
                                    outstreamSelf.hasFocus = true;

                                } else if (!document.hasFocus() && outstreamSelf.hasFocus === true) {
                                    outstreamSelf.listenerBlur();
                                    outstreamSelf.hasFocus = false;
                                }
                            }, 500);
                        }
                    };
                    var initAdHandler = function () {
                        var cbAdunits = {
                            "cbWhenDestroy": outstreamSelf.terminateAll,
                            "cbWhenReady": function (VideoFramework) {
                                //overriding object by instiated video framework
                                outstreamSelf.playerManager = VideoFramework;
                                var adVideoPlayer = VideoFramework.adVideoPlayer;

                                if (VideoFramework.options.vpaid === false) {
                                    if (adVideoPlayer.type === "application/x-shockwave-flash") {
                                        outstreamSelf.videoPlayerObjectElement = adVideoPlayer;
                                        outstreamSelf.isFlash = true;
                                    } else {
                                        outstreamSelf.videoPlayerObjectElement = adVideoPlayer.player().el();
                                    }
                                }

                                if (adVideoPlayer.type !== "application/x-shockwave-flash" && outstreamSelf.playerManager.adVideoPlayer.on) {
                                    //catching fullscreen event
                                    outstreamSelf.playerManager.adVideoPlayer.on("fullscreenchange", outstreamSelf.handleFullscreen);
                                }

                                outstreamSelf.videoIsreadyToPlay = true;
                                if (outstreamSelf.firstAdAttempted) {
                                    outstreamSelf.cleanupPreviousFlashElement();
                                }
                                if (!Utils.isAndroid()) {
                                    if (outstreamSelf.isWindowTopAccessible) {
                                        outstreamSelf.detectAndPlay();
                                    }
                                }


                            },
                            "cbWhenImpression": function () {
                                outstreamSelf.options.impressionSent = true;
                            },
                            "cbWhenWaterfall": function (waterfallStatusObj) {
                                outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.waterfall, false, waterfallStatusObj);
                            },
                            "cbRenderVideo": function (cbAdunits, _options, _cbTimer) {
                                //common part to load video player
                                if (outstreamSelf.firstAdAttempted) {
                                    var attempt = outstreamSelf.options.adAttempt;
                                    outstreamSelf.playerManager = Object.create(PlayerManager_object);

                                    outstreamSelf.videoIsreadyToPlay = false;
                                    _options.isExpanded = outstreamSelf.isExpanded;
                                    // FirstAd already played the consecutive ads should play in a autoplay fashion.
                                    if (outstreamSelf.isExpanded && (_options.initialPlayback === "mouseover" || _options.initialPlayback === "click")) {
                                        _options.initialPlayback = "auto";
                                    }
                                    outstreamSelf.options = outstreamSelf.playerManager.init(_options);
                                    outstreamSelf.options.firstAdAttempted = true;
                                    outstreamSelf.options.adAttempt = ++attempt;
                                    outstreamSelf.cleanupTargetElement();
                                }
                                if (_cbTimer && outstreamSelf.isExpanded) {
                                    _cbTimer();
                                }
                                outstreamSelf.firstAdAttempted = true;
                                outstreamSelf.playerManager.buildPlayer(cbAdunits, outstreamSelf.options);

                                //initialize SideStream
                                outstreamSelf.sideStream = new SideStream(outstreamSelf, outstreamSelf.playerManager);

                                outstreamSelf.playerManager.options.sideStreamObject = outstreamSelf.sideStream;//injecting sideStream object
                            }
                        };
                        AdHandler(outstreamSelf.targetElement, outstreamSelf.options, cbAdunits);
                    };

                    initAdHandler();
                    setWindowEvents();
                },
                "init": function (_options) {


                    _options.initialAudio = "off";
                    _options.expandable = true;//to notify core video this will invoke expand / colapse event


                    //ES6 and BABEL test
                    //this.ES6_PROMISE_TEST = require("babel!./moduleTest.js6");
                    //outstreamSelf.ES6_PROMISE_TEST();


                    //initialize playerManager with options extended on adUnit level
                    //uses DEFAULT_OPTIONS_FOR_OUTSTREAM to create defaults for all outstream publisher options
                    outstreamSelf.options = outstreamSelf.playerManager.init(outstreamSelf.playerManager.ExtendDefaultOption(outstreamSelf.DEFAULT_OPTIONS_FOR_OUTSTREAM, _options));

                    outstreamSelf.originalSize.width = outstreamSelf.options.width;
                    outstreamSelf.originalSize.height = outstreamSelf.options.height;

                    outstreamSelf.disableCollapse = outstreamSelf.options.disableCollapse;
                    outstreamSelf.targetElementId = outstreamSelf.options.targetId;
                    outstreamSelf.ASTadId = outstreamSelf.options.ASTadId;
                    //if publisher option `delayStartUntilNotified` is true, we are not ready to play outstream until we get the ok from outside
                    //if its false, isOkToPlayFromPublisher is true, so no extra delay required
                    outstreamSelf.isOkToPlayFromPublisher = !outstreamSelf.options.delayStartUntilNotified;
                    outstreamSelf.isWindowTopAccessible = outstreamSelf.checkTopWindow();
                    outstreamSelf.rWindowForPublisher = outstreamSelf.getTargetWindow();

                    outstreamSelf.viewableDetector = new ViewableDetector();

                    if (!outstreamSelf.setInitialVariable()) {
                        return;//TODO should throw an error at this point
                    }

                    //for only Android auto-start
                    if (MobileSupport && MobileSupport.isRequiredFakeAndroidAutoStart && outstreamSelf.options && MobileSupport.isRequiredFakeAndroidAutoStart(outstreamSelf.options)) {
                        if (outstreamSelf.options.initialPlayback === "autoWithFallbackPlay") {
                            outstreamSelf.options.initialAudio = "off";
                            //autoplay, muted which are required items for fallback play will be set on Events.js in playerManager module with "autoWithFallbackPlay" options
                            outstreamSelf.createAndroidIframes("fallback", function() {
                                outstreamSelf.start();//start expadning, invoke explicitPlay (vpaid startAd)
                            });
                        } else {//only for android autostart - this will use Android auto-play trick to pre-resolve human activity
                            //callback when the trick finished
                            var resolveHumanTouch = function(type) {
                                outstreamSelf.createAndroidIframes(type, function() {
                                    outstreamSelf.start();//start expadning, invoke explicitPlay (vpaid startAd)
                                });
                            };
                            window.addEventListener("touchstart", function () {
                                resolveHumanTouch("touchstart");
                            }, {passive: true});//passive event will help to avoid race condition when both event happens at a time
                            window.addEventListener("touchend", function () {
                                setTimeout(function () {
                                    resolveHumanTouch("touchend");
                                }, 1);//to guaranty touchstart and touchend will be delived to a listener in order (touchstart first, touchend last)
                            }, {passive: true});//passive event will help to avoid race condition when both event happens at a time
                        }
                    } else {
                        outstreamSelf.start();

                        if (MobileSupport && MobileSupport.doesBrowserNeedUserActionToPlayVideo && MobileSupport.doesBrowserNeedUserActionToPlayVideo()) {
                            window.addEventListener("touchstart", function() {
                                if (outstreamSelf.doneUserActionForInitiateOutstream === false) {
                                    outstreamSelf.playerManager.adVideoPlayer.one("loadedmetadata",function() {
                                        outstreamSelf.doneUserActionForInitiateOutstream = true;
                                        debug("doneUserActionForInitiateOutstream by touchstart event for Chrome on iOS");
                                    });
                                    //this is only for previous version of Chrome (before Chrome 54, iOS10.1.x) which doesn't dispatch "loadedmetadata" event from html5 video element
                                    if (outstreamSelf.videoIsreadyToPlay === false) {//if video is already ready to play (caught loadedmetadata event) then not invoke load() any more
                                        outstreamSelf.playerManager.load();//forcing load and dispatch "loadedmetadata" event to Outstream
                                        debug("forcing load a video to dispatch loadedmetadata event for Chrome on iOS");
                                    }
                                }
                            });
                        }
                    }

                },
                "setInitialVariable": function () {
                    if (outstreamSelf.targetElementId && typeof outstreamSelf.targetElementId === "string") {
                        var publisherDiv = document.getElementById(outstreamSelf.targetElementId);

                        if (!publisherDiv) {
                            outstreamSelf.terminateAll(true);
                            return false;
                        } else {
                            outstreamSelf.targetElementId = outstreamSelf.targetElementId + "_apn_expandable_" + new Date().getTime() + Math.floor(Math.random() * 10000);
                            outstreamSelf.targetElement = document.createElement("div");
                            outstreamSelf.targetElement.id = outstreamSelf.targetElementId;
                            outstreamSelf.targetElement.style.cssText = "margin: 0;padding: 0;border: 0;font-size: 100%;font: inherit;vertical-align: baseline;";
                            publisherDiv.appendChild(outstreamSelf.targetElement);
                        }
                    } else {
                        outstreamSelf.terminateAll(true);
                        return false;
                    }

                    //reset margin after rendering document
                    //I'm not sure why we were setting the margin of the main page
                    //body... we should never be doing this.  Removing this code
                    //might cause regression issues, but I'd rather remove it and
                    //deal with that than have this behavior continue.  (-jweiss 12/2/2015)
                    //outstreamSelf.rWindow.document.body.style.margin = "0px";

                    if (outstreamSelf.options.alignment && outstreamSelf.options.alignment !== undefined) {
                        outstreamSelf.targetElement.style.textAlign = outstreamSelf.options.alignment;
                    }

                    return true;

                },
                "getTargetWindow": function () {
                    return outstreamSelf.isWindowTopAccessible ? top.window : window.self;
                },
                "checkTopWindow": function () {
                    //check if top.window is accessible
                    var result = true;

                    try {
                        var destWindow = top.window;
                        var checkInnerHeight = (destWindow.innerHeight || destWindow.documentElement.clientHeight);
                        var fnTest = function () {
                        };
                        destWindow.addEventListener("scroll", fnTest);
                        destWindow.removeEventListener("scroll", fnTest);
                        if (!destWindow || typeof destWindow !== "object" || typeof destWindow.addEventListener !== "function" || typeof checkInnerHeight !== "number") {
                            result = false;
                        }
                    } catch (ex) {
                        result = false;
                    }

                    return result;

                },
            };
        };












        /***/ },
    /* 42 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "Outstream_Utils";
        var APN_Logger = __webpack_require__(2);
        // var debug = function (message) {
        //     APN_Logger.verbose(message, prefixOfLog);
        // };
        var error = function (message) {
            APN_Logger.error(message, prefixOfLog);
        };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };




        var isMobile = function () {
            var index = navigator.appVersion.indexOf("Mobile");
            var indexForAndroid = navigator.appVersion.indexOf("Android");
            return (index > -1) || (indexForAndroid > -1);
        };

        var isAndroid = function () {
            return (/android/i.test(navigator.userAgent.toLowerCase()));
        };

        var isChrome = function () {
            return (navigator.userAgent.indexOf("Chrome") > -1);
        };

        var isFullScreen = function (playerManager) {

            if (playerManager.isFullscreen) {
                return true;
            }

            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                return (!window.screenTop && !window.screenY);
            } else {
                return false;
            }
        };


        var isValidNumberForHTML = function (str) {
            if (typeof(str) === "number") {
                return true;
            }
            if (str === undefined) {
                return false;
            }
            str = str.replace(/ /g, '');//remove all empty space
            return (isNaN(Number(str)) || str === "") ? false : true;
        };

        var fireCustomEvent = function (obj, eventName) {
            try {
                var event = new CustomEvent(eventName);
                obj.dispatchEvent(event);
            } catch (ex) {
                error(ex);
            }

        };

        var isIphone = function () {
            var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        };

        var isIos = function () {
            var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
            return isFlag;
        };


        module.exports = {
            isMobile: isMobile,
            isAndroid: isAndroid,
            isChrome: isChrome,
            isFullScreen: isFullScreen,
            isValidNumberForHTML: isValidNumberForHTML,
            fireCustomEvent: fireCustomEvent,
            isIos:isIos
        };

        /***/ },
    /* 43 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "SideStream";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(message, prefixOfLog);
        };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };

        var Utils = __webpack_require__(42);

        /**
         * SideStream for AdUnit (currently only support Outstream AdUnit
         * @param adUnit
         * @param playerManager
         * @constructor
         */
        var SideStream = function (adUnit, playerManager) {

            var zIndexOfSideStream = 2147483647;//largest positive value of a signed integer on a 32 bit operating systems
            var sideStreamSelf = this;

            this.options = adUnit.options;// required variables to be defined by adUnit
            this.playerManager = playerManager;// required variables to be defined by adUnit
            var timeIntervalForMoveback = 250;//interval to check when adunit move back to the original position
            this.isActivated = false;//flag to set sideStream is active
            this.targetElementForSideStream = sideStreamSelf.options.targetElement;
            // this.isDoneInitialMove = false;
            this.emptyDiv = {};//object for emptyDIV, this object will be passed as one of the attributes of plaerManager.options in order to check with resize for VID-1789
            this.isEmptySpaceInjected = false;//empty space injecting is required not to push/pull contents of publishers
            this.originalCSS = {
                position: "",
                top: "",
                bottom: "",
                left: "",
                right: "",
                marginLeft: "",
                marginRight: "",
                marginTop: "",
                marginBottom: "",
                offsetWidth: "",
                offsetHeight: "",
                transition: "",
                webkitTransition: "",
                height: "",
                width: ""
            };//for keeping original CSS of target element, it will be restored when it goes back to Outstream


            /**
             * save original css attribute which are related to side stream specific feature
             * @param element
             */
            this.saveOriginalCss = function (element) {
                var cssOfTargetElement = element.style;

                //save original css
                this.originalCSS = {
                    position: cssOfTargetElement.position,
                    top: cssOfTargetElement.top,
                    bottom: cssOfTargetElement.bottom,
                    left: cssOfTargetElement.left,
                    right: cssOfTargetElement.right,
                    marginLeft: cssOfTargetElement.marginLeft,
                    marginRight: cssOfTargetElement.marginRight,
                    marginTop: cssOfTargetElement.marginTop,
                    marginBottom: cssOfTargetElement.marginBottom,
                    offsetWidth: element.offsetWidth,
                    offsetHeight: element.offsetHeight,
                    transition: cssOfTargetElement.transition,
                    webkitTransition: cssOfTargetElement.webkitTransition,
                    height: cssOfTargetElement.height,
                    width: cssOfTargetElement.width
                };
            };

            /**
             * load original css attrubute from variables
             * @param element
             */
            this.loadOriginalCss = function (element) {


                var cssOfTargetElement = element.style;

                //load original css
                cssOfTargetElement.position = this.originalCSS.position;
                cssOfTargetElement.top = this.originalCSS.top;
                cssOfTargetElement.bottom = this.originalCSS.bottom;
                cssOfTargetElement.left = this.originalCSS.left;
                cssOfTargetElement.right = this.originalCSS.right;
                cssOfTargetElement.marginLeft = this.originalCSS.marginLeft;
                cssOfTargetElement.marginRight = this.originalCSS.marginRight;
                cssOfTargetElement.marginTop = this.originalCSS.marginTop;
                cssOfTargetElement.marginBottom = this.originalCSS.marginBottom;

                cssOfTargetElement.transition = this.originalCSS.transition;
                cssOfTargetElement.webkitTransition = this.originalCSS.webkitTransition;

                cssOfTargetElement.height = this.originalCSS.height;
                cssOfTargetElement.width = this.originalCSS.width;


            };

            /**
             * return true if sideStream should resize
             * @returns {boolean}
             */
            this.shouldCloseAdUnit = function () {
                var caseForDisableCollapse = playerManager.options.disableCollapse === true && playerManager.isSkipped === true;
                var caseWhenVideoCompleted = playerManager.options.disableCollapse === false && playerManager.isCompleted === true;

                return (caseForDisableCollapse || caseWhenVideoCompleted) ? true : false;
            };

            /**
             * move adunit back to the original position and have original css attribute which this module changed
             */
            this.moveAdUnitBack = function () {

                debug("moveAdUnitBack");

                sideStreamSelf.isActivated = false;

                //remove object in options
                if (sideStreamSelf.options.emptyDiv) {
                    delete(sideStreamSelf.options.emptyDiv);
                }


                //remove emptyDiv
                if (sideStreamSelf.isEmptySpaceInjected) {
                    var hasEmptyDivInParentElement = sideStreamSelf.options && sideStreamSelf.options.targetElement && sideStreamSelf.options.targetElement.parentElement && sideStreamSelf.options.targetElement.parentElement.contains(sideStreamSelf.emptyDiv);
                    if (hasEmptyDivInParentElement) {
                        sideStreamSelf.options.targetElement.parentElement.removeChild(sideStreamSelf.emptyDiv);
                    }
                }


                //load original css, this should be performed before resetting height, width of targetElementForSideStream to avoid a situation about VID-1914
                sideStreamSelf.loadOriginalCss(sideStreamSelf.targetElementForSideStream);

                //now Outstream should have original value of height
                if (sideStreamSelf.hasSizeForSideStream()) {
                    //ignore hieght, weight for styling
                    sideStreamSelf.targetElementForSideStream.style.height = "";
                    sideStreamSelf.targetElementForSideStream.style.width = "";
                }

                //resize canvase for iOS
                var resizeCallback = function () {
                    Utils.fireCustomEvent(sideStreamSelf.options.targetElement, "IOS_INLINE_RESIZE");
                    //load original css
                    sideStreamSelf.loadOriginalCss(sideStreamSelf.targetElementForSideStream);//this should move to up for VID-1914
                };

                sideStreamSelf.playerManager.resizeVideo(false, false, resizeCallback);

                adUnit.haveVideoThresholdForSideStream = false;

                if (sideStreamSelf.shouldCloseAdUnit()) {
                    sideStreamSelf.targetElementForSideStream.style.height = "0px";
                }

                if (sideStreamSelf.options.autoInitialSize && !Utils.isMobile()) {
                    Utils.fireCustomEvent(window,"resize");//invoke resize event to resize whole area
                }

            };

            /**
             * move adunit to side position depending on options, if options doesn't have right value it will have default values
             * and start Detection logic to move back when it's required
             */
            this.moveAdUnit = function () {

                debug("moveAdUnit to sidestream");
                sideStreamSelf.isActivated = true;

                var width = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).width;
                var height = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).height;


                sideStreamSelf.injectSpace();//this should be invoked at the beginning of this method because the emptySpace should have same height of the targetElement(Div- Outstream)

                this.saveOriginalCss(sideStreamSelf.targetElementForSideStream);
                sideStreamSelf.targetElementForSideStream.style.position = "fixed";
                sideStreamSelf.targetElementForSideStream.style.transition = "";
                sideStreamSelf.targetElementForSideStream.style.webkitTransition = "";

                var xOffset = sideStreamSelf.options.sideStream.xOffset;
                var yOffset = sideStreamSelf.options.sideStream.yOffset;

                //if offset of options doesn't hava valid number it will have default value as 0px
                xOffset = (Utils.isValidNumberForHTML(xOffset)) ? xOffset + "px" : "0px";
                yOffset = (Utils.isValidNumberForHTML(yOffset)) ? yOffset + "px" : "0px";

                //resize canvase
                var resizeCallback = function () {
                    if (Utils.isIos()) {
                        Utils.fireCustomEvent(sideStreamSelf.options.targetElement, "IOS_INLINE_RESIZE");
                    }

                };

                if (sideStreamSelf.hasSizeForSideStream()) {



                    sideStreamSelf.playerManager.resizeVideoForSideStream(width, height, resizeCallback);
                    //sideStreams could have own height by definiend by options
                    sideStreamSelf.targetElementForSideStream.style.width = width + "px";
                    sideStreamSelf.targetElementForSideStream.style.height = height + "px";


                } else {
                    sideStreamSelf.playerManager.resizeVideo(false, false, resizeCallback);
                }


                sideStreamSelf.targetElementForSideStream.style.zIndex = zIndexOfSideStream;
                switch (sideStreamSelf.options.sideStream.position.toLowerCase()) {
                    case "top-left" :
                        sideStreamSelf.targetElementForSideStream.style.top = "0px";
                        sideStreamSelf.targetElementForSideStream.style.bottom = "";
                        sideStreamSelf.targetElementForSideStream.style.left = "0px";
                        sideStreamSelf.targetElementForSideStream.style.right = "";
                        sideStreamSelf.targetElementForSideStream.style.marginLeft = xOffset;
                        sideStreamSelf.targetElementForSideStream.style.marginTop = yOffset;
                        break;
                    case "top-right" :
                        sideStreamSelf.targetElementForSideStream.style.top = "0px";
                        sideStreamSelf.targetElementForSideStream.style.bottom = "";
                        sideStreamSelf.targetElementForSideStream.style.left = "";
                        sideStreamSelf.targetElementForSideStream.style.right = "0px";
                        sideStreamSelf.targetElementForSideStream.style.marginRight = xOffset;
                        sideStreamSelf.targetElementForSideStream.style.marginTop = yOffset;
                        break;
                    case "bottom-left" :
                        sideStreamSelf.targetElementForSideStream.style.top = "";
                        sideStreamSelf.targetElementForSideStream.style.bottom = "0px";
                        sideStreamSelf.targetElementForSideStream.style.left = "0px";
                        sideStreamSelf.targetElementForSideStream.style.right = "";
                        sideStreamSelf.targetElementForSideStream.style.marginLeft = xOffset;
                        sideStreamSelf.targetElementForSideStream.style.marginBottom = yOffset;
                        break;
                    case "bottom-right" :
                        sideStreamSelf.targetElementForSideStream.style.top = "";
                        sideStreamSelf.targetElementForSideStream.style.bottom = "0px";
                        sideStreamSelf.targetElementForSideStream.style.left = "";
                        sideStreamSelf.targetElementForSideStream.style.right = "0px";
                        sideStreamSelf.targetElementForSideStream.style.marginRight = xOffset;
                        sideStreamSelf.targetElementForSideStream.style.marginBottom = yOffset;
                        break;
                    default :
                        sideStreamSelf.targetElementForSideStream.style.top = "";
                        sideStreamSelf.targetElementForSideStream.style.bottom = "0px";
                        sideStreamSelf.targetElementForSideStream.style.left = "";
                        sideStreamSelf.targetElementForSideStream.style.right = "0px";
                        sideStreamSelf.targetElementForSideStream.style.marginRight = xOffset;
                        sideStreamSelf.targetElementForSideStream.style.marginBottom = yOffset;
                        break;
                }


                sideStreamSelf.startDetection();


            };

            this.hasSizeForSideStream = function () {
                return (Utils.isValidNumberForHTML(sideStreamSelf.options.sideStream.width) || Utils.isValidNumberForHTML(sideStreamSelf.options.sideStream.height)) ? true : false;
            };


            /**
             * injectSpace : will inject empty space into the div with same size of original div
             */
            this.injectSpace = function () {
                debug("injectSpace");

                var heightOfTargetElement = (sideStreamSelf.options.sideStream.space === "remove") ? "" : sideStreamSelf.targetElementForSideStream.clientHeight + "px";
                var offsetWidthOfTargetElement = sideStreamSelf.targetElementForSideStream.clientWidth + "px";

                debug("inject : " + heightOfTargetElement);

                sideStreamSelf.emptyDiv = document.createElement("div");
                sideStreamSelf.emptyDiv.style.position = "";
                sideStreamSelf.emptyDiv.style.left = "";
                sideStreamSelf.emptyDiv.style.top = "";

                sideStreamSelf.emptyDiv.style.height = heightOfTargetElement;
                sideStreamSelf.emptyDiv.style.offsetWidth = offsetWidthOfTargetElement;

                sideStreamSelf.options.emptyDiv = sideStreamSelf.emptyDiv;//inject emptyDiv into option to share with playerManager in order to check resize for VID-1789

                //inject empty space into div
                sideStreamSelf.options.targetElement.parentElement.appendChild(sideStreamSelf.emptyDiv);


                sideStreamSelf.isEmptySpaceInjected = true;

            };

            /**
             * start elelemt detection logic to get back adUnit to original position
             */
            this.startDetection = function () {
                if (adUnit.isElementVisible(sideStreamSelf.emptyDiv) && sideStreamSelf.playerManager.isFullscreen === false) {
                    sideStreamSelf.moveAdUnitBack();
                } else {
                    setTimeout(sideStreamSelf.startDetection, timeIntervalForMoveback);
                }
            };


            /**
             * check page overlay for VID-1805
             * @returns {boolean}
             */
            this.checkPageOverlay = function () {

                var result = false;
                var areaOfWindow;
                var areaOfSideStream;
                var percentageOfArea;
                var maxPageOverlay = 100;//default value if it's not defined.

                if (sideStreamSelf.options.sideStream && sideStreamSelf.options.sideStream.maxPageOverlay) {
                    maxPageOverlay = "" + sideStreamSelf.options.sideStream.maxPageOverlay;
                    maxPageOverlay = Number(maxPageOverlay.replace("%", ""));
                }

                areaOfWindow = window.innerWidth * window.innerHeight;
                if (sideStreamSelf.hasSizeForSideStream()) {

                    var width = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).width;
                    var height = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).height;

                    areaOfSideStream = width * height;


                } else {
                    areaOfSideStream = (adUnit && adUnit.sizeObj && adUnit.sizeObj.finalSize) ? adUnit.sizeObj.finalSize.width * adUnit.sizeObj.finalSize.height : 0;
                }

                percentageOfArea = Math.round(areaOfSideStream / areaOfWindow * 100);

                if (maxPageOverlay !== null && percentageOfArea <= maxPageOverlay) {
                    result = true;
                }
                return result;
            };


            this.shouldNotResizeWhenSideStreamActivated = function () {
                return (playerManager.options.sideStream && playerManager.options.sideStream.enabled && sideStreamSelf.isActivated);
            };

            /**
             * getAspectRatioByPlayerSize to set aspect ratio by Outstream's width and height
             */
            this.getAspectRatioByPlayerSize = function () {
                var aspectRatio_ = 16 / 9;//default will be 16:9

                var width = (adUnit && adUnit.sizeObj && adUnit.sizeObj.finalSize) ? adUnit.sizeObj.finalSize.width : 0;
                var height = (adUnit && adUnit.sizeObj && adUnit.sizeObj.finalSize) ? adUnit.sizeObj.finalSize.height : 0;

                if (height > 0 && width > 0) {
                    aspectRatio_ = width / height;
                }
                // log("aspect ratio : " + aspectRatio_);
                return aspectRatio_;
            };


            /**
             * getWidthHeightConsideredByAspectRatio : this will calculate width, hiehgt by aspect ratio
             */
            this.getWidthHeightConsideredByAspectRatio = function (aspectRatio) {

                var width = 0;
                var height = 0;

                if (aspectRatio <= 0) {
                    debug("aspectRatio is inappropriate");
                    return null;
                }

                if (sideStreamSelf.options.sideStream.width && sideStreamSelf.options.sideStream.height) {
                    width = sideStreamSelf.options.sideStream.width;
                    height = sideStreamSelf.options.sideStream.height;
                } else {
                    width = sideStreamSelf.options.sideStream.width ? sideStreamSelf.options.sideStream.width : sideStreamSelf.options.sideStream.height / aspectRatio;
                    height = sideStreamSelf.options.sideStream.height ? sideStreamSelf.options.sideStream.height : sideStreamSelf.options.sideStream.width / aspectRatio;
                }

                // log("getWidthHeightConsideredByAspectRatio : " + width + "," + height);
                return {width: width, height: height};

            };


        };

        module.exports = SideStream;


        /***/ },
    /* 44 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "Outstream_ViewableDetector";
        var APN_Logger = __webpack_require__(2);
        // var debug = function (message) {
        //     APN_Logger.verbose(message, prefixOfLog);
        // };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        var info = function (message) {
            APN_Logger.info(message, prefixOfLog);
        };


        /**
         * ViewableDetector
         * @constructor
         */
        var ViewableDetector = function () {

            info("Initialize ViewableDetector");

            var limitOfRecusion = 100;//limit of recusrsion logic

            /**
             * element visible detection logic incuding iframe supporting
             * @param element : target element to check viewability
             * @param options : options in video framework
             * @param rWindowForPublisher : target window
             * @param isExpanded : special option for adunit
             * @param isWindowTopAccessible
             * @param iframeWindowHeight : this will keep set by publisher every some seconds if it's iframe case
             * @param iframeOffsetTop : this will keep set by publisher every some seconds if it's iframe case
             * @param customVisibleThreshold : to have spcific visibleThreshold for sideStream or custom element
             * @param customHeight : to have custom options.height for sideStream or custom element
             * @returns {boolean} true means an element is visible
             */
            this.isElementVisible = function (element, options, rWindowForPublisher, isExpanded, isWindowTopAccessible, iframeWindowHeight, iframeOffsetTop, customVisibleThreshold, customHeight) {

                var topWindowInnerHeight;
                var videoAreaOnIframe;
                var videoAreaOnIframePositionTop;
                var remainingDistanceToVideoArea;
                var remainingDistanceToVideoAreaByThreshold;
                var remainingDistanceToVideoAreaByThresholdReverse;
                var videoAreaPositionTop;
                var heightOfElement = (typeof(customHeight) !== "undefined") ? customHeight : options.height;
                var visibleThreshold = (typeof(customVisibleThreshold) !== "undefined") ? customVisibleThreshold / 100 : options.playVideoVisibleThreshold / 100;
                var adjustedPositionYByThreshold = heightOfElement * visibleThreshold;
                var adjustedPositionYByThresholdReverse = Number(heightOfElement) - (heightOfElement * visibleThreshold);
                var iframeOnTopWindowPositionTop = 0;
                var iframeValuebyRecusively = {top: 0};


                if (typeof(element) === "undefined" || element instanceof Element === false) {
                    return false;//for VID-1913
                }


                //if there's event from crossdomain it will be used
                if (!isWindowTopAccessible) {
                    topWindowInnerHeight = iframeWindowHeight;
                } else {
                    topWindowInnerHeight = rWindowForPublisher.innerHeight || rWindowForPublisher.documentElement.clientHeight;
                }
                var isInIframe = (rWindowForPublisher === window.self) ? false : true;

                isInIframe = !isWindowTopAccessible ? true : isInIframe;//override isInIframe

                if (isInIframe) {//for both crossdomain and friendly iframe cases

                    if (isWindowTopAccessible) {
                        //if Outstream is in the iframe
                        var getIframesRecursively = function (targetWindow, cntRecursion) {
                            if (targetWindow === rWindowForPublisher || cntRecursion <= 0) {
                                return;//exit out of this recusive routine
                            }
                            var iframes = targetWindow.parent.document.getElementsByTagName("iframe");
                            for (var i = 0; i < iframes.length; i++) {
                                var destIframe = iframes[i];
                                var destWindow = destIframe.contentWindow;
                                if (destWindow === targetWindow) {
                                    var iframePositionTop = destIframe.getBoundingClientRect().top;
                                    iframeValuebyRecusively.top += iframePositionTop;
                                    getIframesRecursively(destWindow.parent, --cntRecursion);
                                }
                            }
                        };
                        getIframesRecursively(window.self, limitOfRecusion);
                    } else {
                        iframeValuebyRecusively.top = iframeOffsetTop;
                    }

                    iframeOnTopWindowPositionTop = iframeValuebyRecusively.top - topWindowInnerHeight;
                    //distnace from iframe to videoArea
                    videoAreaOnIframe = element;
                    videoAreaOnIframePositionTop = videoAreaOnIframe.getBoundingClientRect().top;
                    remainingDistanceToVideoArea = iframeOnTopWindowPositionTop + videoAreaOnIframePositionTop;
                    remainingDistanceToVideoAreaByThreshold = iframeOnTopWindowPositionTop + videoAreaOnIframePositionTop + adjustedPositionYByThreshold;
                    remainingDistanceToVideoAreaByThresholdReverse = iframeOnTopWindowPositionTop + videoAreaOnIframePositionTop + adjustedPositionYByThresholdReverse;
                } else {
                    //if Outstream isn't in the iframe
                    videoAreaPositionTop = element.getBoundingClientRect().top - topWindowInnerHeight;
                    remainingDistanceToVideoArea = videoAreaPositionTop;
                    remainingDistanceToVideoAreaByThreshold = videoAreaPositionTop + adjustedPositionYByThreshold;
                    remainingDistanceToVideoAreaByThresholdReverse = videoAreaPositionTop + adjustedPositionYByThresholdReverse;

                }

                //for a moment to start expanding Outstream, only for forward scroll case
                if (!isExpanded && remainingDistanceToVideoArea < 0 && remainingDistanceToVideoArea > (-1 * heightOfElement)) {
                    return true;//after expanded, "isExpanded" will have true, so this routine wil be one time action in a life cycle of Outstream object
                }

                //pause case when video is placed on top of page by user scrolling
                if (remainingDistanceToVideoAreaByThresholdReverse < -1 * topWindowInnerHeight) {
                    return false;
                }

                if (!isExpanded && remainingDistanceToVideoAreaByThreshold < 0) {//reverse scroll case
                    return true;//after expanded, "isExpanded" will have true, so this routine wil be one time action in a life cycle of Outstream object
                }

                //pause case when video is placed on bottom of page
                //resume case when video is placed on (bottom and top) of page
                if (remainingDistanceToVideoAreaByThreshold < 0) {
                    return true;
                } else {
                    return false;
                }
            };


        };

        module.exports = ViewableDetector;


        /***/ },
    /* 45 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "Outstream_Events";
        var APN_Logger = __webpack_require__(2);
        // var debug = function (message) {
        //     APN_Logger.verbose(message, prefixOfLog);
        // };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        var info = function (message) {
            APN_Logger.info(message, prefixOfLog);
        };

        var Utils = __webpack_require__(42);


        /**
         * Termination : termination logic
         * @param outstreamSelf
         * @returns {Function}
         */
        module.exports = function(outstreamSelf) {

            return function (isError) {

                //VID-2146 remove empty space
                if (outstreamSelf.options.sideStream.enabled === true && outstreamSelf.sideStream && outstreamSelf.sideStream.isActivated === true) {
                    outstreamSelf.sideStream.moveAdUnitBack();
                    outstreamSelf.playerManager.isCompleted = true;
                }


                if (outstreamSelf.playerManager.forceToSkip) {//VID-1359 VID-1350
                    outstreamSelf.isAreadyTerminated = false;
                    outstreamSelf.playerManager.forceToSkip = false;
                }

                if (outstreamSelf.isAreadyTerminated) {return;}//check a flag to avoid double terminating


                info("terminate all elements");

                //remove all event
                outstreamSelf.rWindow.clearInterval(outstreamSelf.triggerCheckFocus);
                outstreamSelf.rWindowForPublisher.removeEventListener("resize", outstreamSelf.fnRotationChange);

                if (outstreamSelf.isWindowTopAccessible) {
                    outstreamSelf.rWindowForPublisher.removeEventListener("scroll", outstreamSelf.detectAndPlay);
                    outstreamSelf.rWindowForPublisher.removeEventListener("touchmove", outstreamSelf.detectAndPlay);
                }

                if (outstreamSelf.intervalIdForDetectAndPlay) {
                    outstreamSelf.rWindowForPublisher.clearInterval(outstreamSelf.intervalIdForDetectAndPlay);
                }


                //safe termination during change fullscreen state
                var limitAttemptTermination = 3000;
                var currentAttemptTermination = 0;

                outstreamSelf.disableCollapse = (outstreamSelf.disableCollapse && !outstreamSelf.playerManager.isSkipped && !outstreamSelf.isTerminatedByPublisher);//change more standard way


                var performTermination = function () {

                    if (outstreamSelf.playerManager) {
                        outstreamSelf.playerManager.delayEventHandler.lazyTerminate();//this will push a function to terminate timer into a queue
                    }


                    if (!Utils.isFullScreen(outstreamSelf.playerManager)) {
                        //we might be calling this multiple times, so let's make sure targetElement
                        //still exists before we access it
                        if (outstreamSelf.targetElement) {
                            outstreamSelf.targetElement.textContent = '';
                            outstreamSelf.targetElement = undefined;
                        }
                        outstreamSelf.eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);
                    } else {
                        //wait until entirely exit fullscreen
                        if (currentAttemptTermination <= limitAttemptTermination) {
                            setTimeout(function () {
                                currentAttemptTermination += 500;
                                performTermination();
                            }, 500);
                        } else {
                            //if player cannot exit from fullscreen, just perform explicitPause and invoke eventCB to AST
                            //because if it's in fullscreen, then try to remove innerContent then it will cause freeze problem
                            outstreamSelf.playerManager.isCompleted = true;
                            outstreamSelf.playerManager.explicitPause();
                            outstreamSelf.targetElement = null;
                            outstreamSelf.eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);

                            return;
                        }

                    }
                };


                var fnTerminateImmediately = function () {

                    //move back to outstream from sidestream
                    if (outstreamSelf.options.sideStream.enabled === true && outstreamSelf.sideStream) {
                        outstreamSelf.sideStream.moveAdUnitBack();
                    }


                    // exit full-screen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }

                    if (!outstreamSelf.disableCollapse) {

                        if (outstreamSelf.isExpanded) {
                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseStart);
                            outstreamSelf.targetElement.style.overflow = "hidden";
                            //css transition start
                            outstreamSelf.targetElement.style.height = "0px";

                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseEnd);

                        }
                        performTermination();//terminate and invoke eventCB for AST
                    }
                    else {
                        outstreamSelf.eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);
                    }

                    if (!isError) {
                        outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
                    }




                };


                var fnTerminateSmoothly = function () {
                    outstreamSelf.playerManager.isCompleted = true;
                    outstreamSelf.sendPauseSignalToVideoPlayerExplicit();

                    //performTermination will invoke so commented out following lines
                    //eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);

                    if (!outstreamSelf.disableCollapse) {


                        var handleCollapseEnd = function (e) {
                            /*jshint -W059 */
                            //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                            e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
                            /*jshint -W059 */

                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseEnd);

                            performTermination();

                            if (!outstreamSelf.isAlreadyCompleted && !isError && !outstreamSelf.isTerminatedByPublisher) {
                                outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
                            }
                        };

                        //for modern browser
                        outstreamSelf.targetElement.addEventListener("transitionend", function (e) {
                            handleCollapseEnd(e);
                            /*jshint -W059 */
                            //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                            e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
                            /*jshint -W059 */
                        });


                        //for old firefox
                        outstreamSelf.targetElement.addEventListener("mozTransitionEnd", function (e) {
                            handleCollapseEnd(e);
                            /*jshint -W059 */
                            //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                            e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
                            /*jshint -W059 */
                        });

                        //for webkit
                        outstreamSelf.targetElement.addEventListener("webkitTransitionEnd", function (e) {
                            handleCollapseEnd(e);
                            /*jshint -W059 */
                            //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                            e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
                            /*jshint -W059 */
                        });

                        //for opera
                        outstreamSelf.targetElement.addEventListener("oTransitionEnd", function (e) {
                            handleCollapseEnd(e);
                            /*jshint -W059 */
                            //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                            e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
                            /*jshint -W059 */
                        });


                        //An event to handle css transition should be defined before starting the transition to make sure it's reliable
                        if (outstreamSelf.isExpanded) {
                            //start css transition
                            outstreamSelf.targetElement.style.height = "0px";
                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseStart);
                        }

                    }
                    else {

                        if (!isError && !outstreamSelf.isTerminatedByPublisher) {
                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
                        }
                        outstreamSelf.isAlreadyCompleted = true;
                    }


                };


                //exit fullscreen if it's on fullscreen
                if (Utils.isFullScreen(outstreamSelf.playerManager)) {
                    fnTerminateImmediately();
                } else {
                    fnTerminateSmoothly();
                }
                outstreamSelf.isAreadyTerminated = true;
                setTimeout(function () {
                    if (!outstreamSelf.isCollapseEnd && outstreamSelf.isCollapseStart) {
                        outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseEnd);
                    }

                    if (!outstreamSelf.isAdComplete && !isError && !outstreamSelf.isTerminatedByPublisher) {
                        outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
                    }
                }, outstreamSelf.options.expandTime + outstreamSelf.TIME_TO_REVERIFY);//if collapseEnd and adComplete isn't happened until outstream.options.expandTime +(TIME_TO_REVERIFY)  Outstream will regards it's done and send callback notification. this is for when css transition is failed on some devices

            };



        };



        /***/ },
    /* 46 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "[Outstream_Mobile]";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(prefixOfLog, message);
        };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };


        var Utils = __webpack_require__(42);
        var MobileSupport = __webpack_require__(3).mobileSupport;

        /**
         * Mobile : mobile related feature like fullscreen, resize
         * @param outstreamSelf
         * @returns {{createAndroidIframes: "createAndroidIframes", handleFullscreen: "handleFullscreen", fnRotationChange: "fnRotationChange", resizeOutstreamArea: "resizeOutstreamArea"}}
         */
        module.exports = function (outstreamSelf) {

            return {
                "createAndroidIframes": function (type, callback) {
                    if (outstreamSelf.hasDoneFakingAutoStartForAndroid) {
                        //debug("ignored a request to create iframes for Android autoplay by " + type + " due to it's already completed by other events");
                        return;
                    }
                    debug("create iframes for Android autoplay by " + type);
                    //calculate number of total placements
                    var steps = 1;
                    if (!outstreamSelf.options.waterfallSteps || outstreamSelf.options.waterfallSteps === -1) {
                        // if waterfall steps is set to infinite, then we will create maximum of 5 Android iframes
                        // for resolving Autoplay on android.
                        steps = outstreamSelf.options.maxWaterfallIframes;
                    } else {
                        steps = outstreamSelf.options.waterfallSteps + 1;
                    }
                    debug("total " + steps + " iframes will be made by waterfall structure with " + type + " event");
                    var iframes = [];
                    //loop to resolve all placements's video element
                    for (var i = 0; i < steps; i++) {
                        var name = "";
                        if (i === 0) {
                            name = MobileSupport.APN_OUTSTREAM_IFRAME_NAME;
                        } else {
                            name = MobileSupport.APN_OUTSTREAM_IFRAME_NAME + "_Waterfall_" + i;
                        }
                        var iframeVideoWrapper = document.createElement("iframe");
                        document.getElementById(outstreamSelf.targetElementId).appendChild(iframeVideoWrapper);
                        //generate body tag
                        var html = "<body></body>";
                        iframeVideoWrapper.contentWindow.document.open();
                        iframeVideoWrapper.contentWindow.document.write(html);
                        iframeVideoWrapper.contentWindow.document.close();
                        //set name
                        iframeVideoWrapper.name = name;
                        iframeVideoWrapper.style.display = "none";

                        debug("iframes injected for waterfall steps #" + (i + 1) + " by " + type);
                        iframes.push(iframeVideoWrapper);//keep it on array
                    }
                    //pass iframe array to a method
                    if (iframes && Array.isArray(iframes) && iframes.length >= 1) {
                        MobileSupport.prepareVideoPlacementsForMobile(iframes, type, callback, outstreamSelf);
                    }
                },
                "handleFullscreen": function () {
                    debug("handleFullscreen");
                    if (outstreamSelf.shouldResizeByFullscreenChange) {
                        setTimeout(function () {
                            outstreamSelf.playerManager.resizeVideo(-1);
                            outstreamSelf.resizeOutstreamArea();

                            if (Utils.isAndroid()) {
                            } else {
                                outstreamSelf.playerManager.play();
                            }

                            outstreamSelf.shouldResizeByFullscreenChange = false;
                        }, 500);
                    }
                },
                "fnRotationChange": function () {//this method is a event handler for "window.resize" when Outstream renders in mobile device it will be invoked whenever rotation changes
                    debug("fnRotationChange");
                    //for VID
                    var shouldNotResizeWhenSideStreamActivated = outstreamSelf.playerManager.options.sideStreamObject && typeof(outstreamSelf.playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? outstreamSelf.playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
                    if (shouldNotResizeWhenSideStreamActivated || outstreamSelf.isExpanded !== true) {
                        return;
                    }


                    if (outstreamSelf.videoIsreadyToPlay) {//this pre-existing flag in Outstream object will be set to true when video player sends callback to notify video is ready to play and default is false

                        if (outstreamSelf.options.autoInitialSize) {
                            outstreamSelf.options.width = outstreamSelf.options.targetElement.offsetWidth;
                        }

                        if (Utils.isMobile() && !outstreamSelf.playerManager.isIosInlineRequired() && Utils.isFullScreen(outstreamSelf.playerManager)) {//if mobile, ios7, fullscreen
                            //this is relative with iOS7 mobile safari's bug. if some object has changed behind the fullscreen, it will break the content.show ugly screen
                            //don't resizeVideo when iOS7 ipad is in fullscreen, resize action should be delayed after exit out of fullscreen
                            outstreamSelf.shouldResizeByFullscreenChange = true;//if this flag set true, after fullscreen change, event handler(handleFullscreen) will resize video
                        } else {

                            if (outstreamSelf.playerManager && outstreamSelf.playerManager.isIosInlineRequired && outstreamSelf.playerManager.isIosInlineRequired()) {
                                //do nothing if it's in iOS inline video player
                            } else {
                                outstreamSelf.playerManager.resizeVideo(-1);
                                outstreamSelf.resizeOutstreamArea();
                            }

                        }
                    }

                },
                "resizeOutstreamArea": function () {
                    debug("resizeOutstreamArea");
                    //for VID-1047
                    if (outstreamSelf.playerManager && outstreamSelf.playerManager.isFullscreen && outstreamSelf.playerManager.isCompleted && Utils.isAndroid()) {
                        return;
                    }

                    //iOS can fire "resize" event during scrolling because of their own address bar appearing/disappearing
                    //so following code should be excuted when video is ready to go (when AdLoaded event came from VPAID creative if it's VPAID case)
                    outstreamSelf.targetElement.style.height = outstreamSelf.options.height + "px";

                    var videoObject = document.getElementById(outstreamSelf.playerManager.videoObjectId);
                    if (videoObject && typeof videoObject !== undefined) {
                        videoObject.style.width = outstreamSelf.options.width;
                        videoObject.style.height = outstreamSelf.options.height;
                    }
                }
            };
        };

        /***/ },
    /* 47 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "Outstream_Waterfall";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(message, prefixOfLog);
        };
        // var error = function (message) {
        //     APN_Logger.error(message, prefixOfLog);
        // };
        // var info = function (message) {
        //     APN_Logger.info(message, prefixOfLog);
        // };

        var Utils = __webpack_require__(42);
        var MobileSupport = __webpack_require__(3).mobileSupport;

        /**
         * Waterfall : waterfall related logic
         * @param outstreamSelf
         * @returns {{cleanupTargetElement: "cleanupTargetElement", cleanupPreviousFlashElement: "cleanupPreviousFlashElement"}}
         */
        module.exports = function (outstreamSelf) {

            return {
                "cleanupTargetElement": function () {
                    debug("cleanupTargetElement");
                    var elm = outstreamSelf.options.targetElement;
                    if(Utils.isAndroid()){
                        if( elm && elm.hasChildNodes()){
                            //For Android usecase clear off previous iframes
                            var iframeList = elm.getElementsByTagName("iframe");
                            var name = MobileSupport.APN_OUTSTREAM_IFRAME_NAME + "_Waterfall_"+outstreamSelf.options.adAttempt;
                            for (var i=0;i<iframeList.length;i++) {
                                var iframe = iframeList[i];
                                if (iframe && iframe.name && iframe.name === name) {
                                    var prevIframe = iframe.parentNode.firstChild;
                                    iframe.parentNode.removeChild(prevIframe);
                                }
                            }
                        }
                    }else {
                        if (elm && elm.hasChildNodes()) {
                            var waterfallMaskElement = document.getElementById("waterfall_mask");
                            var width = elm.clientWidth;
                            var height = elm.clientHeight;
                            for (var cnt = 0; cnt < elm.childNodes.length; cnt++) {
                                // do not remove Flash immediately
                                if (elm.childNodes[cnt].type !== "application/x-shockwave-flash" && elm.childNodes[cnt].id !== "waterfall_mask") {
                                    width = elm.childNodes[cnt].clientWidth;
                                    height = elm.childNodes[cnt].clientHeight;
                                    elm.removeChild(elm.childNodes[cnt]);
                                }
                            }
                            //insertMask
                            if (!waterfallMaskElement) {
                                waterfallMaskElement = document.createElement("div");
                                waterfallMaskElement.id = "waterfall_mask";
                                waterfallMaskElement.style.cssText = "display:inline-block; margin: 0;padding: 0;border: 0; background-color: #000;";
                                elm.appendChild(waterfallMaskElement);
                                waterfallMaskElement.style.width = width + "px";
                                waterfallMaskElement.style.height = height + "px";
                            }
                        }
                    }
                },
                "cleanupPreviousFlashElement": function() {
                    debug("cleanupPreviousFlashElement");
                    var elm = outstreamSelf.options.targetElement;
                    if(elm && elm.hasChildNodes() && elm.childNodes.length >1){
                        var currentElm = null;
                        if (outstreamSelf.playerManager.adVideoPlayer && outstreamSelf.playerManager.adVideoPlayer.type === "application/x-shockwave-flash") {
                            currentElm = document.getElementById(outstreamSelf.playerManager.adVideoPlayer.id);//elm.lastChild;
                        }
                        var cnt =0;
                        var length = elm.childNodes.length;
                        while(cnt<length){
                            if(elm.firstChild !== currentElm && elm.firstChild.type === "application/x-shockwave-flash"){
                                elm.removeChild(elm.firstChild);
                            } else if(elm.firstChild.id === "waterfall_mask"){
                                elm.removeChild(elm.firstChild);
                            }
                            cnt++;
                        }
                    }
                },
            };
        };

        /***/ },
    /* 48 */
    /***/ function(module, exports, __webpack_require__) {

        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.debug(message, "Outstream_ExternalInterface");
        };

        /**
         * ExternalInterface : all external interfaces and callback notifications
         * @param outstreamSelf
         * @returns {{handleMessage: "handleMessage", parentIframeGeometryUpdate: "parentIframeGeometryUpdate", handleOkToPlayAd: "handleOkToPlayAd", cbNotification: "cbNotification", eventCB: "eventCB", cbNotification_internal: "cbNotification_internal", eventCB_internal: "eventCB_internal", reportFinalSize: "reportFinalSize"}}
         */
        module.exports = function (outstreamSelf) {
            return {
                "handleMessage": function (messageName, messagePayload) {
                    debug("messageName : " + messageName);
                    debug("messagePayload : " + messagePayload);
                    switch (messageName) {
                        case "okToPlayAd":
                            outstreamSelf.handleOkToPlayAd();
                            break;
                        case "terminate":
                            debug("Ad terminated by external AST message");
                            outstreamSelf.isTerminatedByPublisher = true;
                            outstreamSelf.terminateAll(false);
                            break;
                        default:
                            break;
                    }
                },
                "parentIframeGeometryUpdate": function (e) {
                    //Outstream's offsetTop : offsetTop - scrollY;
                    //Outstream's windowHeight : windowHeight
                    if (e && e.offsetTop && e.scrollY && e.windowHeight) {
                        outstreamSelf.currentEventFromCrossDomainWindow.offsetTop = e.offsetTop - e.scrollY;
                        outstreamSelf.currentEventFromCrossDomainWindow.windowHeight = e.windowHeight;
                    }
                },
                "handleOkToPlayAd": function () {
                    outstreamSelf.isOkToPlayFromPublisher = true;
                    outstreamSelf.detectAndPlay();
                },
                "cbNotification": function (param, isError, obj) {
                    if (isError) {//all VAST callback should be suppressed until video expended
                        outstreamSelf.playerManager.delayEventHandler.push(function () {
                            outstreamSelf.cbNotification_internal(param, isError, obj);
                        });
                    } else {
                        outstreamSelf.cbNotification_internal(param, isError, obj);
                    }
                },
                "eventCB": function (ASTadId, eventName, options_, errObj) {
                    outstreamSelf.eventCB_internal(ASTadId, eventName, options_, errObj);
                },
                "cbNotification_internal": function (param, isError, obj) {

                    //define function to call options.cbNotification
                    if (outstreamSelf.options.hasOwnProperty('cbNotification')) {
                        if (!isError) {
                            outstreamSelf.options.cbNotification('AdUnit', param, outstreamSelf.options.targetId, obj);
                            if (param === "collapseStart") {
                                outstreamSelf.isCollapseStart = true;
                            }
                            if (param === "collapseEnd") {
                                outstreamSelf.isCollapseEnd = true;
                            }
                            if (param === "adComplete") {
                                outstreamSelf.isAdComplete = true;
                            }
                            if (param === "expandStart") {//VID-2844 for viewaibiltiy
                                outstreamSelf.playerManager.dispatchEventToAdunit({"name": "expand"});
                            }
                            if (param === "collapseEnd") {//VID-2844 for viewaibiltiy
                                outstreamSelf.playerManager.dispatchEventToAdunit({"name": "collapse"});
                            }
                        } else {
                            outstreamSelf.options.cbNotification('VAST', param, outstreamSelf.options.targetId);
                        }
                    }
                },
                "eventCB_internal": function (ASTadId, eventName, options_, errObj) {
                    debug("invoke eventCB to " + ASTadId + " with '" + eventName + "' event");
                    try {
                        if (options_ && typeof options_.eventCB === "function") {
                            options_.eventCB(ASTadId, eventName, options_);
                        }
                        if (eventName === outstreamSelf.cbType.error) {
                            if (errObj && errObj.code === 1) {
                                outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.timeout, false);
                            }
                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.error, true);
                        }
                    } catch (ex) {
                        debug(ex);
                    }
                },
                "reportFinalSize": function () {
                    var finalSize = outstreamSelf.playerManager.getFinalSize();
                    outstreamSelf.sizeObj = {
                        originalSize: {width: outstreamSelf.originalSize.width, height: outstreamSelf.originalSize.height},
                        finalSize: {width: finalSize.width, height: finalSize.height}
                    };

                    debug("options delivered from impbus : autoInitialSize=" + outstreamSelf.options.autoInitialSize + ", playerAspectRatio=" + outstreamSelf.options.playerAspectRatio + ", playerHeight(deprecated)=" + outstreamSelf.options.playerHeight);
                    debug("size delivered from impbus (width,height) : " + outstreamSelf.sizeObj.originalSize.width + "," + outstreamSelf.sizeObj.originalSize.height);
                    debug("size finalized by player (width,height) : " + outstreamSelf.sizeObj.finalSize.width + "," + outstreamSelf.sizeObj.finalSize.height);

                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.size, false, outstreamSelf.sizeObj);
                }
            };
        };

        /***/ },
    /* 49 */
    /***/ function(module, exports, __webpack_require__) {

        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.debug(message, "Outstream_Media");
        };

        /**
         * Media : control video with playerManager
         * @param outstreamSelf
         * @returns {{isPlayingVideo: "isPlayingVideo", sendPlaySignalToVideoPlayerExplicit: "sendPlaySignalToVideoPlayerExplicit", sendPlaySignalToVideoPlayer: "sendPlaySignalToVideoPlayer", sendPauseSignalToVideoPlayerExplicit: "sendPauseSignalToVideoPlayerExplicit", sendPauseSignalToVideoPlayer: "sendPauseSignalToVideoPlayer"}}
         */
        module.exports = function (outstreamSelf) {
            return {
                "isPlayingVideo": function () {
                    /**
                     * getting status of video
                     * @returns {boolean} return true if video is playing
                     */
                    if (outstreamSelf.playerManager) {
                        var result = outstreamSelf.playerManager.isPlayingVideo;
                        return result;
                    } else {
                        return false;
                    }

                },
                "sendPlaySignalToVideoPlayerExplicit": function () {
                    /**
                     * interfaces to video player
                     */
                    if (outstreamSelf.options.initialPlayback !== "auto" && !outstreamSelf.playerManager.isDoneInitialPlay) {
                        return;
                    }
                    if (!outstreamSelf.isPlayingVideo()) {
                        if (typeof outstreamSelf.playerManager.play === "function") {
                            outstreamSelf.playerManager.explicitPlay();
                            debug("sendPlaySignalToVideoPlayerExplicit");
                        }
                    }
                },
                "sendPlaySignalToVideoPlayer": function () {
                    /**
                     * interfaces to video player
                     */
                    if (outstreamSelf.options.initialPlayback !== "auto" && !outstreamSelf.playerManager.isDoneInitialPlay) {
                        return;
                    }
                    if (!outstreamSelf.isPlayingVideo()) {
                        if (typeof outstreamSelf.playerManager.play === "function" && !outstreamSelf.playerManager.explicitPaused) {
                            outstreamSelf.playerManager.play();
                            debug("sendPlaySignalToVideoPlayer");
                        }
                    }
                },
                "sendPauseSignalToVideoPlayerExplicit" : function () {
                    /**
                     * sendPauseSignalToVideoPlayer
                     */
                    if (outstreamSelf.isPlayingVideo()) {
                        if (typeof outstreamSelf.playerManager.explicitPause === "function") {
                            outstreamSelf.playerManager.explicitPause();
                        }
                        debug("sendPauseSignalToVideoPlayerExplicit");
                    }
                },
                "sendPauseSignalToVideoPlayer" : function () {
                    if (outstreamSelf.isPlayingVideo()) {
                        if (typeof outstreamSelf.playerManager.pause === "function") {
                            outstreamSelf.playerManager.pause();
                        }
                        debug("sendPauseSignalToVideoPlayer");
                    }
                },
            };
        };





        /***/ },
    /* 50 */
    /***/ function(module, exports, __webpack_require__) {

        var prefixOfLog = "Outstream_Events";
        var APN_Logger = __webpack_require__(2);
        var debug = function (message) {
            APN_Logger.verbose(message, prefixOfLog);
        };
        var error = function (message) {
            APN_Logger.error(message, prefixOfLog);
        };
        var info = function (message) {
            APN_Logger.info(message, prefixOfLog);
        };

        var Utils = __webpack_require__(42);

        /**
         * Events : event handling and adUnit behavior
         * @param outstreamSelf
         * @returns {{listenerBlur: "listenerBlur", listenerFocus: "listenerFocus", expandArea: "expandArea", detectAndPlay: "detectAndPlay", isElementVisible: "isElementVisible"}}
         */
        module.exports = function(outstreamSelf) {
            return {
                "listenerBlur" : function () {
                    if (outstreamSelf.playerManager.toggleWindowFocus === false) {//ks : if window already lost a focus this logic don't need to execute again for VID-2556
                        return;
                    }
                    if (!Utils.isFullScreen(outstreamSelf.playerManager) && outstreamSelf.playerManager.isPlayingVideo) {
                        outstreamSelf.sendPauseSignalToVideoPlayer();
                        outstreamSelf.playerManager.toggleWindowFocus = false;//set toggle flag for VID-2556
                        info("pause a video by leaving a focus from the window");
                    }

                },
                "listenerFocus" : function () {
                    if (outstreamSelf.playerManager.toggleWindowFocus === true) {//ks : if window already has focus don't need to do again for VID-2556
                        return;
                    }
                    var customVisibleThreshold = 1;//check whole element for detecting outstream is in video
                    var customHeight = (outstreamSelf.options.sideStream && outstreamSelf.options.sideStream.height && outstreamSelf.haveVideoThresholdForSideStream) ? outstreamSelf.options.sideStream.height : outstreamSelf.options.height;//if side stream is activated use the height of sideStream
                    var isVisibleAndFocus = outstreamSelf.isElementVisible(outstreamSelf.targetElement,customVisibleThreshold, customHeight);
                    if (outstreamSelf.playerManager) {
                        outstreamSelf.playerManager.isViewable = isVisibleAndFocus;
                    }
                    if (outstreamSelf.isExpanded && isVisibleAndFocus) {
                        outstreamSelf.sendPlaySignalToVideoPlayer();
                        outstreamSelf.playerManager.toggleWindowFocus = true;//set toggle flag for VID-2556
                    }
                    info("resume a video by having a focus on the window");
                },
                "setIsExpanded": function(val) {
                    //this is silly
                    outstreamSelf.isExpanded = val;
                    outstreamSelf.playerManager.isExpanded = val;
                },
                "expandArea" : function () {
                    info("expand outstream area");

                    //for fix VID-1028 playbuzz unfriendly iframe issue with iOS
                    //main reason is an early invokation of Outstream.init cause unexpected 0 value as targetELement.offsetWidth when unfriendly iframe on playBuzz like 3rd party pages - www.playbuzz.com/mtveditorial10/taylor-swift-or-taylor-momsen-who-sang-these-lyrics?feed=true&src=http://www.playbuzz.com/mtveditorial10/taylor-swift-or-taylor-momsen-who-sang-these-lyrics&comments=undefined&divId=div0&articleCanonicalUrl=http%3A%2F%2Fwww.mtv.com%2Fnews%2F2876759%2Ftaylor-swift-momsen-pretty-reckless-lyrics-quiz%2F&width=640&height=auto&recommend=false&game=mtveditorial10/taylor-swift-or-taylor-momsen-who-sang-these-lyrics&useShares=false&useComments=false&gameInfo=false&embedBy=85b7478f-3761-4e11-be16-d1d587ba4c73&social=true&socialReferrer=false&pbads_debug=1&pbads_preview=test.outstream&pageLoadTrackerId=69787948938852610&shouldTrackLoading=true&parentHost=www.mtv.com&parentUrl=http%3A%2F%2Fwww.mtv.com%2Fnews%2F2876759%2Ftaylor-swift-momsen-pretty-reckless-lyrics-quiz%2F%3Fpbads_debug%3D1%26pbads_preview%3Dtest.outstream%26ast_debug%3Dtrue&referral=
                    if (Utils.isMobile() && outstreamSelf.playerManager.isIosInlineRequired() && !outstreamSelf.isWindowTopAccessible) {//this will be performed with only iOS and unfriendly iframe case
                        Utils.fireCustomEvent(outstreamSelf.options.targetElement, "IOS_INLINE_REFERESH");//this event will re-get offsetWidth of targetElement and resize video
                    }

                    //An event to handle css transition should be defined before starting the transition to make sure it's reliable
                    //invoke expandEnd when expand completed
                    outstreamSelf.targetElement.addEventListener("transitionend", function (e) {
                        if (!outstreamSelf.isExpandTransitionCompleted) {
                            outstreamSelf.isExpandTransitionCompleted = true;
                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.expandEnd);
                            if (outstreamSelf.options.initialPlayback !== "auto") {
                                outstreamSelf.playerManager.delayEventHandler.suppress(false);
                            }
                        }
                        /*jshint -W059 */
                        //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                        e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
                        /*jshint -W059 */

                        outstreamSelf.reportFinalSize();
                    });

                    if (Utils.isChrome() && outstreamSelf.isFlash) {
                        //avoid situation to show ugly animation when it's blocked by Chrome
                        outstreamSelf.targetElement.style.position = "relative";
                        outstreamSelf.targetElement.addEventListener("transitionend", function (e) {
                            if (outstreamSelf.options.initialPlayback !== "auto") {
                                outstreamSelf.playerManager.delayEventHandler.suppress(false);
                            }
                            outstreamSelf.targetElement.style.left = "-0.1px";
                            /*jshint -W059 */
                            //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
                            e.target.removeEventListener(e.type, arguments.callee);
                            /*jshint -W059 */
                            setTimeout(function () {
                                outstreamSelf.targetElement.style.left = "0px";
                                outstreamSelf.isExpandedWhenFlash = true;
                            }, 1);

                        });
                    }

                    //notify expandStart
                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.expandStart);

                    //css transition start
                    outstreamSelf.targetElement.style.height = outstreamSelf.options.height + "px";


                    //protection logic if it's in iOS and if transiotnEnd is not reliable
                    var gapOfRecheckTransition = 500;
                    setTimeout(function () {
                        if (!outstreamSelf.isExpandTransitionCompleted && outstreamSelf.targetElement.style.height === outstreamSelf.options.height + "px") {
                            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.expandEnd);
                            outstreamSelf.reportFinalSize();
                            outstreamSelf.isExpandTransitionCompleted = true;
                            if (outstreamSelf.options.initialPlayback !== "auto") {
                                outstreamSelf.playerManager.delayEventHandler.suppress(false);
                            }
                        }
                    }, outstreamSelf.animationSpeed * 1000 + gapOfRecheckTransition);


                    //if succeeded?
                    outstreamSelf.setIsExpanded(true);


                    if (outstreamSelf.options.vpaid) {
                        outstreamSelf.playerManager.dispatchEventToAdunit({"name": "creative-view"});
                    }



                },
                "detectAndPlay" : function () {

                    if (outstreamSelf.videoIsreadyToPlay !== true || outstreamSelf.isAreadyTerminated) {//this videoIsreadyToPlay will set after got cbWhenReady from playerManager
                        return;//for VID-2106
                    }

                    if (Object.keys && Object.keys(outstreamSelf.playerManager).length === 0) {
                        // if playerManager is an emoty object, we are not ready to expand or load yet
                        return;
                    }

                    if (!outstreamSelf.isDoneLoadVideo) {
                        try {

                            var willGoWithIosInline = Utils.isIos() && outstreamSelf.options.enableInlineVideoForIos === true;
                            if (willGoWithIosInline === false) {//ios inline has their own video.load part
                                outstreamSelf.playerManager.load();
                            }

                            outstreamSelf.isDoneLoadVideo = true;
                        } catch (ex) {
                            error(ex);
                        }
                    }

                    //if video area is not expended, start to expend and play video
                    var elementIsVisible = outstreamSelf.isElementVisible(outstreamSelf.targetElement);
                    if (outstreamSelf.playerManager) {
                        outstreamSelf.playerManager.isViewable = elementIsVisible;
                    }

                    if (outstreamSelf.isExpanded === false && outstreamSelf.videoIsreadyToPlay && elementIsVisible && outstreamSelf.isOkToPlayFromPublisher) {

                        if (outstreamSelf.options.initialPlayback === "auto") {
                            outstreamSelf.playerManager.isPlayingVideo = false;      // force to set playing flag to false, make sure the video will play (one time deal)
                        }

                        //expanda area
                        outstreamSelf.expandArea();

                        outstreamSelf.eventCB(outstreamSelf.ASTadId, outstreamSelf.cbType.impression, outstreamSelf.options);
                        //tigger loaded and impression at the same time
                        //this might change in the future, but for now let's leave it
                        outstreamSelf.eventCB(outstreamSelf.ASTadId, outstreamSelf.cbType.loaded, outstreamSelf.options);
                        outstreamSelf.setIsExpanded(true);
                        outstreamSelf.playerManager.pausedByViewability = true;

                        info("ready to start to play a video by videopausedByViewability true");

                        return;
                    }


                    //behaviors if video area is already expended
                    if (outstreamSelf.isExpanded) {
                        //for script
                        elementIsVisible = outstreamSelf.isElementVisible(outstreamSelf.targetElement);

                        //activate sideStream if it should
                        if (outstreamSelf.playerManager.isFullscreen === false && elementIsVisible === false && outstreamSelf.playerManager.isCompleted === false && outstreamSelf.doneInitialPlayback && outstreamSelf.options.sideStream.enabled === true && outstreamSelf.sideStream && outstreamSelf.haveVideoThresholdForSideStream === false && outstreamSelf.sideStream.checkPageOverlay() === true && outstreamSelf.options.impressionSent) {//for VID-1805, side stream activation needs to do checkPageOverlay()

                            if (outstreamSelf.playerManager.isFullscreenToggled === true && Utils.isMobile() === false) {
                                return;//for VID-2558 VID-2554 Desktop Safari, Firefox response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation. and it is set by playerManager
                            }

                            if (Utils.isIos() && outstreamSelf.options.enableInlineVideoForIos === false) {
                                //not activate sideStream if enableInlineVideoForIos is false in iOS
                            } else {
                                if (Utils.isChrome() && outstreamSelf.isFlash) {//flash has a delay logic to set style.left and it can intefere with sideStream feature, so should wait until isExpandedWhenFlash is true at the case
                                    if (outstreamSelf.isExpandedWhenFlash) {
                                        outstreamSelf.sideStream.moveAdUnit();
                                        outstreamSelf.haveVideoThresholdForSideStream = true;

                                    }
                                } else {
                                    outstreamSelf.sideStream.moveAdUnit();
                                    outstreamSelf.haveVideoThresholdForSideStream = true;
                                }
                                return;//don't need to pause/mute if sideStream is activated
                            }
                        }

                        if (outstreamSelf.haveVideoThresholdForSideStream === true && outstreamSelf.sideStream.checkPageOverlay() === true) {//to avoid to go pause/mute if sidestream is alreay enabled.
                            outstreamSelf.playerManager.isViewable = true;//for VID-1926 SideStream should be considered as always visible because it has fixed css attribute;
                            return;
                        }

                        //a logic for mute by scroll
                        //this is for VID-1081, VID-1013
                        if (outstreamSelf.playerManager.isFullscreen && outstreamSelf.playerManager.isMuted && outstreamSelf.playerManager.hasBeenUnmuted) {
                            outstreamSelf.playerManager.unmute();
                            outstreamSelf.isMutedByViewability = false;
                            outstreamSelf.playerManager.mutedByViewability = false;
                        } else if (outstreamSelf.options.nonViewableBehavior === "mute" && (outstreamSelf.playerManager && outstreamSelf.playerManager.isFullscreen === false) && !outstreamSelf.playerManager.isPaused) {
                            if (elementIsVisible && outstreamSelf.isMutedByViewability === true) {
                                outstreamSelf.playerManager.unmute();
                                outstreamSelf.isMutedByViewability = false;
                                outstreamSelf.playerManager.mutedByViewability = false;

                                if (outstreamSelf.options.initialPlayback === "auto") {
                                    outstreamSelf.playerManager.delayEventHandler.suppress(false);
                                }

                            } else if (elementIsVisible === false && outstreamSelf.isMutedByViewability === false && outstreamSelf.playerManager.isMuted === false) {
                                outstreamSelf.playerManager.mute();
                                outstreamSelf.isMutedByViewability = true;
                                outstreamSelf.playerManager.mutedByViewability = true;
                            }

                            if (outstreamSelf.doneInitialPlayback) {
                                elementIsVisible = true;
                            }
                        }

                        if (outstreamSelf.playerManager) {
                            outstreamSelf.playerManager.isViewable = elementIsVisible;
                        }

                        //a logic for pause by scroll
                        if (elementIsVisible) {
                            if (outstreamSelf.playerManager.pausedByViewability) {
                                if (outstreamSelf.options.initialPlayback === "auto") {
                                    outstreamSelf.playerManager.delayEventHandler.suppress(false);
                                }
                                outstreamSelf.sendPlaySignalToVideoPlayerExplicit();
                                outstreamSelf.playerManager.pausedByViewability = false;
                                debug("set pausedByViewability false");
                                outstreamSelf.doneInitialPlayback = true;
                                if (Utils.isAndroid()) {
                                    outstreamSelf.rWindowForPublisher.removeEventListener("touchmove", outstreamSelf.detectAndPlay);
                                    outstreamSelf.intervalIdForDetectAndPlay = setInterval(outstreamSelf.detectAndPlay, 50);//if it's in cross domain iframe environment, AST renderer will dispatch an event of top frame by parentIframeGeometryUpdate method
                                }

                            } else if(outstreamSelf.firstAdAttempted && outstreamSelf.videoIsreadyToPlay && !outstreamSelf.playerManager.isDoneInitialPlay) {
                                outstreamSelf.sendPlaySignalToVideoPlayerExplicit();
                            }
                        } else {
                            if (!Utils.isFullScreen(outstreamSelf.playerManager)) {
                                if (outstreamSelf.playerManager.isDoneInitialPlay && outstreamSelf.playerManager.pausedByViewability === false && !outstreamSelf.playerManager.explicitPaused) {//VID-1795
                                    outstreamSelf.sendPauseSignalToVideoPlayerExplicit();
                                    debug("set pausedByViewability true");
                                    outstreamSelf.playerManager.pausedByViewability = true;
                                }
                            }
                        }

                    }


                },
                "isElementVisible" : function (element, customVisibleThreshold, customHeight) {
                    return outstreamSelf.viewableDetector.isElementVisible(
                        element,
                        outstreamSelf.options,
                        outstreamSelf.rWindowForPublisher,
                        outstreamSelf.isExpanded,
                        outstreamSelf.isWindowTopAccessible,
                        outstreamSelf.currentEventFromCrossDomainWindow.windowHeight,
                        outstreamSelf.currentEventFromCrossDomainWindow.offsetTop,
                        customVisibleThreshold,
                        customHeight
                    );
                }
            };
        };





        /***/ }
    /******/ ]);